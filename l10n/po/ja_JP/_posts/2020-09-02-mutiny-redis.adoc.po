# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-04-29 21:23+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: YAML Front Matter: author
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:1
#, fuzzy, no-wrap
msgid "cescoffier"
msgstr "クスコフィエ"

#. type: YAML Front Matter: date
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:1
#, fuzzy, no-wrap
msgid "2020-09-02"
msgstr "2020-09-02"

#. type: YAML Front Matter: layout
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:1
#, fuzzy, no-wrap
msgid "post"
msgstr "ポスト"

#. type: YAML Front Matter: synopsis
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:1
#, fuzzy, no-wrap
msgid "How to compose asynchronous actions with Mutiny"
msgstr "Mutinyで非同期アクションを構成する方法"

#. type: YAML Front Matter: tags
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:1
#, fuzzy, no-wrap
msgid "reactive mutiny redis"
msgstr "リアクティブ・ミューティニー・レディス"

#. type: YAML Front Matter: title
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:1
#, fuzzy, no-wrap
msgid "Using Redis with Mutiny - Composing asynchronous actions"
msgstr "MutinyでRedisを使う - 非同期アクションを構成する"

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:11
#, fuzzy
msgid "I got an interesting question from a user about Redis and Mutiny. While the problem was not specifically about Redis and could be applied to many other APIs, I found the context amusing."
msgstr "RedisとMutinyについて、ユーザーから面白い質問を受けました。その問題はRedisに特化したものではなく、他の多くのAPIにも適用できるものでしたが、私はその文脈が面白いと感じました。"

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:13
#, fuzzy
msgid "Enrico, the user, wanted to do something like this:"
msgstr "ユーザーのEnricoさんは、こんなことをしたいと思っていたそうです。"

#. type: delimited block -
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:20
#, no-wrap
msgid ""
"1. get all keys from Redis\n"
"2. for each key -> retrieve the associated object\n"
"3. add this object to a JsonArray \n"
"4. produce the JsonArray with all the objects\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:23
#, fuzzy
msgid "Enrico is using the Mutiny variant of the Vert.x Redis Client."
msgstr "Enrico氏は、Vert.x Redis ClientのMutinyバージョンを使用しています。"

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:25
#, fuzzy
msgid "This client offers a few methods to help us with our problem:"
msgstr "このクライアントは、私たちの問題を解決するためのいくつかの方法を提供しています。"

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:27
#, fuzzy
msgid "the `RedisClient.keys(pattern)` method returning `Uni<JsonArray>`. This array contains the list of keys matching a pattern passed to the `keys` method. To simplify this post, let's use: `keys(\"*\")` returning all the keys."
msgstr "`Uni<JsonArray>` を返す `RedisClient.keys(pattern)` メソッドです。この配列には、 `keys` メソッドに渡されたパターンにマッチするキーのリストが含まれています。この記事を簡単にするために、すべてのキーを返す `keys(\"*\")` を使ってみましょう。"

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:28
#, fuzzy
msgid "the `RedisClient.hgetall(key)` method returning a `Uni<JsonObject>`. This method retrieves the object associated with the passed key."
msgstr "を返す `RedisClient.hgetall(key)` メソッドは、 `Uni<JsonObject>` 。このメソッドは、渡されたキーに関連するオブジェクトを取得します。"

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:30
#, fuzzy
msgid "Both methods are asynchronous (they return `Uni`), and we need to call the second one for each retrieved key. In other words, we need to iterate over the set of keys, and for each key to invoke an asynchronous action. Finally, we want to collect the result of these asynchronous actions into a `JsonArray`."
msgstr "どちらのメソッドも非同期であり（ `Uni` を返します）、取得したキーごとに2番目のメソッドを呼び出す必要があります。言い換えれば、キーのセットを反復し、各キーに対して非同期アクションを呼び出す必要があります。最後に、これらの非同期アクションの結果を `JsonArray` に集めたいと思います。"

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:32
#, fuzzy
msgid "Let's start with the beginning; we need the Redis Client instance:"
msgstr "まず最初に、Redisクライアントのインスタンスが必要になります。"

#. type: delimited block -
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:38
#, no-wrap
msgid ""
"RedisClient redis = RedisClient.create(vertx, new JsonObject()\n"
"     .put(\"port\", 6379)\n"
"     .put(\"host\", \"localhost\"));\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:41
#, fuzzy
msgid "Note that in Quarkus, you should use the Redis extension directly, which exposes a similar API. Enrico wanted to use the Vert.x Redis Client directly."
msgstr "なお、Quarkusでは、同様のAPIを公開しているRedisエクステンションを直接使用する必要があります。EnricoはVert.x Redis Clientを直接使用したいと考えていました。"

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:43
#, fuzzy
msgid "Now that we have our client, let's retrieve the list of keys:"
msgstr "さて、クライアントができたので、キーのリストを取得してみましょう。"

#. type: delimited block -
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:47
#, no-wrap
msgid "Uni<JsonArray> keys = redis.keys(\"*\")\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:50
#, fuzzy
msgid "That produces the `JsonArray`, but we want a stream of keys.  Again, it's an asynchronous method. The returned `Uni` receives the array when it's available. Once received (`onItem`), we can create a stream out of this array:"
msgstr "これは `JsonArray` を生成しますが、私たちはキーのストリームが欲しいのです。繰り返しますが、これは非同期のメソッドです。返された `Uni` は、配列が利用可能になると、それを受け取ります。受信したら( `onItem`)、この配列からストリームを作成することができます。"

#. type: delimited block -
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:56
#, no-wrap
msgid ""
"Multi<String> keys = redis.keys(\"*\")\n"
"     .onItem().transformToMulti(array -> Multi.createFrom().iterable(array))\n"
"     .onItem().castTo(String.class);\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:59
#, fuzzy
msgid "This snippet:"
msgstr "このスニペット。"

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:61
#, fuzzy
msgid "retrieves the `JsonArray` containing the keys"
msgstr "キーを含む `JsonArray` を取得します。"

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:62
#, fuzzy
msgid "creates a `Multi` streaming these keys, it's a `Multi<Object>` as a `JsonArray` is extending `Iterable<Object>`"
msgstr "は、これらのキーをストリーミングして `Multi` を作成すると、 `JsonArray` が拡張されるように `Multi<Object>` になります。 `Iterable<Object>`"

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:63
#, fuzzy
msgid "maps the items from this `Multi` to `String`"
msgstr "は、この `Multi` のアイテムをマッピングします。 `String`"

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:65
#, fuzzy
msgid "At this point, we have a stream of (String) keys. So, we are done with step 1."
msgstr "この時点で、（String）キーのストリームができました。これで、ステップ1は終了です。"

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:67
#, fuzzy
msgid "Now, step 2: for each key, we want to retrieve the associated object."
msgstr "さて、ステップ2ですが、各キーに対して、関連するオブジェクトを取得したいと思います。"

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:69
#, fuzzy
msgid "So let's use the `hgetall` method:"
msgstr "そこで、 `hgetall` の方法を使ってみましょう。"

#. type: delimited block -
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:74
#, no-wrap
msgid ""
"Multi<JsonObject> objects = keys\n"
"  .onItem().transformToUniAndMerge(key -> redis.hgetall(key));\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:77
#, fuzzy
msgid "This snippet requires a bit of an explanation."
msgstr "このスニペットにはちょっとした説明が必要です。"

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:79
#, fuzzy
msgid "For each item of the stream `keys`, we call `hgetall`, which produces a `Uni<JsonObject>`."
msgstr "ストリーム `keys` の各アイテムに対して、 `hgetall` を呼び出し、 `Uni<JsonObject>` を生成します。"

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:81
#, fuzzy
msgid "So, we want to transform our key into a Uni (*transformToUni*)."
msgstr "そこで、キーをUniに変換したいと思います *（transformToUni）*。"

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:83
#, fuzzy
msgid "When you have a stream of items and need to invoke an asynchronous action for each item, you must choose how you will merge the results. Mutiny provides two strategies:"
msgstr "アイテムのストリームがあり、各アイテムに対して非同期アクションを呼び出す必要がある場合、結果をどのようにマージするかを選択する必要があります。Mutinyには2つの戦略があります。"

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:85
#, fuzzy, no-wrap
msgid "*merge -* as soon as the item produced by the `Uni` is received we send it downstream\n"
msgstr "*マージ -* `Uni` で作成されたアイテムを受信したらすぐに下流に送る"

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:86
#, fuzzy, no-wrap
msgid "*concatenate* - we preserve the order of the input stream to be sure that the items are sent downstream in the same order\n"
msgstr "*concatenate*- 入力ストリームの順序を保持し、アイテムが同じ順序で下流に送られるようにします。"

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:88
#, fuzzy
msgid "Let's illustrate this. Imagine we have the keys `1`, `2`, `3` and to the stream `{1, 2, 3}`. Also, let's consider that in our Redis database, the key `1` is associated to `A`, `2` to `B` and `3` to `C`."
msgstr "これを説明しましょう。キー `1`, `2`, `3` と、ストリーム `{1, 2, 3}` があるとします。また、Redisデータベースでは、キー `1` が `A` に、 `2` が `B` に、 `3` が `C` に関連付けられていることを考えてみましょう。"

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:90
#, fuzzy
msgid "If you use the *merge* strategy, we are retrieving the associated objects in an undetermined order. We can end up with `{A, C, B}` or `{B, A, C}`. It depends on many factors, such as the latency, scheduling, load and so on. However, it also means we can retrieve all the associated objects concurrently and produce the resulting stream without taking care of the order."
msgstr "*マージ*戦略を使用した場合、関連するオブジェクトを不確定な順序で取得しています。 `{A, C, B}` や `{B, A, C}` になってしまうこともあります。これは、レイテンシー、スケジューリング、負荷などの多くの要因に依存します。しかし、これは、順序を気にすることなく、すべての関連オブジェクトを同時に取得し、結果のストリームを生成することができることを意味します。"

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:92
#, fuzzy
msgid "If you use the *concatenate* strategy, it preserves the order from the input stream. So, it will always produce `{A, B, C}`. While it may be desirable, it may reduce the ability to retrieve the object concurrently, as Mutiny has to *wait* for all the retrieval of all the previous objects. For example, if Mutiny receives `C` first, it needs to wait for `A` and `B` before sending `C` downstream."
msgstr "*コンカチネイト*戦略を使用すると、入力ストリームからの順序が保持されます。そのため、常に `{A, B, C}` を生成します。それは望ましいことかもしれませんが、Mutinyがすべての前のオブジェクトの取得を *待た*なければならないため、オブジェクトを同時に取得する能力が低下する可能性があります。たとえば、Mutinyが最初に `C` を受け取った場合、 `C` を下流に送る前に、 `A` と `B` を待つ必要があります。"

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:94
#, fuzzy
msgid "In our context, let's not preserve the order and use the *merge* strategy. So we use `transformToUniAndMerge`."
msgstr "ここでは、注文を維持せず、 *マージ*戦略を使用します。そこで、 `transformToUniAndMerge` を使います。"

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:96
#, fuzzy
msgid "If you run the code multiple times, you might see order changes in the resulting array."
msgstr "このコードを複数回実行すると、結果の配列に順序の変化が見られるかもしれません。"

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:98
#, fuzzy
msgid "Ok, step 2 done. Let's focus on the final steps: accumulate the objects into a `JsonArray`, and produce a `Uni<JsonArray>`, containing all the objects. Mutiny provides methods to gather items from a stream into lists, maps, sets, but there is no built-in `JsonArray` support. Fortunately, Mutiny offers a method that you can use to collect items in any structure:"
msgstr "OK、ステップ2が完了しました。最後のステップに注目しましょう。オブジェクトを `JsonArray` に蓄積し、すべてのオブジェクトを含む `Uni<JsonArray>` を生成します。Mutinyはストリームからアイテムをリスト、マップ、セットに集めるメソッドを提供していますが、ビルトインの `JsonArray` サポートはありません。幸いなことに、Mutinyには任意の構造でアイテムを集めるのに使えるメソッドがあります。"

#. type: delimited block -
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:103
#, no-wrap
msgid ""
"Uni<JsonArray> result = objects\n"
"   .collectItems().in(() -> new JsonArray(), (arr, obj) -> arr.add(obj));\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:106
#, fuzzy
msgid "`collectItems().in` allows accumulating the items in your own structure. It takes two parameters: a supplier of the structure, called only once, and a bi-consumer taking the structure and the item to add, called for each item."
msgstr "`collectItems().in` では、自分の構造体にアイテムを蓄積することができます。これは2つのパラメータを取ります。構造体の供給者は1度だけ呼ばれ、構造体と追加するアイテムを取る両消費者は各アイテムごとに呼ばれます。"

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:108
#, fuzzy
msgid "Here we go, we have everything to solve Enrico's question."
msgstr "これで、エンリコの質問を解決するためのすべてが揃いました。"

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:110
#, fuzzy
msgid "The *all in one* code is the following:"
msgstr "*オールインワン・*コードは以下の通りです。"

#. type: delimited block -
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:122
#, no-wrap
msgid ""
"Uni<JsonArray> result = \n"
"  // Step 1 - retrieve the keys\n"
"  redis.keys(\"*\") \n"
"    .onItem().transformToMulti(keys -> Multi.createFrom().iterable(keys))\n"
"    .onItem().castTo(String.class)\n"
"  // Step 2 - retrieve the associated object for each key\n"
"    .onItem().transformToUniAndMerge(key -> redis.hgetall(key))\n"
"  // Step 3 and 4 - accumulate the retrieved object in a JsonArray\n"
"    .collectItems().in(() -> new JsonArray(), (arr, obj) -> arr.add(obj));\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:125
#, fuzzy
msgid "In this snippet, there are a few interesting patterns:"
msgstr "このスニペットには、いくつかの興味深いパターンがあります。"

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:127
#, fuzzy
msgid "When you have a collection, and you want to iterate on it with Mutiny, transform it into a `Multi`"
msgstr "コレクションがあり、それをMutinyで反復処理したい場合、それを次のように変換します。 `Multi`"

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:128
#, fuzzy
msgid "When you execute asynchronous action for each item of a stream, think about *merge* vs. *concatenate.* Use the one that makes sense for you."
msgstr "ストリームの各アイテムに対して非同期アクションを実行する場合、 *マージ*と *コンカチネイト*のどちらを使うかを考えます。 自分にとって意味のある方を使いましょう。"

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:129
#, fuzzy
msgid "To accumulate items into a structure, use `collectItems`, it offers many methods to produce your structure of choice."
msgstr "アイテムを構造体に蓄積するには、 `collectItems` を使用します。 は、好きな構造体を作るための多くの方法を提供します。"

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:131
#, fuzzy
msgid "If you want to see this code in action, check this https://gist.github.com/cescoffier/e8c8a18897f9e5ca15f1378876a1bd93[gist]. You even can run it directly with JBang:"
msgstr "このコードを実際に見てみたい方は、こちらの link:https://gist.github.com/cescoffier/e8c8a18897f9e5ca15f1378876a1bd93[gist]をご覧ください。JBangで直接実行することもできます。"

#. type: delimited block -
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:135
#, no-wrap
msgid "jbang https://gist.github.com/cescoffier/e8c8a18897f9e5ca15f1378876a1bd93\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:138
#, fuzzy
msgid "You can replace *merge* with *concatenate* to see the difference."
msgstr "*マージ*を *コンカチネイト*に置き換えると、その違いがわかります。"

#. type: Plain text
#: upstream/_posts/2020-09-02-mutiny-redis.adoc:139
msgid "Enjoy!"
msgstr "楽しんで!"

#, fuzzy
#~ msgid "---\n"
#~ msgstr "---\n"

#, fuzzy
#~ msgid ""
#~ "layout: post\n"
#~ "title: 'Using Redis with Mutiny - Composing asynchronous actions'\n"
#~ "date: 2020-09-02\n"
#~ "tags: reactive mutiny redis\n"
#~ "synopsis: How to compose asynchronous actions with Mutiny\n"
#~ "author: cescoffier\n"
#~ "---\n"
#~ msgstr ""
#~ "layout: post\n"
#~ "title: 'Using Redis with Mutiny - Composing asynchronous actions' (英語)\n"
#~ "date: 2020-09-02\n"
#~ "tags: reactive mutiny redis\n"
#~ "synopsis: Mutinyで非同期アクションを構成する方法\n"
#~ "author: cescoffier\n"
#~ "---\n"

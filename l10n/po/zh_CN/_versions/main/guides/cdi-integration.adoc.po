# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-10-12 02:16+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_versions/main/guides/cdi-integration.adoc:6
#, no-wrap
msgid "CDI Integration Guide"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:19
msgid "ArC, the CDI container in Quarkus, is bootstrapped at build time.  To integrate with the container, https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#spi_lite[CDI Build Compatible Extensions, window=\"_blank\"] can be used, as well as a Quarkus-specific extension API.  CDI Portable Extensions are not and cannot be supported.  This guide focuses on the Quarkus-specific extensions API."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:22
msgid "The container is bootstrapped in multiple phases.  From a high level perspective these phases go as follows:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:24
msgid "Initialization"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:25
msgid "Bean discovery"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:26
msgid "Registration of synthetic components"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:27
msgid "Validation"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:34
msgid "In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.  _Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.  Subsequently, the extensions can register _synthetic components_.  Attributes of these components are fully controlled by the extensions, i.e. are not derived from an existing class.  Finally, the _deployment is validated_.  For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:36
msgid "You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X` or `--debug` and grep the lines that contain `io.quarkus.arc`. In the xref:cdi-reference.adoc#dev-mode[development mode], you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:39
msgid "Quarkus build steps can produce and consume various build items and hook into each phase.  In the following sections we will describe all the relevant build items and common scenarios."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cdi-integration.adoc:40
#, no-wrap
msgid "Metadata Sources"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:47
msgid "Classes and annotations are the primary source of bean-level metadata.  The initial metadata are read from the _bean archive index_, an immutable https://github.com/wildfly/jandex[Jandex index, window=\"_blank\"] which is built from various sources during xref:cdi-reference.adoc#bean_discovery[bean discovery].  However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.  Moreover, extensions can also register xref:synthetic_beans[synthetic components].  This is an important aspect to realize when integrating CDI components in Quarkus."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:50
msgid "This way, extensions can turn classes, that would be otherwise ignored, into beans and vice versa.  For example, a class that declares a `@Scheduled` method is always registered as a bean even if it is not annotated with a bean defining annotation and would be normally ignored."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cdi-integration.adoc:54
#, no-wrap
msgid "Use Case - My Class Is Not Recognized as a Bean"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:60
msgid "An `UnsatisfiedResolutionException` indicates a problem during xref:cdi.adoc#typesafe_resolution[typesafe resolution].  Sometimes an injection point cannot be satisfied even if there is a class on the classpath that appears to be eligible for injection.  There are several reasons why a class is not recognized and also several ways to fix it.  In the first step we should identify the _reason_."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cdi-integration.adoc:62
#, no-wrap
msgid "_Reason 1_: Class Is Not discovered"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:67
msgid "Quarkus has a xref:cdi-reference.adoc#bean_discovery[simplified discovery].  It might happen that the class is not part of the application index.  For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:71
msgid "_Solution_: Use the `AdditionalBeanBuildItem`.  This build item can be used to specify one or more additional classes to be analyzed during the discovery.  Additional bean classes are transparently added to the application index processed by the container."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:73
msgid "It is not possible to conditionally enable/disable additional beans via the `@IfBuildProfile`, `@UnlessBuildProfile`, `@IfBuildProperty` and `@UnlessBuildProperty` annotations as described in xref:cdi-reference.adoc#enable_build_profile[Enabling Beans for Quarkus Build Profile] and xref:cdi-reference.adoc#enable_build_properties[Enabling Beans for Quarkus Build Properties]. Extensions should inspect the configuration or the current profile and only produce an `AdditionalBeanBuildItem` if really needed."
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/cdi-integration.adoc:74
#, no-wrap
msgid "`AdditionalBeanBuildItem` Example"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-integration.adoc:81
#, no-wrap
msgid ""
"@BuildStep\n"
"AdditionalBeanBuildItem additionalBeans() {\n"
"     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:83
msgid "`AdditionalBeanBuildItem.Builder` can be used for more complex use cases."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:88
msgid "Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.  If the container considers them xref:cdi-reference.adoc#remove_unused_beans[unused], they are just ignored.  However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.  See also xref:cdi-reference.adoc#remove_unused_beans[Removing Unused Beans] and xref:unremovable_builditem[_Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed] for more details."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:91
msgid "It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.  The default scope is only used if there is no scope declared on the bean class."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:93
#: upstream/_versions/main/guides/cdi-integration.adoc:135
msgid "If no default scope is specified the `@Dependent` pseudo-scope is used."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cdi-integration.adoc:94
#, no-wrap
msgid "_Reason 2_: Class Is Discovered but Has No Bean Defining Annotation"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:99
msgid "In Quarkus, the application is represented by a single bean archive with the https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].  Therefore, bean classes that don't have a https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.  Bean defining annotations are declared on the class-level and include scopes, stereotypes and `@Interceptor`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:101
msgid "_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions."
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/cdi-integration.adoc:102
#, no-wrap
msgid "`AutoAddScopeBuildItem` Example"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-integration.adoc:111
#, no-wrap
msgid ""
"@BuildStep\n"
"AutoAddScopeBuildItem autoAddScope() {\n"
"   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n"
"      .defaultScope(BuiltinScope.SINGLETON) <2>\n"
"      .build();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:113
msgid "Find all classes annotated with `@Scheduled`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:114
msgid "Add `@Singleton` as default scope. Classes already annotated with a scope are skipped automatically."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:116
msgid "_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`."
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/cdi-integration.adoc:117
#, no-wrap
msgid "`BeanDefiningAnnotationBuildItem` Example"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-integration.adoc:124
#, no-wrap
msgid ""
"@BuildStep\n"
"BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n"
"   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:126
msgid "Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:130
msgid "Bean classes added via `BeanDefiningAnnotationBuildItem` are _not removable_ by default, i.e. the resulting beans must not be removed even if they are considered unused.  However, you can change the default behavior.  See also xref:cdi-reference.adoc#remove_unused_beans[Removing Unused Beans] and xref:unremovable_builditem[_Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed] for more details."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:133
msgid "It is also possible to specify the default scope.  The default scope is only used if there is no scope declared on the bean class."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cdi-integration.adoc:137
#, no-wrap
msgid "_Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:144
msgid "The container attempts to xref:cdi-reference.adoc#remove_unused_beans[remove all unused beans] during the build by default.  This optimization allows for _framework-level dead code elimination_.  In few special cases, it's not possible to correctly identify an unused bean.  In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.  Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`."
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/cdi-integration.adoc:145
#, no-wrap
msgid "`UnremovableBeanBuildItem` Example"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-integration.adoc:152
#, no-wrap
msgid ""
"@BuildStep\n"
"UnremovableBeanBuildItem unremovableBeans() {\n"
"   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:154
msgid "Make all classes annotated with `@Startup` unremovable."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cdi-integration.adoc:155
#, no-wrap
msgid "Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:159
msgid "It is likely that the annotation class is not part of the application index.  For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:161
msgid "_Solution_: Use the `AdditionalBeanBuildItem` as described in xref:additional_bean_build_item[_Reason 1_: Class Is Not discovered]."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cdi-integration.adoc:163
#, no-wrap
msgid "Use Case - I Need To Transform Annotation Metadata"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:168
msgid "In some cases, it's useful to be able to modify the annotation metadata.  Quarkus provides a powerful alternative to https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#process_annotated_type[`jakarta.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"] and https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#bce_enhancement[`jakarta.enterprise.inject.build.compatible.spi.Enhancement`, window=\"_blank\"].  With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:170
msgid "Keep in mind that annotation transformers must be produced _before_ the bean discovery starts."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:173
msgid "For example, you might want to add an interceptor binding to a specific bean class.  You can use a convenient builder-like API to create a transformer instance:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:175
msgid "Builder Example"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-integration.adoc:183
#, no-wrap
msgid ""
"@BuildStep\n"
"AnnotationsTransformerBuildItem transform() {\n"
"   return new AnnotationsTransformerBuildItem(AnnotationsTransformer.appliedToClass() <1>\n"
"        .whenClass(c -> c.name().toString().equals(\"org.acme.Bar\")) <2>\n"
"        .thenTransform(t -> t.add(MyInterceptorBinding.class))); <3>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:185
#: upstream/_versions/main/guides/cdi-integration.adoc:210
msgid "The transformer is only applied to classes."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:186
msgid "Only apply the transformation if the class name equals to `org.acme.Bar`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:187
msgid "Add the `@MyInterceptorBinding` annotation."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:189
msgid "The example above can be rewritten with an anonymous class:"
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/cdi-integration.adoc:190
#, no-wrap
msgid "`AnnotationsTransformerBuildItem` Example"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-integration.adoc:196
#, no-wrap
msgid ""
"@BuildStep\n"
"AnnotationsTransformerBuildItem transform() {\n"
"   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-integration.adoc:200
#, no-wrap
msgid ""
"      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n"
"         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n"
"      }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-integration.adoc:208
#, no-wrap
msgid ""
"      public void transform(TransformationContext context) {\n"
"         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n"
"            context.transform().add(MyInterceptorBinding.class).done(); <2>\n"
"         }\n"
"      }\n"
"    });\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:211
msgid "If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:213
msgid "Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`."
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/cdi-integration.adoc:214
#, no-wrap
msgid "`TransformedAnnotationsBuildItem` Example"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-integration.adoc:224
#, no-wrap
msgid ""
"@BuildStep\n"
"void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n"
"   ClassInfo myClazz = ...;\n"
"   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n"
"     myBuildItem.produce(new MyBuildItem());\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:226
msgid "`TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:228
msgid "There are other build items specialized in transformation: xref:additional_interceptor_bindings[Use Case - Additional Interceptor Bindings] and xref:injection_point_transformation[Use Case - Injection Point Transformation]."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cdi-integration.adoc:229
#, no-wrap
msgid "How to Enable Trace Logging for Annotation Transformers"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:232
msgid "You can set the `TRACE` level for the category `io.quarkus.arc.processor` and try to analyze the log output afterwards."
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/cdi-integration.adoc:233
#, no-wrap
msgid "`application.properties` Example"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-integration.adoc:238
#, no-wrap
msgid ""
"quarkus.log.category.\"io.quarkus.arc.processor\".min-level=TRACE <1>\n"
"quarkus.log.category.\"io.quarkus.arc.processor\".level=TRACE\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:240
msgid "You also need to adjust the minimum log level for the relevant category."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cdi-integration.adoc:242
#, no-wrap
msgid "Use Case - Inspect Beans, Observers and Injection Points"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cdi-integration.adoc:244
#, no-wrap
msgid "_Solution 1_: `BeanDiscoveryFinishedBuildItem`"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:248
msgid "Consumers of `BeanDiscoveryFinishedBuildItem` can easily inspect all class-based beans, observers and injection points registered in the application.  However, synthetic beans and observers are _not included_ because this build item is produced _before_ the synthetic components are registered."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:250
msgid "Additionally, the bean resolver returned from `BeanDiscoveryFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out whether there is a bean that would satisfy certain combination of required type and qualifiers."
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/cdi-integration.adoc:251
#, no-wrap
msgid "`BeanDiscoveryFinishedBuildItem` Example"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-integration.adoc:259
#, no-wrap
msgid ""
"@BuildStep\n"
"void doSomethingWithNamedBeans(BeanDiscoveryFinishedBuildItem beanDiscovery, BuildProducer<NamedBeansBuildItem> namedBeans) {\n"
"   List<BeanInfo> namedBeans = beanDiscovery.beanStream().withName().collect(toList())); <1>\n"
"   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:261
msgid "The resulting list will not contain `@Named` synthetic beans."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cdi-integration.adoc:262
#, no-wrap
msgid "_Solution 2_: `SynthesisFinishedBuildItem`"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:265
msgid "Consumers of `SynthesisFinishedBuildItem` can easily inspect all beans, observers and injection points registered in the application. Synthetic beans and observers are included because this build item is produced _after_ the synthetic components are registered."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:267
msgid "Additionally, the bean resolver returned from `SynthesisFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out whether there is a bean that would satisfy certain combination of required type and qualifiers."
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/cdi-integration.adoc:268
#, no-wrap
msgid "`SynthesisFinishedBuildItem` Example"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-integration.adoc:276
#, no-wrap
msgid ""
"@BuildStep\n"
"void doSomethingWithNamedBeans(SynthesisFinishedBuildItem synthesisFinished, BuildProducer<NamedBeansBuildItem> namedBeans) {\n"
"   List<BeanInfo> namedBeans = synthesisFinished.beanStream().withName().collect(toList())); <1>\n"
"   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:278
msgid "The resulting list will contain `@Named` synthetic beans."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cdi-integration.adoc:280
#, no-wrap
msgid "Use Case - The Need for Synthetic Beans"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:286
msgid "Sometimes it is practical to be able to register a _synthetic bean_.  Bean attributes of a synthetic bean are not derived from a Java class, method or field.  Instead, all the attributes are defined by an extension.  In regular CDI, this could be achieved using the https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=\"_blank\"] and https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#bce_synthesis[`SyntheticComponents.addBean()`] methods."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:288
msgid "_Solution_: If you need to register a synthetic bean then use the `SyntheticBeanBuildItem`."
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/cdi-integration.adoc:289
#, no-wrap
msgid "`SyntheticBeanBuildItem` Example 1"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-integration.adoc:299
#, no-wrap
msgid ""
"@BuildStep\n"
"SyntheticBeanBuildItem syntheticBean() {\n"
"   return SyntheticBeanBuildItem.configure(String.class)\n"
"             .qualifiers(AnnotationInstance.builder(MyQualifier.class).build())\n"
"             .creator(mc -> mc.returnValue(mc.load(\"foo\"))) <1>\n"
"             .done();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:301
msgid "Generate the bytecode of the `jakarta.enterprise.context.spi.Contextual#create(CreationalContext<T>)` implementation."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:305
msgid "The output of a bean configurator is recorded as bytecode.  Therefore, there are some limitations in how a synthetic bean instance is created at runtime.  You can:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:307
msgid "Generate the bytecode of the `Contextual#create(CreationalContext<T>)` method directly via `ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:308
msgid "Pass a subclass of `io.quarkus.arc.BeanCreator` via `ExtendedBeanConfigurator#creator(Class<? extends BeanCreator<U>>)`, and possibly specify some build-time parameters via `ExtendedBeanConfigurator#param()` and synthetic injection points via `ExtendedBeanConfigurator#addInjectionPoint()`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:309
msgid "Produce the runtime instance through a proxy returned from a xref:writing-extensions.adoc#bytecode-recording[`@Recorder` method] and set it via `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)`, `ExtendedBeanConfigurator#runtimeProxy(Object)`, `ExtendedBeanConfigurator#supplier(Supplier<?>)` or `ExtendedBeanConfigurator#createWith(Function<SyntheticCreationalContext<?>, <?>)`."
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/cdi-integration.adoc:310
#, no-wrap
msgid "`SyntheticBeanBuildItem` Example 2"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-integration.adoc:320
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(STATIC_INIT) <1>\n"
"SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n"
"   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n"
"                .runtimeValue(recorder.createFoo()) <2>\n"
"                .done();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:322
msgid "By default, a synthetic bean is initialized during `STATIC_INIT`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:323
msgid "The bean instance is supplied by a value returned from a recorder method."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:326
msgid "It is possible to mark a synthetic bean to be initialized during `RUNTIME_INIT`.  See the xref:writing-extensions.adoc#bootstrap-three-phases[Three Phases of Bootstrap and Quarkus Philosophy] for more information about the difference between `STATIC_INIT` and `RUNTIME_INIT`."
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/cdi-integration.adoc:327
#, no-wrap
msgid "`RUNTIME_INIT` `SyntheticBeanBuildItem` Example"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-integration.adoc:338
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(RUNTIME_INIT) <1>\n"
"SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n"
"   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n"
"                .setRuntimeInit() <2>\n"
"                .runtimeValue(recorder.createFoo())\n"
"                .done();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:340
msgid "The recorder must be executed in the `ExecutionTime.RUNTIME_INIT` phase."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:341
#: upstream/_versions/main/guides/cdi-integration.adoc:384
msgid "The bean instance is initialized during `RUNTIME_INIT`."
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/cdi-integration.adoc:345
msgid "Synthetic beans initialized during `RUNTIME_INIT` must not be accessed during `STATIC_INIT`. `RUNTIME_INIT` build steps that access a runtime-init synthetic bean should consume the `SyntheticBeansRuntimeInitBuildItem`:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-integration.adoc:354
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(RUNTIME_INIT)\n"
"@Consume(SyntheticBeansRuntimeInitBuildItem.class) <1>\n"
"void accessFoo(TestRecorder recorder) {\n"
"   recorder.foo(); <2>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:356
msgid "This build step must be executed after `syntheticBean()` completes."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:357
msgid "This recorder method results in an invocation upon the `Foo` bean instance and thus we need to make sure that the build step is executed after all synthetic beans are initialized."
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/cdi-integration.adoc:360
msgid "It is also possible to use the `BeanRegistrationPhaseBuildItem` to register a synthetic bean. However, we recommend extension authors to stick with `SyntheticBeanBuildItem` which is more idiomatic for Quarkus."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cdi-integration.adoc:361
#, no-wrap
msgid "Synthetic Injection Points"
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/cdi-integration.adoc:366
msgid "A synthetic bean may register a synthetic injection point via the `ExtendedBeanConfigurator#addInjectionPoint()` method.  This injection point is validated at build time and considered when xref:cdi-reference.adoc#remove_unused_beans[detecting unused beans].  The injected reference is accessible through the `SyntheticCreationalContext#getInjectedReference()` methods at runtime."
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/cdi-integration.adoc:367
#, no-wrap
msgid "Synthetic Injection Point - Build Step Example"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-integration.adoc:372
#, no-wrap
msgid ""
"import org.jboss.jandex.ClassType;\n"
"import org.jboss.jandex.DotName;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-integration.adoc:382
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(RUNTIME_INIT) <1>\n"
"SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n"
"   return SyntheticBeanBuildItem.configure(Foo.class)\n"
"                .scope(Singleton.class)\n"
"                .addInjectionPoint(ClassType.create(DotName.createSimple(Bar.class))) <2>\n"
"                .createWith(recorder.createFoo()) <3>\n"
"                .done();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:385
msgid "A synthetic injection point with required type `Bar` was added; this is an equivalent of `@Inject Bar`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:386
msgid "The bean instance is created with a function returned from a recorder method."
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/cdi-integration.adoc:387
#, no-wrap
msgid "Synthetic Injection Point - Recorder Example"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-integration.adoc:392
#, no-wrap
msgid ""
"@Recorder\n"
"public class TestRecorder {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-integration.adoc:399
#, no-wrap
msgid ""
"   public Function<SyntheticCreationalContext<Foo>, Foo> createFoo() {\n"
"     return (context) -> {\n"
"        return new Foo(context.getInjectedReference(Bar.class)); <1>\n"
"     };\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:401
msgid "Pass a contextual reference of `Bar` to the constructor of `Foo`."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cdi-integration.adoc:403
#, no-wrap
msgid "Use Case - Synthetic Observers"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:406
msgid "Similar to xref:synthetic_beans[synthetic beans], the attributes of a synthetic observer method are not derived from a Java method. Instead, all the attributes are defined by an extension."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:408
msgid "_Solution_: If you need to register a synthetic observer, use the `ObserverRegistrationPhaseBuildItem`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:410
msgid "A build step that consumes the `ObserverRegistrationPhaseBuildItem` should always produce an `ObserverConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase)."
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/cdi-integration.adoc:411
#, no-wrap
msgid "`ObserverRegistrationPhaseBuildItem` Example"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-integration.adoc:427
#, no-wrap
msgid ""
"@BuildStep\n"
"void syntheticObserver(ObserverRegistrationPhaseBuildItem observerRegistrationPhase,\n"
"            BuildProducer<MyBuildItem> myBuildItem,\n"
"            BuildProducer<ObserverConfiguratorBuildItem> observerConfigurationRegistry) {\n"
"   observerConfigurationRegistry.produce(new ObserverConfiguratorBuildItem(observerRegistrationPhase.getContext()\n"
"       .configure()\n"
"       .beanClass(DotName.createSimple(MyBuildStep.class.getName()))\n"
"       .observedType(String.class)\n"
"       .notify(mc -> {\n"
"           // do some gizmo bytecode generation...\n"
"       })));\n"
"   myBuildItem.produce(new MyBuildItem());\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:432
msgid "The output of a `ObserverConfigurator` is recorded as bytecode.  Therefore, there are some limitations in how a synthetic observer is invoked at runtime.  Currently, you must generate the bytecode of the method body directly."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cdi-integration.adoc:434
#, no-wrap
msgid "Use Case - I Have a Generated Bean Class"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:438
msgid "No problem.  You can generate the bytecode of a bean class manually and then all you need to do is to produce a `GeneratedBeanBuildItem` instead of `GeneratedClassBuildItem`."
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/cdi-integration.adoc:439
#, no-wrap
msgid "`GeneratedBeanBuildItem` Example"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-integration.adoc:451
#, no-wrap
msgid ""
"@BuildStep\n"
"void generatedBean(BuildProducer<GeneratedBeanBuildItem> generatedBeans) {\n"
"    ClassOutput beansClassOutput = new GeneratedBeanGizmoAdaptor(generatedBeans); <1>\n"
"    ClassCreator beanClassCreator = ClassCreator.builder().classOutput(beansClassOutput)\n"
"                .className(\"org.acme.MyBean\")\n"
"                .build();\n"
"    beanClassCreator.addAnnotation(Singleton.class);\n"
"    beanClassCreator.close(); <2>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:453
msgid "`io.quarkus.arc.deployment.GeneratedBeanGizmoAdaptor` makes it easy to produce ``GeneratedBeanBuildItem``s from Gizmo constructs."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:454
msgid "The resulting bean class is something like `public class @Singleton MyBean { }`."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cdi-integration.adoc:455
#, no-wrap
msgid "Use Case - I Need to Validate the Deployment"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:458
msgid "Sometimes extensions need to inspect the beans, observers and injection points, then perform additional validations and fail the build if something is wrong."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:460
msgid "_Solution_: If an extension needs to validate the deployment it should use the `ValidationPhaseBuildItem`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:462
msgid "A build step that consumes the `ValidationPhaseBuildItem` should always produce a `ValidationErrorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase)."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-integration.adoc:474
#, no-wrap
msgid ""
"@BuildStep\n"
"void validate(ValidationPhaseBuildItem validationPhase,\n"
"            BuildProducer<MyBuildItem> myBuildItem,\n"
"            BuildProducer<ValidationErrorBuildItem> errors) {\n"
"   if (someCondition) {\n"
"     errors.produce(new ValidationErrorBuildItem(new IllegalStateException()));\n"
"     myBuildItem.produce(new MyBuildItem());\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:477
msgid "You can easily filter all registered beans via the convenient `BeanStream` returned from the `ValidationPhaseBuildItem.getContext().beans()` method."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cdi-integration.adoc:479
#, no-wrap
msgid "Use Case - Register a Custom CDI Context"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:482
msgid "Sometimes extensions need to extend the set of built-in CDI contexts."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:484
msgid "_Solution_: If you need to register a custom context, use the `ContextRegistrationPhaseBuildItem`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:486
msgid "A build step that consumes the `ContextRegistrationPhaseBuildItem` should always produce a `ContextConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase)."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:488
msgid "`ContextRegistrationPhaseBuildItem` Example"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-integration.adoc:494
#, no-wrap
msgid ""
"@BuildStep\n"
"ContextConfiguratorBuildItem registerContext(ContextRegistrationPhaseBuildItem phase) {\n"
"      return new ContextConfiguratorBuildItem(phase.getContext().configure(TransactionScoped.class).normal().contextClass(TransactionContext.class));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:497
msgid "Additionally, each extension that registers a custom CDI context via `ContextRegistrationPhaseBuildItem` should also produce the `CustomScopeBuildItem` in order to contribute the custom scope annotation name to the set of bean defining annotations."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:499
msgid "`CustomScopeBuildItem` Example"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-integration.adoc:505
#, no-wrap
msgid ""
"@BuildStep\n"
"CustomScopeBuildItem customScope() {\n"
"   return new CustomScopeBuildItem(DotName.createSimple(TransactionScoped.class.getName()));\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cdi-integration.adoc:507
#, no-wrap
msgid "What if I Need to Know All the Scopes Used in the Application?"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:510
msgid "_Solution_: You can inject the `CustomScopeAnnotationsBuildItem` in a build step and use the convenient methods such as `CustomScopeAnnotationsBuildItem.isScopeDeclaredOn()`."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cdi-integration.adoc:512
#, no-wrap
msgid "Use Case - Additional Interceptor Bindings"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:517
msgid "In rare cases it might be handy to programmatically register an existing annotation that is not annotated with `@jakarta.interceptor.InterceptorBinding` as an interceptor binding.  This is similar to what CDI achieves through `BeforeBeanDiscovery#addInterceptorBinding()`.  We are going to use `InterceptorBindingRegistrarBuildItem` to get it done."
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/cdi-integration.adoc:518
#, no-wrap
msgid "`InterceptorBindingRegistrarBuildItem` Example"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-integration.adoc:530
#, no-wrap
msgid ""
"@BuildStep\n"
"InterceptorBindingRegistrarBuildItem addInterceptorBindings() {\n"
"    return new InterceptorBindingRegistrarBuildItem(new InterceptorBindingRegistrar() {\n"
"        @Override\n"
"        public List<InterceptorBinding> getAdditionalBindings() {\n"
"            return List.of(InterceptorBinding.of(NotAnInterceptorBinding.class));\n"
"        }\n"
"    });\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cdi-integration.adoc:532
#, no-wrap
msgid "Use Case - Additional Qualifiers"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:537
msgid "Sometimes it might be useful to register an existing annotation that is not annotated with `@jakarta.inject.Qualifier` as a CDI qualifier.  This is similar to what CDI achieves through `BeforeBeanDiscovery#addQualifier()`.  We are going to use `QualifierRegistrarBuildItem` to get it done."
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/cdi-integration.adoc:538
#, no-wrap
msgid "`QualifierRegistrarBuildItem` Example"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-integration.adoc:551
#, no-wrap
msgid ""
"@BuildStep\n"
"QualifierRegistrarBuildItem addQualifiers() {\n"
"    return new QualifierRegistrarBuildItem(new QualifierRegistrar() {\n"
"        @Override\n"
"        public Map<DotName, Set<String>> getAdditionalQualifiers() {\n"
"            return Collections.singletonMap(DotName.createSimple(NotAQualifier.class.getName()),\n"
"                                        Collections.emptySet());\n"
"        }\n"
"    });\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cdi-integration.adoc:553
#, no-wrap
msgid "Use Case - Additional Stereotypes"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:558
msgid "It is sometimes useful to register an existing annotation that is not annotated with `@jakarta.enterprise.inject.Stereotype` as a CDI stereotype.  This is similar to what CDI achieves through `BeforeBeanDiscovery#addStereotype()`.  We are going to use `StereotypeRegistrarBuildItem` to get it done."
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/cdi-integration.adoc:559
#, no-wrap
msgid "`StereotypeRegistrarBuildItem` Example"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-integration.adoc:571
#, no-wrap
msgid ""
"@BuildStep\n"
"StereotypeRegistrarBuildItem addStereotypes() {\n"
"    return new StereotypeRegistrarBuildItem(new StereotypeRegistrar() {\n"
"        @Override\n"
"        public Set<DotName> getAdditionalStereotypes() {\n"
"            return Collections.singleton(DotName.createSimple(NotAStereotype.class.getName()));\n"
"        }\n"
"    });\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:574
msgid "If the newly registered stereotype annotation doesn't have the appropriate meta-annotations, such as scope or interceptor bindings, use an xref:annotations_transformer_build_item[annotation transformation] to add them."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cdi-integration.adoc:576
#, no-wrap
msgid "Use Case - Injection Point Transformation"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:581
msgid "Every now and then it is handy to be able to change the qualifiers of an injection point programmatically.  You can do just that with `InjectionPointTransformerBuildItem`.  The following sample shows how to apply transformation to injection points with type `Foo` that contain qualifier `MyQualifier`:"
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/cdi-integration.adoc:582
#, no-wrap
msgid "`InjectionPointTransformerBuildItem` Example"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-integration.adoc:588
#, no-wrap
msgid ""
"@BuildStep\n"
"InjectionPointTransformerBuildItem transformer() {\n"
"    return new InjectionPointTransformerBuildItem(new InjectionPointsTransformer() {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-integration.adoc:592
#, no-wrap
msgid ""
"        public boolean appliesTo(Type requiredType) {\n"
"            return requiredType.name().equals(DotName.createSimple(Foo.class.getName()));\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-integration.adoc:604
#, no-wrap
msgid ""
"        public void transform(TransformationContext context) {\n"
"            if (context.getQualifiers().stream()\n"
"                    .anyMatch(a -> a.name().equals(DotName.createSimple(MyQualifier.class.getName())))) {\n"
"                context.transform()\n"
"                        .removeAll()\n"
"                        .add(DotName.createSimple(MyOtherQualifier.class.getName()))\n"
"                        .done();\n"
"            }\n"
"        }\n"
"    });\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:607
msgid "In theory, you can use xref:annotations_transformer_build_item[an `AnnotationsTransformer`] to achieve the same goal. However, there are few differences that make `InjectionPointsTransformer` more suitable for this particular task: (1) annotation transformers are applied to all classes during bean discovery, whereas `InjectionPointsTransformer` is only applied to discovered injection points after bean discovery; (2) with `InjectionPointsTransformer` you don't need to handle various types of injection points (field, parameters of initializer methods, etc.)."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cdi-integration.adoc:608
#, no-wrap
msgid "Use Case - Resource Annotations and Injection"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:612
msgid "The `ResourceAnnotationBuildItem` can be used to specify resource annotations that make it possible to resolve non-CDI injection points, such as Jakarta EE resources.  An integrator must also provide a corresponding `io.quarkus.arc.ResourceReferenceProvider` service provider implementation."
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/cdi-integration.adoc:613
#, no-wrap
msgid "`ResourceAnnotationBuildItem` Example"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-integration.adoc:622
#, no-wrap
msgid ""
"@BuildStep\n"
"void setupResourceInjection(BuildProducer<ResourceAnnotationBuildItem> resourceAnnotations, BuildProducer<GeneratedResourceBuildItem> resources) {\n"
"    resources.produce(new GeneratedResourceBuildItem(\"META-INF/services/io.quarkus.arc.ResourceReferenceProvider\",\n"
"        MyResourceReferenceProvider.class.getName().getBytes()));\n"
"    resourceAnnotations.produce(new ResourceAnnotationBuildItem(DotName.createSimple(MyAnnotation.class.getName())));\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cdi-integration.adoc:625
#, no-wrap
msgid "Available Build Time Metadata"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:629
msgid "Any of the above extensions that operates with `BuildExtension.BuildContext` can leverage certain build time metadata that are generated during build.  The built-in keys located in `io.quarkus.arc.processor.BuildExtension.Key` are:"
msgstr ""

#. type: Labeled list
#: upstream/_versions/main/guides/cdi-integration.adoc:630
#, no-wrap
msgid "ANNOTATION_STORE"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:631
msgid "Contains an `AnnotationStore` that keeps information about all `AnnotationTarget` annotations after application of annotation transformers"
msgstr ""

#. type: Labeled list
#: upstream/_versions/main/guides/cdi-integration.adoc:631
#, no-wrap
msgid "INJECTION_POINTS"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:632
msgid "`Collection<InjectionPointInfo>` containing all injection points"
msgstr ""

#. type: Labeled list
#: upstream/_versions/main/guides/cdi-integration.adoc:632
#, no-wrap
msgid "BEANS"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:633
msgid "`Collection<BeanInfo>` containing all beans"
msgstr ""

#. type: Labeled list
#: upstream/_versions/main/guides/cdi-integration.adoc:633
#, no-wrap
msgid "REMOVED_BEANS"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:634
msgid "`Collection<BeanInfo>` containing all the removed beans; see xref:cdi-reference.adoc#remove_unused_beans[Removing unused beans] for more information"
msgstr ""

#. type: Labeled list
#: upstream/_versions/main/guides/cdi-integration.adoc:634
#, no-wrap
msgid "OBSERVERS"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:635
msgid "`Collection<ObserverInfo>` containing all observers"
msgstr ""

#. type: Labeled list
#: upstream/_versions/main/guides/cdi-integration.adoc:635
#, no-wrap
msgid "SCOPES"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:636
msgid "`Collection<ScopeInfo>` containing all scopes, including custom ones"
msgstr ""

#. type: Labeled list
#: upstream/_versions/main/guides/cdi-integration.adoc:636
#, no-wrap
msgid "QUALIFIERS"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:637
msgid "`Map<DotName, ClassInfo>` containing all qualifiers"
msgstr ""

#. type: Labeled list
#: upstream/_versions/main/guides/cdi-integration.adoc:637
#, no-wrap
msgid "INTERCEPTOR_BINDINGS"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:638
msgid "`Map<DotName, ClassInfo>` containing all interceptor bindings"
msgstr ""

#. type: Labeled list
#: upstream/_versions/main/guides/cdi-integration.adoc:638
#, no-wrap
msgid "STEREOTYPES"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:639
msgid "`Map<DotName, StereotypeInfo>` containing all stereotypes"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:644
msgid "To get hold of these, simply query the extension context object for given key.  Note that these metadata are made available as build proceeds which means that extensions can only leverage metadata that were built before the extensions are invoked.  If your extension attempts to retrieve metadata that wasn't yet produced, `null` will be returned.  Here is a summary of which extensions can access which metadata:"
msgstr ""

#. type: Labeled list
#: upstream/_versions/main/guides/cdi-integration.adoc:645
#, no-wrap
msgid "AnnotationsTransformer"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:646
msgid "Shouldn't rely on any metadata as it could be used at any time in any phase of the bootstrap"
msgstr ""

#. type: Labeled list
#: upstream/_versions/main/guides/cdi-integration.adoc:646
#, no-wrap
msgid "ContextRegistrar"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:647
#: upstream/_versions/main/guides/cdi-integration.adoc:648
#: upstream/_versions/main/guides/cdi-integration.adoc:649
msgid "Has access to `ANNOTATION_STORE`, `QUALIFIERS`, `INTERCEPTOR_BINDINGS`, `STEREOTYPES`"
msgstr ""

#. type: Labeled list
#: upstream/_versions/main/guides/cdi-integration.adoc:647
#, no-wrap
msgid "InjectionPointsTransformer"
msgstr ""

#. type: Labeled list
#: upstream/_versions/main/guides/cdi-integration.adoc:648
#, no-wrap
msgid "ObserverTransformer"
msgstr ""

#. type: Labeled list
#: upstream/_versions/main/guides/cdi-integration.adoc:649
#, no-wrap
msgid "BeanRegistrar"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:650
msgid "Has access to `ANNOTATION_STORE`, `QUALIFIERS`, `INTERCEPTOR_BINDINGS`, `STEREOTYPES`, `BEANS` (class-based beans only), `OBSERVERS` (class-based observers only), `INJECTION_POINTS`"
msgstr ""

#. type: Labeled list
#: upstream/_versions/main/guides/cdi-integration.adoc:650
#, no-wrap
msgid "ObserverRegistrar"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:651
msgid "Has access to `ANNOTATION_STORE`, `QUALIFIERS`, `INTERCEPTOR_BINDINGS`, `STEREOTYPES`, `BEANS`, `OBSERVERS` (class-based observers only), `INJECTION_POINTS`"
msgstr ""

#. type: Labeled list
#: upstream/_versions/main/guides/cdi-integration.adoc:651
#, no-wrap
msgid "BeanDeploymentValidator"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-integration.adoc:651
msgid "Has access to all build metadata"
msgstr ""

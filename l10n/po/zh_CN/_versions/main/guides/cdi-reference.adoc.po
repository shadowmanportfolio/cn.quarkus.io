# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-11-29 01:59+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_versions/main/guides/cdi-reference.adoc:6
#, no-wrap
msgid "Contexts and Dependency Injection"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:21
msgid "Quarkus DI solution (also called ArC) is based on the https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html[Jakarta Contexts and Dependency Injection 4.0, window=\"_blank\"] specification.  It implements the CDI Lite specification, with selected improvements on top, and passes the CDI Lite TCK.  It does not implement CDI Full.  See also xref:supported_features_and_limitations[the list of supported features and limitations]."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:23
msgid "If you're new to CDI then we recommend you to read the xref:cdi.adoc[Introduction to CDI] first."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:25
msgid "Most of the existing CDI code should work just fine but there are some small differences which follow from the Quarkus architecture and goals."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cdi-reference.adoc:27
#, no-wrap
msgid "Bean Discovery"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:32
msgid "Bean discovery in CDI is a complex process which involves legacy deployment structures and accessibility requirements of the underlying module architecture.  However, Quarkus is using a *simplified bean discovery*.  There is only single bean archive with the https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"] and no visibility boundaries."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:34
msgid "The bean archive is synthesized from:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:36
msgid "the application classes,"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:37
msgid "dependencies that contain a `beans.xml` descriptor (content is ignored),"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:38
msgid "dependencies that contain a Jandex index - `META-INF/jandex.idx`,"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:39
msgid "dependencies referenced by `quarkus.index-dependency` in `application.properties`,"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:40
msgid "and Quarkus integration code."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:45
msgid "Bean classes that don't have a https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are not discovered.  This behavior is defined by CDI.  But producer methods and fields and observer methods are discovered even if the declaring class is not annotated with a bean defining annotation (this behavior is different to what is defined in CDI).  In fact, the declaring bean classes are considered annotated with `@Dependent`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:47
msgid "Quarkus extensions may declare additional discovery rules. For example, `@Scheduled` business methods are registered even if the declaring class is not annotated with a bean defining annotation."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cdi-reference.adoc:48
#, no-wrap
msgid "How to Generate a Jandex Index"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:52
msgid "A dependency with a Jandex index is automatically scanned for beans.  To generate the index just add the following plugin to your build file:"
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/cdi-reference.adoc:54
#, no-wrap
msgid "Maven"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:75
#, no-wrap
msgid ""
"<build>\n"
"  <plugins>\n"
"    <plugin>\n"
"      <groupId>io.smallrye</groupId>\n"
"      <artifactId>jandex-maven-plugin</artifactId>\n"
"      <version>{jandex-version}</version>\n"
"      <executions>\n"
"        <execution>\n"
"          <id>make-index</id>\n"
"          <goals>\n"
"            <goal>jandex</goal>\n"
"          </goals>\n"
"        </execution>\n"
"      </executions>\n"
"    </plugin>\n"
"  </plugins>\n"
"</build>\n"
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/cdi-reference.adoc:79
#, no-wrap
msgid "Gradle (Groovy DSL)"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:87
#, no-wrap
msgid ""
"plugins {\n"
"    id 'org.kordamp.gradle.jandex' version '{jandex-gradle-plugin-version}'\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:89
#: upstream/_versions/main/guides/cdi-reference.adoc:102
msgid "You can find the latest plugin version in the https://plugins.gradle.org/plugin/org.kordamp.gradle.jandex[Gradle Plugin Portal]"
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/cdi-reference.adoc:92
#, no-wrap
msgid "Gradle (Kotlin DSL)"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:100
#, no-wrap
msgid ""
"plugins {\n"
"    id(\"org.kordamp.gradle.jandex\") version \"{jandex-gradle-plugin-version}\"\n"
"}\n"
msgstr ""

#. type: delimited block *
#: upstream/_versions/main/guides/cdi-reference.adoc:107
msgid "If you can't modify the dependency, you can still index it by adding `quarkus.index-dependency` entries to your `application.properties`:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:113
#, no-wrap
msgid ""
"quarkus.index-dependency.<name>.group-id=\n"
"quarkus.index-dependency.<name>.artifact-id=\n"
"quarkus.index-dependency.<name>.classifier=(this one is optional)\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:116
msgid "For example, the following entries ensure that the `org.acme:acme-api` dependency is indexed:"
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/cdi-reference.adoc:117
#: upstream/_versions/main/guides/cdi-reference.adoc:142
#: upstream/_versions/main/guides/cdi-reference.adoc:154
#: upstream/_versions/main/guides/cdi-reference.adoc:473
#: upstream/_versions/main/guides/cdi-reference.adoc:680
#, no-wrap
msgid "Example application.properties"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:122
#, no-wrap
msgid ""
"quarkus.index-dependency.acme.group-id=org.acme <1>\n"
"quarkus.index-dependency.acme.artifact-id=acme-api <2>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:124
#: upstream/_versions/main/guides/cdi-reference.adoc:161
msgid "Value is a group id for a dependency identified by name `acme`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:125
#: upstream/_versions/main/guides/cdi-reference.adoc:162
msgid "Value is an artifact id for a dependency identified by name `acme`."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cdi-reference.adoc:126
#, no-wrap
msgid "How To Exclude Types and Dependencies from Discovery"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:132
msgid "It may happen that some beans from third-party libraries do not work correctly in Quarkus.  A typical example is a bean injecting a portable extension.  In such case, it's possible to exclude types and dependencies from the bean discovery.  The `quarkus.arc.exclude-types` property accepts a list of string values that are used to match classes that should be excluded."
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/cdi-reference.adoc:133
#: upstream/_versions/main/guides/cdi-reference.adoc:464
#: upstream/_versions/main/guides/cdi-reference.adoc:671
#, no-wrap
msgid "Value Examples"
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/cdi-reference.adoc:135
#: upstream/_versions/main/guides/cdi-reference.adoc:466
#: upstream/_versions/main/guides/cdi-reference.adoc:673
#, no-wrap
msgid "Valu"
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/cdi-reference.adoc:136
#: upstream/_versions/main/guides/cdi-reference.adoc:467
#: upstream/_versions/main/guides/cdi-reference.adoc:674
#, no-wrap
msgid "Description"
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/cdi-reference.adoc:136
#: upstream/_versions/main/guides/cdi-reference.adoc:467
#: upstream/_versions/main/guides/cdi-reference.adoc:674
#, no-wrap
msgid "`org.acme.Foo`"
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/cdi-reference.adoc:137
#, no-wrap
msgid "Match the fully qualified name of the class"
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/cdi-reference.adoc:137
#: upstream/_versions/main/guides/cdi-reference.adoc:468
#: upstream/_versions/main/guides/cdi-reference.adoc:675
#, no-wrap
msgid "`org.acme.*`"
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/cdi-reference.adoc:138
#, no-wrap
msgid "Match classes with package `org.acme`"
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/cdi-reference.adoc:138
#: upstream/_versions/main/guides/cdi-reference.adoc:469
#: upstream/_versions/main/guides/cdi-reference.adoc:676
#, no-wrap
msgid "`org.acme.**`"
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/cdi-reference.adoc:139
#, no-wrap
msgid "Match classes where the package starts with `org.acme`"
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/cdi-reference.adoc:139
#: upstream/_versions/main/guides/cdi-reference.adoc:470
#: upstream/_versions/main/guides/cdi-reference.adoc:677
#, no-wrap
msgid "`Bar`"
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/cdi-reference.adoc:140
#, no-wrap
msgid "Match the simple name of the class"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:146
#, no-wrap
msgid "quarkus.arc.exclude-types=org.acme.Foo,org.acme.*,Bar <1><2><3>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:148
msgid "Exclude the type `org.acme.Foo`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:149
msgid "Exclude all types from the `org.acme` package."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:150
msgid "Exclude all types whose simple name is `Bar`"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:153
msgid "It is also possible to exclude a dependency artifact that would be otherwise scanned for beans.  For example, because it contains a `beans.xml` descriptor."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:159
#, no-wrap
msgid ""
"quarkus.arc.exclude-dependency.acme.group-id=org.acme <1>\n"
"quarkus.arc.exclude-dependency.acme.artifact-id=acme-services <2>\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cdi-reference.adoc:163
#, no-wrap
msgid "Native Executables and Private Members"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:169
msgid "Quarkus is using GraalVM to build a native executable.  One of the limitations of GraalVM is the usage of link:https://www.graalvm.org/{graalvm-docs-version}/reference-manual/native-image/Reflection/[Reflection, window=\"_blank\"].  Reflective operations are supported but all relevant members must be registered for reflection explicitly.  Those registrations result in a bigger native executable."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:173
msgid "And if Quarkus DI needs to access a private member it *has to use reflection*.  That's why Quarkus users are encouraged __not to use private members__ in their beans.  This involves injection fields, constructors and initializers, observer methods, producer methods and fields, disposers and interceptor methods."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:176
msgid "How to avoid using private members? You can use package-private modifiers:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:181
#: upstream/_versions/main/guides/cdi-reference.adoc:198
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class CounterBean {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:184
#, no-wrap
msgid ""
"    @Inject\n"
"    CounterService counterService; <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:188
#, no-wrap
msgid ""
"    void onMessage(@Observes Event msg) { <2>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:190
msgid "A package-private injection field."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:191
msgid "A package-private observer method."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:193
msgid "Or constructor injection:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:200
#, no-wrap
msgid "    private CounterService service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:205
#, no-wrap
msgid ""
"    CounterBean(CounterService service) { <1>\n"
"      this.service = service;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:207
msgid "A package-private constructor injection. `@Inject` is optional in this particular case."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cdi-reference.adoc:209
#, no-wrap
msgid "[[supported_features]][[limitations]] Supported Features and Limitations"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:213
msgid "The CDI Lite specification is fully supported.  The following features from CDI Full are also supported:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:215
msgid "Decorators"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:216
msgid "Decoration of built-in beans, such as `Event`, is not supported"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:217
msgid "`BeanManager`"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:218
msgid "In addition to the `BeanContainer` methods, the following methods are supported: `getInjectableReference()`, `resolveDecorators()`"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:219
msgid "`@SessionScoped`"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:220
msgid "Only with the Undertow extension; see xref:cdi.adoc#bean-scope-available[here] for details"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:222
msgid "These additional features are not covered by the CDI Lite TCK."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cdi-reference.adoc:224
#, no-wrap
msgid "Non-standard Features"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cdi-reference.adoc:226
#, no-wrap
msgid "Eager Instantiation of Beans"
msgstr ""

#. type: Title ====
#: upstream/_versions/main/guides/cdi-reference.adoc:229
#, no-wrap
msgid "Lazy By Default"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:233
msgid "By default, CDI beans are created lazily, when needed.  What exactly \"needed\" means depends on the scope of a bean."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:235
msgid "A *normal scoped bean* (`@ApplicationScoped`, `@RequestScoped`, etc.) is needed when a method is invoked upon an injected instance (contextual reference per the specification)."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:237
msgid "In other words, injecting a normal scoped bean will not suffice because a _client proxy_ is injected instead of a contextual instance of the bean."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:239
msgid "A *bean with a pseudo-scope* (`@Dependent` and `@Singleton` ) is created when injected."
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/cdi-reference.adoc:240
#, no-wrap
msgid "Lazy Instantiation Example"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:249
#, no-wrap
msgid ""
"@Singleton // => pseudo-scope\n"
"class AmazingService {\n"
"  String ping() {\n"
"    return \"amazing\";\n"
"  }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:256
#, no-wrap
msgid ""
"@ApplicationScoped // => normal scope\n"
"class CoolService {\n"
"  String ping() {\n"
"    return \"cool\";\n"
"  }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:259
#, no-wrap
msgid ""
"@Path(\"/ping\")\n"
"public class PingResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:262
#, no-wrap
msgid ""
"  @Inject\n"
"  AmazingService s1; <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:265
#, no-wrap
msgid ""
"  @Inject\n"
"  CoolService s2; <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:271
#, no-wrap
msgid ""
"  @GET\n"
"  public String ping() {\n"
"    return s1.ping() + s2.ping(); <3>\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:273
msgid "Injection triggers the instantiation of `AmazingService`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:274
msgid "Injection itself does not result in the instantiation of `CoolService`. A client proxy is injected."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:275
msgid "The first invocation upon the injected proxy triggers the instantiation of `CoolService`."
msgstr ""

#. type: Title ====
#: upstream/_versions/main/guides/cdi-reference.adoc:277
#, no-wrap
msgid "Startup Event"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:280
msgid "However, if you really need to instantiate a bean eagerly you can:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:282
msgid "Declare an observer of the `StartupEvent` - the scope of the bean does not matter in this case:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:290
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"class CoolService {\n"
"  void startup(@Observes StartupEvent event) { <1>\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:292
msgid "A `CoolService` is created during startup to service the observer method invocation."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:294
msgid "Use the bean in an observer of the `StartupEvent` - normal scoped beans must be used as described in xref:lazy_by_default[Lazy By Default]:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:299
#, no-wrap
msgid ""
"@Dependent\n"
"class MyBeanStarter {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:304
#, no-wrap
msgid ""
"  void startup(@Observes StartupEvent event, AmazingService amazing, CoolService cool) { <1>\n"
"    cool.toString(); <2>\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:306
msgid "The `AmazingService` is created during injection."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:307
msgid "The `CoolService` is a normal scoped bean, so we have to invoke a method upon the injected proxy to force the instantiation."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:309
msgid "Annotate the bean with `@io.quarkus.runtime.Startup` as described in xref:lifecycle.adoc#startup_annotation[Startup annotation]:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:315
#, no-wrap
msgid ""
"@Startup // <1>\n"
"@ApplicationScoped\n"
"public class EagerAppBean {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:317
#, no-wrap
msgid "   private final String name;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:322
#, no-wrap
msgid ""
"   EagerAppBean(NameGenerator generator) { // <2>\n"
"     this.name = generator.createName();\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:324
msgid "For each bean annotated with `@Startup` a synthetic observer of `StartupEvent` is generated. The default priority is used."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:325
msgid "The bean constructor is called when the application starts and the resulting contextual instance is stored in the application context."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:327
msgid "Quarkus users are encouraged to always prefer the `@Observes StartupEvent` to `@Initialized(ApplicationScoped.class)` as explained in the xref:lifecycle.adoc[Application Initialization and Termination] guide."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cdi-reference.adoc:328
#, no-wrap
msgid "Request Context Lifecycle"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:331
msgid "The request context is also active:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:333
msgid "during notification of a synchronous observer method."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:335
msgid "The request context is destroyed:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:337
msgid "after the observer notification completes for an event, if it was not already active when the notification started."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:339
msgid "An event with qualifier `@Initialized(RequestScoped.class)` is fired when the request context is initialized for an observer notification. Moreover, the events with qualifiers `@BeforeDestroyed(RequestScoped.class)` and `@Destroyed(RequestScoped.class)` are fired when the request context is destroyed."
msgstr ""

#. type: Title ====
#: upstream/_versions/main/guides/cdi-reference.adoc:340
#, no-wrap
msgid "How to Enable Trace Logging for Request Context Activation"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:343
msgid "You can set the `TRACE` level for the logger `io.quarkus.arc.requestContext` and try to analyze the log output afterwards."
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/cdi-reference.adoc:344
#, no-wrap
msgid "`application.properties` Example"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:349
#, no-wrap
msgid ""
"quarkus.log.category.\"io.quarkus.arc.requestContext\".min-level=TRACE <1>\n"
"quarkus.log.category.\"io.quarkus.arc.requestContext\".level=TRACE\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:351
msgid "You also need to adjust the minimum log level for the relevant category."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cdi-reference.adoc:352
#, no-wrap
msgid "Qualified Injected Fields"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:355
msgid "In CDI, if you declare a field injection point you need to use `@Inject` and optionally a set of qualifiers."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:361
#: upstream/_versions/main/guides/cdi-reference.adoc:697
#, no-wrap
msgid ""
"  @Inject\n"
"  @ConfigProperty(name = \"cool\")\n"
"  String coolProperty;\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:364
msgid "In Quarkus, you can skip the `@Inject` annotation completely if the injected field declares at least one qualifier."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:369
#: upstream/_versions/main/guides/cdi-reference.adoc:714
#, no-wrap
msgid ""
"  @ConfigProperty(name = \"cool\")\n"
"  String coolProperty;\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:372
msgid "With the notable exception of one special case discussed below, `@Inject` is still required for constructor and method injection."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cdi-reference.adoc:373
#, no-wrap
msgid "Simplified Constructor Injection"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:377
msgid "In CDI, a normal scoped bean must always declare a no-args constructor (this constructor is normally generated by the compiler unless you declare any other constructor).  However, this requirement complicates constructor injection - you need to provide a dummy no-args constructor to make things work in CDI."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:382
#: upstream/_versions/main/guides/cdi-reference.adoc:402
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class MyCoolService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:384
#: upstream/_versions/main/guides/cdi-reference.adoc:404
#, no-wrap
msgid "  private SimpleProcessor processor;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:387
#, no-wrap
msgid ""
"  MyCoolService() { // dummy constructor needed\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:393
#, no-wrap
msgid ""
"  @Inject // constructor injection\n"
"  MyCoolService(SimpleProcessor processor) {\n"
"    this.processor = processor;\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:397
msgid "There is no need to declare dummy constructors for normal scoped bean in Quarkus - they are generated automatically.  Also, if there's only one constructor there is no need for `@Inject`."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:409
#, no-wrap
msgid ""
"  MyCoolService(SimpleProcessor processor) {\n"
"    this.processor = processor;\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:412
msgid "We don't generate a no-args constructor automatically if a bean class extends a class that does not declare a no-args constructor."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cdi-reference.adoc:414
#, no-wrap
msgid "Removing Unused Beans"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:422
msgid "The container attempts to remove all unused beans, interceptors and decorators during build by default.  This optimization helps to minimize the amount of generated classes, thus conserving memory.  However, Quarkus can't detect the programmatic lookup performed via the `CDI.current()` static method.  Therefore, it is possible that a removal results in a false positive error, i.e. a bean is removed although it's actually used.  In such cases, you'll notice a big warning in the log.  Users and extension authors have several options xref:eliminate_false_positives[how to eliminate false positives]."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:426
msgid "The optimization can be disabled by setting `quarkus.arc.remove-unused-beans` to `none` or `false`.  Quarkus also provides a middle ground where application beans are never removed whether or not they are unused, while the optimization proceeds normally for non application classes.  To use this mode, set `quarkus.arc.remove-unused-beans` to `fwk` or `framework`."
msgstr ""

#. type: Title ====
#: upstream/_versions/main/guides/cdi-reference.adoc:427
#, no-wrap
msgid "What's Removed?"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:431
msgid "Quarkus first identifies so-called _unremovable_ beans that form the roots in the dependency tree.  A good example is a Jakarta REST resource class or a bean which declares a `@Scheduled` method."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:433
msgid "An _unremovable_ bean:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:435
msgid "is excluded from removal by an extension, or"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:436
msgid "has a name designated via `@Named`, or"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:437
msgid "declares an observer method."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:439
msgid "An _unused_ bean:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:441
msgid "is not _unremovable_, and"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:442
msgid "is not eligible for injection to any injection point in the dependency tree, and"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:443
msgid "does not declare any producer which is eligible for injection to any injection point in the dependency tree, and"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:444
msgid "is not eligible for injection into any `jakarta.enterprise.inject.Instance` or `jakarta.inject.Provider` injection point."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:446
msgid "Unused interceptors and decorators are not associated with any bean."
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/cdi-reference.adoc:450
msgid "When using the dev mode (running `./mvnw clean compile quarkus:dev`), you can see more information about which beans are being removed:"
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/cdi-reference.adoc:452
msgid "In the console - just enable the DEBUG level in your `application.properties`, i.e. `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG`"
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/cdi-reference.adoc:453
msgid "In the relevant Dev UI page"
msgstr ""

#. type: Title ====
#: upstream/_versions/main/guides/cdi-reference.adoc:456
#, no-wrap
msgid "How To Eliminate False Positives"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:460
msgid "Users can instruct the container to not remove any of their specific beans (even if they satisfy all the rules specified above) by annotating them with `@io.quarkus.arc.Unremovable`.  This annotation can be declared on a class, a producer method or field."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:463
msgid "Since this is not always possible, there is an option to achieve the same via `application.properties`.  The `quarkus.arc.unremovable-types` property accepts a list of string values that are used to match beans based on their name or package."
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/cdi-reference.adoc:468
#, no-wrap
msgid "Match the fully qualified name of the bean class"
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/cdi-reference.adoc:469
#: upstream/_versions/main/guides/cdi-reference.adoc:676
#, no-wrap
msgid "Match beans where the package of the bean class is `org.acme`"
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/cdi-reference.adoc:470
#: upstream/_versions/main/guides/cdi-reference.adoc:677
#, no-wrap
msgid "Match beans where the package of the bean class starts with `org.acme`"
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/cdi-reference.adoc:471
#, no-wrap
msgid "Match the simple name of the bean class"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:477
#, no-wrap
msgid "quarkus.arc.unremovable-types=org.acme.Foo,org.acme.*,Bar\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:480
msgid "Furthermore, extensions can eliminate false positives by producing an `UnremovableBeanBuildItem`."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cdi-reference.adoc:482
#, no-wrap
msgid "Default Beans"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:486
msgid "Quarkus adds a capability that CDI currently does not support which is to conditionally declare a bean if no other bean with equal types and qualifiers was declared by any available means (bean class, producer, synthetic bean, ...)  This is done using the `@io.quarkus.arc.DefaultBean` annotation and is best explained with an example."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:488
msgid "Say there is a Quarkus extension that among other things declares a few CDI beans like the following code does:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:493
#: upstream/_versions/main/guides/cdi-reference.adoc:566
#: upstream/_versions/main/guides/cdi-reference.adoc:587
#: upstream/_versions/main/guides/cdi-reference.adoc:619
#: upstream/_versions/main/guides/cdi-reference.adoc:642
#, no-wrap
msgid ""
"@Dependent\n"
"public class TracerConfiguration {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:498
#, no-wrap
msgid ""
"    @Produces\n"
"    public Tracer tracer(Reporter reporter, Configuration configuration) {\n"
"        return new Tracer(reporter, configuration);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:504
#, no-wrap
msgid ""
"    @Produces\n"
"    @DefaultBean\n"
"    public Configuration configuration() {\n"
"        // create a Configuration\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:511
#, no-wrap
msgid ""
"    @Produces\n"
"    @DefaultBean\n"
"    public Reporter reporter(){\n"
"        // create a Reporter\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:516
msgid "The idea is that the extension autoconfigures things for the user, eliminating a lot of boilerplate - we can just `@Inject` a `Tracer` wherever it is needed.  Now imagine that in our application we would like to utilize the configured `Tracer`, but we need to customize it a little, for example by providing a custom `Reporter`.  The only thing that would be needed in our application would be something like the following:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:522
#, no-wrap
msgid ""
"@Dependent\n"
"public class CustomTracerConfiguration {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:528
#, no-wrap
msgid ""
"    @Produces\n"
"    public Reporter reporter(){\n"
"        // create a custom Reporter\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:532
msgid "`@DefaultBean` allows extensions (or any other code for that matter) to provide defaults while backing off if beans of that type are supplied in any way Quarkus supports."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:536
msgid "Default beans can optionally declare `@jakarta.annotation.Priority`.  If there is no priority defined, `@Priority(0)` is assumed.  Priority value is used for bean ordering and during typesafe resolution to disambiguate multiple matching default beans."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:541
#, no-wrap
msgid ""
"@Dependent\n"
"public class CustomizedDefaultConfiguration {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:550
#, no-wrap
msgid ""
"    @Produces\n"
"    @DefaultBean\n"
"    @Priority(100)\n"
"    public Configuration customizedConfiguration(){\n"
"        // create a customized default Configuration\n"
"        // this will have priority over previously defined default bean\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cdi-reference.adoc:553
#, no-wrap
msgid "Enabling Beans for Quarkus Build Profile"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:558
msgid "Quarkus adds a capability that CDI currently does not support which is to conditionally enable a bean when a Quarkus build time profile is enabled, via the `@io.quarkus.arc.profile.IfBuildProfile` and `@io.quarkus.arc.profile.UnlessBuildProfile` annotations.  When used in conjunction with `@io.quarkus.arc.DefaultBean`, these annotations allow for the creation of different bean configurations for different build profiles."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:561
msgid "Imagine for instance that an application contains a bean named `Tracer`, which needs to do nothing when in tests or in dev mode, but works in its normal capacity for the production artifact.  An elegant way to create such beans is the following:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:572
#, no-wrap
msgid ""
"    @Produces\n"
"    @IfBuildProfile(\"prod\")\n"
"    public Tracer realTracer(Reporter reporter, Configuration configuration) {\n"
"        return new RealTracer(reporter, configuration);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:579
#: upstream/_versions/main/guides/cdi-reference.adoc:600
#: upstream/_versions/main/guides/cdi-reference.adoc:632
#: upstream/_versions/main/guides/cdi-reference.adoc:655
#, no-wrap
msgid ""
"    @Produces\n"
"    @DefaultBean\n"
"    public Tracer noopTracer() {\n"
"        return new NoopTracer();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:582
msgid "If instead, it is required that the `Tracer` bean also works in dev mode and only default to doing nothing for tests, then `@UnlessBuildProfile` would be ideal. The code would look like:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:593
#, no-wrap
msgid ""
"    @Produces\n"
"    @UnlessBuildProfile(\"test\") // this will be enabled for both prod and dev build time profiles\n"
"    public Tracer realTracer(Reporter reporter, Configuration configuration) {\n"
"        return new RealTracer(reporter, configuration);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:603
msgid "The runtime profile has absolutely no effect on the bean resolution using `@IfBuildProfile` and `@UnlessBuildProfile`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:605
msgid "It is also possible to use `@IfBuildProfile` and `@UnlessBuildProfile` on stereotypes."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cdi-reference.adoc:607
#, no-wrap
msgid "Enabling Beans for Quarkus Build Properties"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:612
msgid "Quarkus adds a capability that CDI currently does not support which is to conditionally enable a bean when a Quarkus build time property has/has not a specific value, via the `@io.quarkus.arc.properties.IfBuildProperty` and `@io.quarkus.arc.properties.UnlessBuildProperty` annotations.  When used in conjunction with `@io.quarkus.arc.DefaultBean`, this annotation allow for the creation of different bean configurations for different build properties."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:614
msgid "The scenario we mentioned above with `Tracer` could also be implemented in the following way:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:625
#, no-wrap
msgid ""
"    @Produces\n"
"    @IfBuildProperty(name = \"some.tracer.enabled\", stringValue = \"true\")\n"
"    public Tracer realTracer(Reporter reporter, Configuration configuration) {\n"
"        return new RealTracer(reporter, configuration);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:635
msgid "`@IfBuildProperty` and `@UnlessBuildProperty` are repeatable annotations, i.e. a bean will only be enabled if **all** the conditions defined by these annotations are satisfied."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:637
msgid "If instead, it is required that the `RealTracer` bean is only used if the `some.tracer.enabled` property is not `false`, then `@UnlessBuildProperty` would be ideal. The code would look like:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:648
#, no-wrap
msgid ""
"    @Produces\n"
"    @UnlessBuildProperty(name = \"some.tracer.enabled\", stringValue = \"false\")\n"
"    public Tracer realTracer(Reporter reporter, Configuration configuration) {\n"
"        return new RealTracer(reporter, configuration);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:658
msgid "Properties set at runtime have absolutely no effect on the bean resolution using `@IfBuildProperty`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:660
msgid "It is also possible to use `@IfBuildProperty` and `@UnlessBuildProperty` on stereotypes."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cdi-reference.adoc:661
#, no-wrap
msgid "Declaring Selected Alternatives"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:665
msgid "In CDI, an alternative bean may be selected either globally for an application by means of `@Priority`, or for a bean archive using a `beans.xml` descriptor.  Quarkus has a simplified bean discovery and the content of `beans.xml` is ignored."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:670
msgid "However, it is also possible to select alternatives for an application using the unified configuration.  The `quarkus.arc.selected-alternatives` property accepts a list of string values that are used to match alternative beans.  If any value matches then the priority of `Integer#MAX_VALUE` is used for the relevant bean.  The priority declared via `@Priority` or inherited from a stereotype is overridden."
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/cdi-reference.adoc:675
#, no-wrap
msgid "Match the fully qualified name of the bean class or the bean class of the bean that declares the producer"
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/cdi-reference.adoc:678
#, no-wrap
msgid "Match the simple name of the bean class or the bean class of the bean that declares the producer"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:684
#, no-wrap
msgid "quarkus.arc.selected-alternatives=org.acme.Foo,org.acme.*,Bar\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cdi-reference.adoc:686
#, no-wrap
msgid "Simplified Producer Method Declaration"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:689
msgid "In CDI, a producer method must be always annotated with `@Produces`."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:693
#: upstream/_versions/main/guides/cdi-reference.adoc:711
#, no-wrap
msgid "class Producers {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:704
#, no-wrap
msgid ""
"  @Produces\n"
"  @ApplicationScoped\n"
"  MyService produceService() {\n"
"    return new MyService(coolProperty);\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:707
msgid "In Quarkus, you can skip the `@Produces` annotation completely if the producer method is annotated with a scope annotation, a stereotype or a qualifier."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:720
#, no-wrap
msgid ""
"  @ApplicationScoped\n"
"  MyService produceService() {\n"
"    return new MyService(coolProperty);\n"
"  }\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cdi-reference.adoc:722
#, no-wrap
msgid "Interception of Static Methods"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:728
msgid "The Interceptors specification is clear that _around-invoke_ methods must not be declared static.  However, this restriction was driven mostly by technical limitations.  And since Quarkus is a build-time oriented stack that allows for additional class transformations, those limitations don't apply anymore.  It's possible to annotate a non-private static method with an interceptor binding:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:732
#, no-wrap
msgid "class Services {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:740
#, no-wrap
msgid ""
"  @Logged <1>\n"
"  static BigDecimal computePrice(long amount) { <2>\n"
"    BigDecimal price;\n"
"    // Perform computations...\n"
"    return price;\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:742
msgid "`Logged` is an interceptor binding."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:743
msgid "Each method invocation is intercepted if there is an interceptor associated with `Logged`."
msgstr ""

#. type: Title ====
#: upstream/_versions/main/guides/cdi-reference.adoc:744
#, no-wrap
msgid "Limitations"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:747
msgid "Only *method-level bindings* are considered for backward compatibility reasons (otherwise static methods of bean classes that declare class-level bindings would be suddenly intercepted)"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:748
msgid "Private static methods are never intercepted"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:749
msgid "`InvocationContext#getTarget()` returns `null` for obvious reasons; therefore not all existing interceptors may behave correctly when intercepting static methods"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:751
msgid "Interceptors can use `InvocationContext.getMethod()` to detect static methods and adjust the behavior accordingly."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cdi-reference.adoc:753
#, no-wrap
msgid "Ability to handle 'final' classes and methods"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:758
msgid "In normal CDI, classes that are marked as `final` and / or have `final` methods are not eligible for proxy creation, which in turn means that interceptors and normal scoped beans don't work properly.  This situation is very common when trying to use CDI with alternative JVM languages like Kotlin where classes and methods are `final` by default."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:760
msgid "Quarkus however, can overcome these limitations when `quarkus.arc.transform-unproxyable-classes` is set to `true` (which is the default value)."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cdi-reference.adoc:761
#, no-wrap
msgid "Container-managed Concurrency"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:769
msgid "There is no standard concurrency control mechanism for CDI beans.  Nevertheless, a bean instance can be shared and accessed concurrently from multiple threads.  In that case it should be thread-safe.  You can use standard Java constructs (`volatile`, `synchronized`, `ReadWriteLock`, etc.) or let the container control the concurrent access.  Quarkus provides `@io.quarkus.arc.Lock` and a built-in interceptor for this interceptor binding.  Each interceptor instance associated with a contextual instance of an intercepted bean holds a separate `ReadWriteLock` with non-fair ordering policy."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:771
msgid "`io.quarkus.arc.Lock` is a regular interceptor binding and as such can be used for any bean with any scope. However, it is especially useful for \"shared\" scopes, e.g. `@Singleton` and `@ApplicationScoped`."
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/cdi-reference.adoc:772
#, no-wrap
msgid "Container-managed Concurrency Example"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:776
#, no-wrap
msgid "import io.quarkus.arc.Lock;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:780
#, no-wrap
msgid ""
"@Lock <1>\n"
"@ApplicationScoped\n"
"class SharedService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:784
#, no-wrap
msgid ""
"  void addAmount(BigDecimal amount) {\n"
"    // ...changes some internal state of the bean\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:790
#, no-wrap
msgid ""
"  @Lock(value = Lock.Type.READ, time = 1, unit = TimeUnit.SECONDS) <2> <3>\n"
"  BigDecimal getAmount() {\n"
"    // ...it is safe to read the value concurrently\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:792
msgid "`@Lock` (which maps to `@Lock(Lock.Type.WRITE)`) declared on the class instructs the container to lock the bean instance for any invocation of any business method, i.e. the client has \"exclusive access\" and no concurrent invocations will be allowed."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:793
msgid "`@Lock(Lock.Type.READ)` overrides the value specified at class level. It means that any number of clients can invoke the method concurrently, unless the bean instance is locked by `@Lock(Lock.Type.WRITE)`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:794
msgid "You can also specify the \"wait time\". If it's not possible to acquire the lock in the given time a `LockException` is thrown."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cdi-reference.adoc:795
#, no-wrap
msgid "Repeatable interceptor bindings"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:798
msgid "Quarkus has limited support for `@Repeatable` interceptor binding annotations."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:802
msgid "When binding an interceptor to a component, you can declare multiple `@Repeatable` annotations on methods.  Repeatable interceptor bindings declared on classes and stereotypes are not supported, because there are some open questions around interactions with the Interceptors specification.  This might be added in the future."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:806
msgid "As an example, suppose we have an interceptor that clears a cache.  The corresponding interceptor binding would be called `@CacheInvalidateAll` and would be declared as `@Repeatable`.  If we wanted to clear two caches at the same time, we would add `@CacheInvalidateAll` twice:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:820
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"class CachingService {\n"
"  @CacheInvalidateAll(cacheName = \"foo\")\n"
"  @CacheInvalidateAll(cacheName = \"bar\")\n"
"  void heavyComputation() {\n"
"    // ...\n"
"    // some computation that updates a lot of data\n"
"    // and requires 2 caches to be invalidated\n"
"    // ...\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:824
msgid "This is how interceptors are used.  What about creating an interceptor?"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:827
msgid "When declaring interceptor bindings of an interceptor, you can add multiple `@Repeatable` annotations to the interceptor class as usual.  This is useless when the annotation members are `@Nonbinding`, as would be the case for the `@Cached` annotation, but is important otherwise."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:831
msgid "For example, suppose we have an interceptor that can automatically log method invocations to certain targets.  The interceptor binding annotation `@Logged` would have a member called `target`, which specifies where to store the log.  Our implementation could be restricted to console logging and file logging:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:840
#, no-wrap
msgid ""
"@Interceptor\n"
"@Logged(target = \"console\")\n"
"@Logged(target = \"file\")\n"
"class NaiveLoggingInterceptor {\n"
"  // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:843
msgid "Other interceptors could be provided to log method invocations to different targets."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cdi-reference.adoc:844
#, no-wrap
msgid "Caching the Result of Programmatic Lookup"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:854
msgid "In certain situations, it is practical to obtain a bean instance programmatically via an injected `jakarta.enterprise.inject.Instance` and `Instance.get()`.  However, according to the specification the `get()` method must identify the matching bean and obtain a contextual reference.  As a consequence, a new instance of a `@Dependent` bean is returned from each invocation of `get()`.  Moreover, this instance is a dependent object of the injected `Instance`.  This behavior is well-defined, but it may lead to unexpected errors and memory leaks.  Therefore, Quarkus comes with the `io.quarkus.arc.WithCaching` annotation.  An injected `Instance` annotated with this annotation will cache the result of the `Instance#get()` operation.  The result is computed on the first call and the same value is returned for all subsequent calls, even for `@Dependent` beans."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:858
#, no-wrap
msgid "class Producer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:861
#, no-wrap
msgid ""
"  AtomicLong nextLong = new AtomicLong();\n"
"  AtomicInteger nextInt = new AtomicInteger();\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:867
#, no-wrap
msgid ""
"   @Dependent\n"
"   @Produces\n"
"   Integer produceInt() {\n"
"     return nextInt.incrementAndGet();\n"
"   }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:874
#, no-wrap
msgid ""
"   @Dependent\n"
"   @Produces\n"
"   Long produceLong() {\n"
"     return nextLong.incrementAndGet();\n"
"   }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:876
#, no-wrap
msgid "class Consumer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:879
#, no-wrap
msgid ""
"  @Inject\n"
"  Instance<Long> longInstance;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:883
#, no-wrap
msgid ""
"  @Inject\n"
"  @WithCaching\n"
"  Instance<Integer> intInstance;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:889
#, no-wrap
msgid ""
"  // this method should always return true\n"
"  // Producer#produceInt() is only called once\n"
"  boolean pingInt() {\n"
"    return intInstance.get().equals(intInstance.get());\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:896
#, no-wrap
msgid ""
"  // this method should always return false\n"
"  // Producer#produceLong() is called twice per each pingLong() invocation\n"
"  boolean pingLong() {\n"
"    return longInstance.get().equals(longInstance.get());\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:899
msgid "It is also possible to clear the cached value via `io.quarkus.arc.InjectableInstance.clearCache()`. In this case, you'll need to inject the Quarkus-specific `io.quarkus.arc.InjectableInstance` instead of `jakarta.enterprise.inject.Instance`."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cdi-reference.adoc:900
#, no-wrap
msgid "Declaratively Choose Beans That Can Be Obtained by Programmatic Lookup"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:904
msgid "It is sometimes useful to narrow down the set of beans that can be obtained by programmatic lookup via `jakarta.enterprise.inject.Instance`.  Typically, a user needs to choose the appropriate implementation of an interface based on a runtime configuration property."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:911
msgid "Imagine that we have two beans implementing the interface `org.acme.Service`.  You can't inject the `org.acme.Service` directly unless your implementations declare a CDI qualifier.  However, you can inject the `Instance<Service>` instead, then iterate over all implementations and choose the correct one manually.  Alternatively, you can use the `@LookupIfProperty` and `@LookupUnlessProperty` annotations.  `@LookupIfProperty` indicates that a bean should only be obtained if a runtime configuration property matches the provided value.  `@LookupUnlessProperty`, on the other hand, indicates that a bean should only be obtained if a runtime configuration property does not match the provided value."
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/cdi-reference.adoc:912
#, no-wrap
msgid "`@LookupIfProperty` Example"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:918
#, no-wrap
msgid ""
" interface Service {\n"
"    String name();\n"
" }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:922
#, no-wrap
msgid ""
" @LookupIfProperty(name = \"service.foo.enabled\", stringValue = \"true\")\n"
" @ApplicationScoped\n"
" class ServiceFoo implements Service {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:927
#, no-wrap
msgid ""
"    public String name() {\n"
"       return \"foo\";\n"
"    }\n"
" }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:930
#, no-wrap
msgid ""
" @ApplicationScoped\n"
" class ServiceBar implements Service {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:935
#, no-wrap
msgid ""
"    public String name() {\n"
"       return \"bar\";\n"
"    }\n"
" }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:938
#, no-wrap
msgid ""
" @ApplicationScoped\n"
" class Client {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:941
#, no-wrap
msgid ""
"    @Inject\n"
"    Instance<Service> service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:948
#, no-wrap
msgid ""
"    void printServiceName() {\n"
"       // This will print \"bar\" if the property \"service.foo.enabled\" is NOT set to \"true\"\n"
"       // If \"service.foo.enabled\" is set to \"true\" then service.get() would result in an AmbiguousResolutionException\n"
"       System.out.println(service.get().name());\n"
"    }\n"
" }\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cdi-reference.adoc:950
#, no-wrap
msgid "Injecting Multiple Bean Instances Intuitively"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:956
msgid "In CDI, it's possible to inject multiple bean instances (aka contextual references) via the `jakarta.enterprise.inject.Instance` which implements `java.lang.Iterable`.  However, it's not exactly intuitive.  Therefore, a new way was introduced in Quarkus - you can inject a `java.util.List` annotated with the `io.quarkus.arc.All` qualifier.  The type of elements in the list is used as the required type when performing the lookup."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:961
#: upstream/_versions/main/guides/cdi-reference.adoc:981
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class Processor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:966
#, no-wrap
msgid ""
"     @Inject\n"
"     @All\n"
"     List<Service> services; <1> <2>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:968
msgid "The injected instance is an _immutable list_ of the contextual references of the _disambiguated_ beans."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:969
msgid "For this injection point the required type is `Service` and no additional qualifiers are declared."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:971
msgid "The list is sorted by priority as defined by `io.quarkus.arc.InjectableBean#getPriority()`. Higher priority goes first. In general, the `@jakarta.annotation.Priority` annotation can be used to assign the priority to a class bean, producer method or producer field."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:973
msgid "If an injection point declares no other qualifier than `@All` then `@Any` is used, i.e. the behavior is equivalent to `@Inject @Any Instance<Service>`."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:976
msgid "You can also inject a list of bean instances wrapped in `io.quarkus.arc.InstanceHandle`.  This can be useful if you need to inspect the related bean metadata."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:985
#, no-wrap
msgid ""
"     @Inject\n"
"     @All\n"
"     List<InstanceHandle<Service>> services;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:995
#, no-wrap
msgid ""
"     public void doSomething() {\n"
"       for (InstanceHandle<Service> handle : services) {\n"
"         if (handle.getBean().getScope().equals(Dependent.class)) {\n"
"           handle.get().process();\n"
"           break;\n"
"         }\n"
"       }\n"
"     }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:998
msgid "Neither a type variable nor a wildcard is a legal type parameter for an `@All List<>` injection point, i.e. `@Inject @All List<?> all` is not supported and results in a deployment error."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:1000
msgid "It is also possible to obtain the list of all bean instance handles programmatically via the `Arc.container().listAll()` methods."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cdi-reference.adoc:1001
#, no-wrap
msgid "Ignoring Class-Level Interceptor Bindings for Methods and Constructors"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:1005
msgid "If a managed bean declares interceptor binding annotations on the class level, the corresponding `@AroundInvoke` interceptors will apply to all business methods.  Similarly, the corresponding `@AroundConstruct` interceptors will apply to the bean constructor."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:1007
msgid "For example, suppose we have a logging interceptor with the `@Logged` binding annotation and a tracing interceptor with the `@Traced` binding annotation:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:1016
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"@Logged\n"
"public class MyService {\n"
"    public void doSomething() {\n"
"        ...\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:1022
#, no-wrap
msgid ""
"    @Traced\n"
"    public void doSomethingElse() {\n"
"        ...\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:1026
msgid "In this example, both `doSomething` and `doSomethingElse` will be intercepted by the hypothetical logging interceptor.  Additionally, the `doSomethingElse` method will be intercepted by the hypothetical tracing interceptor."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:1029
msgid "Now, if that `@Traced` interceptor also performed all the necessary logging, we'd like to skip the `@Logged` interceptor for this method, but keep it for all other methods.  To achieve that, you can annotate the method with `@NoClassInterceptors`:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:1037
#, no-wrap
msgid ""
"@Traced\n"
"@NoClassInterceptors\n"
"public void doSomethingElse() {\n"
"    ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:1041
msgid "The `@NoClassInterceptors` annotation may be put on methods and constructors and means that all class-level interceptors are ignored for these methods and constructors.  In other words, if a method/constructor is annotated `@NoClassInterceptors`, then the only interceptors that will apply to this method/constructor are interceptors declared directly on the method/constructor."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:1043
msgid "This annotation affects only business method interceptors (`@AroundInvoke`) and constructor lifecycle callback interceptors (`@AroundConstruct`)."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cdi-reference.adoc:1044
#, no-wrap
msgid "Exceptions Thrown By An Asynchronous Observer Method"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:1051
msgid "If an exception is thrown by an asynchronous observer then the `CompletionStage` returned by the `fireAsync()` method completes exceptionally so that the event producer may react appropriately.  However, if the event producer does not care then the exception is ignored silently.  Therefore, Quarkus logs an error message by default.  It is also possible to implement a custom `AsyncObserverExceptionHandler`.  A bean that implements this interface should be `@jakarta.inject.Singleton` or `@jakarta.enterprise.context.ApplicationScoped`."
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/cdi-reference.adoc:1052
#, no-wrap
msgid "`NoopAsyncObserverExceptionHandler`"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:1057
#, no-wrap
msgid ""
"@Singleton\n"
"public class NoopAsyncObserverExceptionHandler implements AsyncObserverExceptionHandler {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:1061
#, no-wrap
msgid ""
"  void handle(Throwable throwable, ObserverMethod<?> observerMethod, EventContext<?> eventContext) {\n"
"    // do nothing\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:1063
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cdi-reference.adoc:1066
#, no-wrap
msgid "Build Time Extensions"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:1072
msgid "Quarkus incorporates build-time optimizations in order to provide instant startup and low memory footprint.  The downside of this approach is that CDI Portable Extensions cannot be supported.  Nevertheless, most of the functionality can be achieved using Quarkus xref:writing-extensions.adoc[extensions].  See the xref:cdi-integration.adoc[integration guide] for more information."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cdi-reference.adoc:1073
#, no-wrap
msgid "Development Mode"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:1076
msgid "In the development mode, two special endpoints are registered automatically to provide some basic debug info in the JSON format:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:1078
msgid "HTTP GET `/q/arc` - returns the summary; number of beans, config properties, etc."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:1079
msgid "HTTP GET `/q/arc/beans` - returns the list of all beans"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:1080
msgid "You can use query params to filter the output:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:1081
msgid "`scope` - include beans with scope that ends with the given value, i.e. `http://localhost:8080/q/arc/beans?scope=ApplicationScoped`"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:1082
msgid "`beanClass` - include beans with bean class that starts with the given value, i.e. `http://localhost:8080/q/arc/beans?beanClass=org.acme.Foo`"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:1083
msgid "`kind` - include beans of the specified kind (`CLASS`, `PRODUCER_FIELD`, `PRODUCER_METHOD`, `INTERCEPTOR` or `SYNTHETIC`), i.e. `http://localhost:8080/q/arc/beans?kind=PRODUCER_METHOD`"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:1084
msgid "HTTP GET `/q/arc/removed-beans` - returns the list of unused beans removed during build"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:1085
msgid "HTTP GET `/q/arc/observers` - returns the list of all observer methods"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:1087
msgid "These endpoints are only available in the development mode, i.e. when you run your application via `mvn quarkus:dev` (or `./gradlew quarkusDev`)."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cdi-reference.adoc:1088
#, no-wrap
msgid "Monitoring Business Method Invocations and Events"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:1092
msgid "In the development mode, it is also possible to enable monitoring of business method invocations and fired events.  Simply set the `quarkus.arc.dev-mode.monitoring-enabled` configuration property to `true` and explore the relevant Dev UI pages."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cdi-reference.adoc:1094
#, no-wrap
msgid "Strict Mode"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:1098
msgid "By default, ArC does not perform all validations required by the CDI specification.  It also improves CDI usability in many ways, some of them being directly against the specification."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:1101
msgid "To pass the CDI Lite TCK, ArC also has a _strict_ mode.  This mode enables additional validations and disables certain improvements that conflict with the specification."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:1103
msgid "To enable the strict mode, use the following configuration:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cdi-reference.adoc:1107
#, no-wrap
msgid "quarkus.arc.strict-compatibility=true\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:1110
msgid "Some other features affect specification compatibility as well:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:1112
msgid "xref:unproxyable_classes_transformation[Transformation of unproxyable classes]"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:1113
msgid "xref:remove_unused_beans[Unused beans removal]"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:1115
msgid "To get a behavior closer to the specification, these features should be disabled."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cdi-reference.adoc:1118
msgid "Applications are recommended to use the default, non-strict mode, which makes CDI more convenient to use.  The \"strictness\" of the strict mode (the set of additional validations and the set of disabled improvements on top of the CDI specification) may change over time."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cdi-reference.adoc:1120
#, no-wrap
msgid "ArC Configuration Reference"
msgstr ""

# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-11-22 02:02+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_versions/main/guides/virtual-threads.adoc:7
#, no-wrap
msgid "Virtual Thread support reference"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:20
msgid "This guide explains how to benefit from Java 21+ virtual threads in Quarkus application."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/virtual-threads.adoc:21
#, no-wrap
msgid "What are virtual threads?"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/virtual-threads.adoc:23
#, no-wrap
msgid "Terminology"
msgstr ""

#. type: Labeled list
#: upstream/_versions/main/guides/virtual-threads.adoc:24
#, no-wrap
msgid "OS thread"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:26
msgid "A \"thread-like\" data structure managed by the Operating System."
msgstr ""

#. type: Labeled list
#: upstream/_versions/main/guides/virtual-threads.adoc:27
#, no-wrap
msgid "Platform thread"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:30
msgid "Until Java 19, every instance of the link:{thread}[Thread] class was a platform thread, a wrapper around an OS thread.  Creating a platform thread creates an OS thread, and blocking a platform thread blocks an OS thread."
msgstr ""

#. type: Labeled list
#: upstream/_versions/main/guides/virtual-threads.adoc:31
#, no-wrap
msgid "Virtual thread"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:34
msgid "Lightweight, JVM-managed threads. They extend the link:{thread}[Thread] class but are not tied to one specific OS thread.  Thus, scheduling virtual threads is the responsibility of the JVM."
msgstr ""

#. type: Labeled list
#: upstream/_versions/main/guides/virtual-threads.adoc:35
#, no-wrap
msgid "Carrier thread"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:38
msgid "A platform thread used to execute a virtual thread is called a **carrier** thread.  It isn't a class distinct from link:{Thread}[Thread] or `VirtualThread` but rather a functional denomination."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/virtual-threads.adoc:39
#, no-wrap
msgid "Differences between virtual threads and platform threads"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:41
msgid "We will give a brief overview of the topic here; please refer to the link:{vthreadjep}[JEP 425] for more information."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:44
msgid "Virtual threads are a feature available since Java 19 (Java 21 is the first LTS version including virtual threads), aiming at providing a cheap alternative to platform threads for I/O-bound workloads."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:48
msgid "Until now, platform threads were the concurrency unit of the JVM.  They are a wrapper over OS structures.  Creating a Java platform thread creates a \"thread-like\" structure in your operating system."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:51
msgid "Virtual threads, on the other hand, are managed by the JVM. To be executed, they need to be mounted on a platform thread (which acts as a carrier to that virtual thread).  As such, they have been designed to offer the following characteristics:"
msgstr ""

#. type: Labeled list
#: upstream/_versions/main/guides/virtual-threads.adoc:52
#, no-wrap
msgid "Lightweight "
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:56
msgid "Virtual threads occupy less space than platform threads in memory.  Hence, it becomes possible to use more virtual threads than platform threads simultaneously without blowing up the memory.  By default, platform threads are created with a stack of about 1 MB, whereas virtual threads stack is \"pay-as-you-go.\" You can find these numbers and other motivations for virtual threads in this https://youtu.be/lIq-x_iI-kc?t=543[presentation] given by the lead developer of project Loom (the project that added the virtual thread support to the JVM)."
msgstr ""

#. type: Labeled list
#: upstream/_versions/main/guides/virtual-threads.adoc:57
#, no-wrap
msgid "Cheap to create"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:61
msgid "Creating a platform thread in Java takes time.  Currently, techniques such as pooling, where threads are created once and then reused, are strongly encouraged to minimize the time lost in starting them (as well as limiting the maximum number of threads to keep memory consumption low).  Virtual threads are supposed to be disposable entities that we create when we need them, it is discouraged to pool them or reuse them for different tasks."
msgstr ""

#. type: Labeled list
#: upstream/_versions/main/guides/virtual-threads.adoc:62
#, no-wrap
msgid "Cheap to block"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:65
msgid "When performing blocking I/O, the underlying OS thread wrapped by the Java platform thread is put in a wait queue, and a context switch occurs to load a new thread context onto the CPU core. This operation takes time.  Since the JVM manages virtual threads, no underlying OS thread is blocked when they perform a blocking operation.  Their state is stored in the heap, and another virtual thread is executed on the same Java platform (carrier) thread."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/virtual-threads.adoc:66
#, no-wrap
msgid "The Continuation Dance"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:68
msgid "As mentioned above, the JVM schedules the virtual threads. These virtual threads are mounted on carrier threads. The scheduling comes with a pinch of magic. When the virtual thread attempts to use blocking I/O, the JVM _transforms_ this call into a non-blocking one, unmounts the virtual thread, and mounts another virtual thread on the carrier thread. When the I/O completes, the _waiting_ virtual thread becomes eligible again and will be re-mounted on a carrier thread to continue its execution. For the user, all this dance is invisible. Your synchronous code is executed asynchronously."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:70
msgid "Note that the virtual thread may not be re-mounted on the same carrier thread."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/virtual-threads.adoc:72
#, no-wrap
msgid "Virtual threads are useful for I/O-bound workloads only"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:80
msgid "We now know we can create more virtual threads than platform threads. One could be tempted to use virtual threads to perform long computations (CPU-bound workload).  It is useless and counterproductive.  CPU-bound doesn't consist of quickly swapping threads while they need to wait for the completion of an I/O, but in leaving them attached to a CPU core to compute something.  In this scenario, it is worse than useless to have thousands of threads if we have tens of CPU cores, virtual threads won't enhance the performance of CPU-bound workloads.  Even worse, when running a CPU-bound workload on a virtual thread, the virtual thread monopolizes the carrier thread on which it is mounted.  It will either reduce the chance for the other virtual thread to run or will start creating new carrier threads, leading to high memory usage."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/virtual-threads.adoc:82
#, no-wrap
msgid "Run code on virtual threads using @RunOnVirtualThread"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:87
msgid "In Quarkus, the support of virtual thread is implemented using the link:{runonvthread}[@RunOnVirtualThread] annotation.  This section briefly overviews the rationale and how to use it.  There are dedicated guides for extensions supporting that annotation, such as:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:89
msgid "xref:./resteasy-reactive-virtual-threads.adoc[Virtual threads in REST applications]"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:90
msgid "xref:./messaging-virtual-threads.adoc[Virtual threads in reactive messaging applications]"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:91
msgid "xref:./grpc-virtual-threads.adoc[Virtual threads in gRPC services]"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:92
msgid "xref:./scheduler-reference.adoc#virtual_threads[Execute periodic tasks on virtual threads]"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/virtual-threads.adoc:94
#, no-wrap
msgid "Why not run everything on virtual threads?"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:101
msgid "As mentioned above, not everything can run safely on virtual threads.  The risk of **monopolization** can lead to high-memory usage.  Also, there are situations where the virtual thread cannot be unmounted from the carrier thread.  This is called **pinning**.  Finally, some libraries use `ThreadLocal` to store and reuse objects.  Using virtual threads with these libraries will lead to massive allocation, as the intentionally pooled objects will be instantiated for every (disposable and generally short-lived) virtual thread."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:107
msgid "As of today, it is not possible to use virtual threads in a carefree manner.  Following such a laissez-faire approach could quickly lead to memory and resource starvation issues.  Thus, Quarkus uses an explicit model until the aforementioned issues disappear (as the Java ecosystem matures).  It is also the reason why _reactive_ extensions have the virtual thread support, and rarely the _classic_ ones.  We need to know when to dispatch on a virtual thread."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:109
msgid "It is essential to understand that these issues are not Quarkus limitations or bugs but are due to the current state of the Java ecosystem which needs to evolve to become virtual thread friendly."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:111
msgid "To learn more about the internal design and choices, check the https://dl.acm.org/doi/10.1145/3583678.3596895[Considerations for integrating virtual threads in a Java framework: a Quarkus example in a resource-constrained environment] paper."
msgstr ""

#. type: Title ====
#: upstream/_versions/main/guides/virtual-threads.adoc:113
#, no-wrap
msgid "Monopolization cases"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:117
msgid "The monopolization has been explained in the xref:cpu-bound[Virtual threads are useful for I/O-bound workloads only] section.  When running long computations, we do not allow the JVM to unmount and switch to another virtual thread until the virtual thread terminates.  Indeed, the current scheduler does not support preempting tasks."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:121
msgid "This monopolization can lead to the creation of new carrier threads to execute other virtual threads.  Creating carrier threads results in creating platform threads.  So, there is a memory cost associated with this creation."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:124
msgid "Suppose you run in a constrained environment, such as containers. In that case, monopolization can quickly become a concern, as the high memory usage can lead to out-of-memory issues and container termination.  The memory usage may be higher than with regular worker threads because of the inherent cost of the scheduling and virtual threads."
msgstr ""

#. type: Title ====
#: upstream/_versions/main/guides/virtual-threads.adoc:126
#, no-wrap
msgid "Pinning cases"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:129
msgid "The promise of \"cheap blocking\" might not always hold: a virtual thread might _pin_ its carrier on certain occasions.  The platform thread is blocked in this situation, precisely as it would have been in a typical blocking scenario."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:131
msgid "According to link:{vthreadjep}[JEP 425] this can happen in two situations:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:133
msgid "when a virtual thread performs a blocking operation inside a `synchronized` block or method"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:134
msgid "when it executes a blocking operation inside a native method or a foreign function"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:139
msgid "It can be reasonably easy to avoid these situations in your code, but verifying every dependency you use is hard.  Typically, while experimenting with virtual threads, we realized that versions older than 42.6.0 of the link:{pgsql-driver}[postgresql-JDBC driver] result in frequent pinning.  Most JDBC drivers still pin the carrier thread.  Even worse, many libraries require code changes."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:141
msgid "For more information, see link:https://quarkus.io/blog/virtual-thread-1/[When Quarkus meets Virtual Threads]"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:145
msgid "This information about pinning cases applies to PostgreSQL JDBC driver 42.5.4 and earlier.  For PostgreSQL JDBC driver 42.6.0 and later, virtually all synchronized methods have been replaced by reentrant locks.  For more information, see the link:https://jdbc.postgresql.org/changelogs/2023-03-17-42.6.0-release/[Notable Changes] for PostgreSQL JDBC driver 42.6.0."
msgstr ""

#. type: Title ====
#: upstream/_versions/main/guides/virtual-threads.adoc:147
#, no-wrap
msgid "The pooling case"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:150
msgid "Some libraries are using `ThreadLocal` as an object pooling mechanism.  Extremely popular libraries like https://github.com/FasterXML/jackson-core/issues/919[Jackson] and Netty assume that the application uses a limited number of threads, which are recycled (using a thread pool) to run multiple (unrelated but sequential) tasks."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:152
msgid "This pattern has multiple advantages, such as:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:154
msgid "Allocation benefit: heavy objects are only allocated once per thread, but because the number of these threads was intended to be limited, it would not use too much memory."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:155
msgid "Thread safety: only one thread can access the object stored in the thread local - preventing concurrent accesses."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:162
msgid "However, this pattern is counter-productive when using virtual threads.  Virtual threads are not pooled and generally short-lived.  So, instead of a few of them, we now have many of them.  For each of them, the object stored in the `ThreadLocal` is created (often large and expensive) and won't be reused, as the virtual thread is not pooled (and won't be used to run another task once the execution completes).  This problem leads to high memory usage.  Unfortunately, it requires sophisticated code changes in the libraries themselves."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/virtual-threads.adoc:163
#, no-wrap
msgid "Use @RunOnVirtualThread with RESTEasy Reactive"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:167
msgid "This section shows a brief example of using the link:{runonvthread}[@RunOnVirtualThread] annotation.  It also explains the various development and execution models offered by Quarkus."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:170
msgid "The `@RunOnVirtualThread` annotation instructs Quarkus to invoke the annotated method on a **new** virtual thread instead of the current one.  Quarkus handles the creation of the virtual thread and the offloading."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:172
msgid "Since virtual threads are disposable entities, the fundamental idea of `@RunOnVirtualThread` is to offload the execution of an endpoint handler on a new virtual thread instead of running it on an event-loop or worker thread (in the case of RESTEasy Reactive)."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:176
msgid "To do so, it suffices to add the link:{runonvthread}[@RunOnVirtualThread] annotation to the endpoint.  If the Java Virtual Machine used to **run** the application provides virtual thread support (so Java 21 or later versions), then the endpoint execution is offloaded to a virtual thread.  It will then be possible to perform blocking operations without blocking the platform thread upon which the virtual thread is mounted."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:181
msgid "In the case of RESTEasy Reactive, this annotation can only be used on endpoints annotated with link:{blockingannotation}[@Blocking] or considered blocking because of their signature.  You can visit xref:resteasy-reactive.adoc#execution-model-blocking-non-blocking[Execution model, blocking, non-blocking] for more information."
msgstr ""

#. type: Title ====
#: upstream/_versions/main/guides/virtual-threads.adoc:182
#, no-wrap
msgid "Get started with virtual threads with RESTEasy Reactive"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:185
msgid "Add the following dependency to your build file:"
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/virtual-threads.adoc:187
#: upstream/_versions/main/guides/virtual-threads.adoc:204
#, no-wrap
msgid "pom.xml"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:193
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-resteasy-reactive</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/virtual-threads.adoc:196
#, no-wrap
msgid "build.gradle"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:199
#, no-wrap
msgid "implementation(\"io.quarkus:quarkus-resteasy-reactive\")\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:202
msgid "Then, you also need to make sure that you are using Java 21+, this can be enforced in your pom.xml file with the following:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:210
#, no-wrap
msgid ""
"<properties>\n"
"    <maven.compiler.source>21</maven.compiler.source>\n"
"    <maven.compiler.target>21</maven.compiler.target>\n"
"</properties>\n"
msgstr ""

#. type: Title ====
#: upstream/_versions/main/guides/virtual-threads.adoc:212
#, no-wrap
msgid "Three development and execution models"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:216
msgid "The example below shows the differences between three endpoints, all of them querying a _fortune_ in the database then returning it to the client."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:218
msgid "the first one uses the traditional blocking style, it is considered blocking due to its signature."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:219
msgid "the second one uses Mutiny, it is considered non-blocking due to its signature."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:221
msgid "the third one uses Mutiny but in a synchronous way, since it doesn't return a \"reactive type\" it is considered blocking and the link:{runonvthread}[@RunOnVirtualThread] annotation can be used."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:225
#, no-wrap
msgid "package org.acme.rest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:230
#, no-wrap
msgid ""
"import org.acme.fortune.model.Fortune;\n"
"import org.acme.fortune.repository.FortuneRepository;\n"
"import io.smallrye.common.annotation.RunOnVirtualThread;\n"
"import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:235
#, no-wrap
msgid ""
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import java.util.List;\n"
"import java.util.Random;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:239
#, no-wrap
msgid ""
"@Path(\"\")\n"
"public class FortuneResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:241
#, no-wrap
msgid "    @Inject FortuneRepository repository;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:249
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/blocking\")\n"
"    public Fortune blocking() {\n"
"        // Runs on a worker (platform) thread\n"
"        var list = repository.findAllBlocking();\n"
"        return pickOne(list);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:257
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/reactive\")\n"
"    public Uni<Fortune> reactive() {\n"
"        // Runs on the event loop\n"
"        return repository.findAllAsync()\n"
"                .map(this::pickOne);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:266
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/virtual\")\n"
"    @RunOnVirtualThread\n"
"    public Fortune virtualThread() {\n"
"        // Runs on a virtual thread\n"
"        var list = repository.findAllAsyncAndAwait();\n"
"        return pickOne(list);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:268
#: upstream/_versions/main/guides/virtual-threads.adoc:488
#: upstream/_versions/main/guides/virtual-threads.adoc:551
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:271
msgid "The following table summarizes the options:"
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/virtual-threads.adoc:273
#, no-wrap
msgid "Model"
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/virtual-threads.adoc:273
#, no-wrap
msgid "Example of signature"
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/virtual-threads.adoc:273
#, no-wrap
msgid "Pros"
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/virtual-threads.adoc:275
#, no-wrap
msgid "Cons"
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/virtual-threads.adoc:276
#, no-wrap
msgid "Synchronous code on worker thread"
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/virtual-threads.adoc:277
#, no-wrap
msgid "`Fortune blocking()`"
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/virtual-threads.adoc:278
#: upstream/_versions/main/guides/virtual-threads.adoc:288
#, no-wrap
msgid "Simple code"
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/virtual-threads.adoc:280
#, no-wrap
msgid "Use worker thread (limit concurrency)"
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/virtual-threads.adoc:281
#, no-wrap
msgid "Reactive code on event loop"
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/virtual-threads.adoc:282
#, no-wrap
msgid "`Uni<Fortune> reactive()`"
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/virtual-threads.adoc:283
#, no-wrap
msgid "High concurrency and low resource usage"
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/virtual-threads.adoc:285
#, no-wrap
msgid "More complex code"
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/virtual-threads.adoc:286
#, no-wrap
msgid "Synchronous code on virtual thread"
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/virtual-threads.adoc:287
#, no-wrap
msgid "`@RunOnVirtualThread Fortune vt()`"
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/virtual-threads.adoc:289
#, no-wrap
msgid "Risk of pinning, monopolization and under-efficient object pooling"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:292
msgid "Note that all three models can be used in a single application."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/virtual-threads.adoc:293
#, no-wrap
msgid "Use virtual thread friendly clients"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:297
msgid "As mentioned in the xref:why-not[Why not run everything on virtual threads?] section, the Java ecosystem is not entirely ready for virtual threads.  So, you need to be careful, especially when using a libraries doing I/O."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:300
msgid "Fortunately, Quarkus provides a massive ecosystem that is ready to be used in virtual threads.  Mutiny, the reactive programming library used in Quarkus, and the Vert.x Mutiny bindings provides the ability to write blocking code (so, no fear, no learning curve) which do not pin the carrier thread."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:302
msgid "As a result:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:305
msgid "Quarkus extensions providing blocking APIs on top of reactive APIs can be used in virtual threads.  This includes the reactive rest client, the redis client, the mailer..."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:306
msgid "API returning `Uni` can be used directly using `uni.await().atMost(...)`. It blocks the virtual thread, without blocking the carrier thread, and also improves the resilience of your application with an easy (non-blocking) timeout support."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:307
msgid "If you use a https://smallrye.io/smallrye-mutiny-vertx-bindings/latest/[Vert.x client using the Mutiny bindings], use the `andAwait()` methods which block until you get the result without pinning the carrier thread. It includes all the reactive SQL drivers."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/virtual-threads.adoc:308
#, no-wrap
msgid "Detect pinned thread in tests"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:312
msgid "We recommend to use the following configuration when running tests in application using virtual threads.  If would not fail the tests, but at least dump start traces if the code pins the carrier thread:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:326
#, no-wrap
msgid ""
"<plugin>\n"
"  <artifactId>maven-surefire-plugin</artifactId>\n"
"  <version>${surefire-plugin.version}</version>\n"
"  <configuration>\n"
"      <systemPropertyVariables>\n"
"        <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>\n"
"        <maven.home>${maven.home}</maven.home>\n"
"      </systemPropertyVariables>\n"
"      <argLine>-Djdk.tracePinnedThreads</argLine>\n"
"  </configuration>\n"
"</plugin>\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/virtual-threads.adoc:328
#, no-wrap
msgid "Run application using virtual threads"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:334
#, no-wrap
msgid "java -jar target/quarkus-app/quarkus-run.jar\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:337
msgid "Prior to Java 21, virtual threads were still an experimental feature, you need to start your application with the `--enable-preview` flag."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/virtual-threads.adoc:338
#, no-wrap
msgid "Build containers for application using virtual threads"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:341
msgid "When running your application in JVM mode (so not compiled into native, for native check xref:native[the dedicated section]), you can follow the xref:./container-image.adoc[containerization guide] to build a container."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:344
msgid "In this section, we use JIB to build the container.  Refer to the xref:./container-image.adoc[containerization guide] to learn more about the alternatives."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:346
msgid "To containerize your Quarkus application that use `@RunOnVirtualThread`, add the following properties in your `application.properties`:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:354
#, no-wrap
msgid ""
"quarkus.container-image.build=true\n"
"quarkus.container-image.group=<your-group-name>\n"
"quarkus.container-image.name=<you-container-name>\n"
"quarkus.jib.base-jvm-image=registry.access.redhat.com/ubi8/openjdk-21-runtime <1>\n"
"quarkus.jib.platforms=linux/amd64,linux/arm64 <2>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:356
msgid "Make sure you use a base image supporting virtual threads. Here we use an image providing Java 21. Quarkus picks an image providing Java 21+ automatically if you do not set one."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:357
msgid "Select the target architecture. You can select more than one to build multi-archs images."
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/virtual-threads.adoc:360
#: upstream/_versions/main/guides/virtual-threads.adoc:419
msgid "Then, build your container as you would do usually.  For example, if you are using Maven, run:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:364
#, no-wrap
msgid "mvn package\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/virtual-threads.adoc:367
#, no-wrap
msgid "Compiling Quarkus application using virtual threads into native executable"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/virtual-threads.adoc:369
#, no-wrap
msgid "Using a local GraalVM installation"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:372
msgid "To compile a Quarkus applications leveraging `@RunOnVirtualThread` into a native executable, you must be sure to use a GraalVM / Mandrel `native-image` supporting virtual threads, so providing at least Java 21."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:375
msgid "Build the native executable as indicated on xref:./building-native-image.adoc[the native compilation guide].  For example, with Maven, run:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:379
#: upstream/_versions/main/guides/virtual-threads.adoc:423
#, no-wrap
msgid "mvn package -Dnative\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/virtual-threads.adoc:381
#, no-wrap
msgid "Using an in-container build"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:386
msgid "In-container build allows building Linux 64 executables by using a `native-image` compiler running in a container.  It avoids having to install `native-image` on your machine, and also allows configuring the GraalVM version you need.  Note that, to use in-container build, you must have Docker or Podman installed on your machine."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:388
msgid "Then, add to your `application.properties` file:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:393
#, no-wrap
msgid ""
"# In-container build to get a linux 64 executable\n"
"quarkus.native.container-build=true <1>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:395
msgid "Enables the in-container build"
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/virtual-threads.adoc:397
#, no-wrap
msgid "From ARM/64 to AMD/64"
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/virtual-threads.adoc:401
msgid "If you are using a Mac M1 or M2 (using an ARM64 CPU), you need to be aware that the native executable you will get using an in-container build will be a Linux executable, but using your host (ARM 64) architecture.  You can use emulation to force the architecture when using Docker with the following property:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:405
#, no-wrap
msgid "quarkus.native.container-runtime-options=--platform=linux/amd64\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:408
msgid "Be aware that it increases the compilation time... a lot (>10 minutes)."
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/virtual-threads.adoc:410
#, no-wrap
msgid "Containerize native applications using virtual threads"
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/virtual-threads.adoc:414
msgid "To build a container running a Quarkus application using virtual threads compiled into a native executable, you must make sure you have a Linux/AMD64 executable (or ARM64 if you are targeting ARM machines)."
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/virtual-threads.adoc:416
msgid "Make sure your `application.properties` contains the configuration explained in xref:native[the native compilation section]."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:426
msgid "If you ever want to build a native container image and already have an existing native image you can set `-Dquarkus.native.reuse-existing=true` and the native image build will not be re-run."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/virtual-threads.adoc:427
#, no-wrap
msgid "Use the duplicated context in virtual threads"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:431
msgid "Methods annotated with `@RunOnVirtualThread` inherit from the original duplicated context (See the xref:duplicated-context.adoc[duplicated context reference guide] for details).  So, the data written in the duplicated context (and the request scope, as the request scoped is stored in the duplicated context) by filters and interceptors are available during the method execution (even if the filters and interceptors are not run on the virtual thread)."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:433
msgid "However, thread locals are not propagated."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/virtual-threads.adoc:434
#, no-wrap
msgid "Virtual thread names"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:439
msgid "Virtual threads are created without a thread name by default, which is not practical to identify the execution for debugging and logging purposes.  Quarkus managed virtual threads are named and prefixed with `quarkus-virtual-thread-`.  You can customize this prefix, or disable the naming altogether configuring an empty value:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:443
#, no-wrap
msgid "quarkus.virtual-threads.name-prefix=\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/virtual-threads.adoc:446
#, no-wrap
msgid "Inject the virtual thread executor"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:450
msgid "In order to run tasks on virtual threads Quarkus manages an internal `ThreadPerTaskExecutor`.  In rare instances where you'd need to access this executor directly you can inject it using the `@VirtualThreads` CDI qualifier:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:452
msgid "Injecting the Virtual Thread ExecutorService is experimental and may change in future versions."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:456
#, no-wrap
msgid "package org.acme;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:458
#, no-wrap
msgid "import org.acme.fortune.repository.FortuneRepository;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:460
#, no-wrap
msgid "import java.util.concurrent.ExecutorService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:464
#, no-wrap
msgid ""
"import jakarta.enterprise.event.Observes;\n"
"import jakarta.inject.Inject;\n"
"import jakarta.transaction.Transactional;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:468
#, no-wrap
msgid ""
"import io.quarkus.logging.Log;\n"
"import io.quarkus.runtime.StartupEvent;\n"
"import io.quarkus.virtual.threads.VirtualThreads;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:470
#, no-wrap
msgid "public class MyApplication {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:473
#, no-wrap
msgid ""
"    @Inject\n"
"    FortuneRepository repository;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:477
#, no-wrap
msgid ""
"    @Inject\n"
"    @VirtualThreads\n"
"    ExecutorService vThreads;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:481
#, no-wrap
msgid ""
"    void onEvent(@Observes StartupEvent event) {\n"
"        vThreads.execute(this::findAll);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:486
#, no-wrap
msgid ""
"    @Transactional\n"
"    void findAll() {\n"
"        Log.info(repository.findAllBlocking());\n"
"    }\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/virtual-threads.adoc:490
#, no-wrap
msgid "Testing virtual thread applications"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:495
msgid "As mentioned above, virtual threads have a few limitations that can drastically affect your application performance and memory usage.  The _junit5-virtual-threads_ extension provides a way to detect pinned carrier threads while running your tests.  Thus, you can eliminate one of the most prominent limitations or be aware of the problem."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:497
msgid "To enable this detection:"
msgstr ""

#. type: Bullet: '1) '
#: upstream/_versions/main/guides/virtual-threads.adoc:499
msgid "Add the `junit5-virtual-threads` dependency to your project:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:506
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus.junit5</groupId>\n"
"    <artifactId>junit5-virtual-threads</artifactId>\n"
"    <scope>test</scope>\n"
"</dependency>\n"
msgstr ""

#. type: Bullet: '2) '
#: upstream/_versions/main/guides/virtual-threads.adoc:509
msgid "In your test case, add the `io.quarkus.test.junit5.virtual.VirtualThreadUnit` and `io.quarkus.test.junit.virtual.ShouldNotPin` annotations:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:518
#, no-wrap
msgid ""
"@QuarkusTest\n"
"@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n"
"@VirtualThreadUnit // Use the extension\n"
"@ShouldNotPin // Detect pinned carrier thread\n"
"class TodoResourceTest {\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:522
msgid "When you run your test (remember to use Java 21+), Quarkus detects pinned carrier threads.  When it happens, the test fails."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:524
msgid "The `@ShouldNotPin` can also be used on methods directly."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:527
msgid "The _junit5-virtual-threads_ also provides a `@ShouldPin` annotation for cases where pinning is unavoidable.  The following snippet demonstrates the `@ShouldPin` annotation usage."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:535
#, no-wrap
msgid ""
"@VirtualThreadUnit // Use the extension\n"
"public class LoomUnitExampleTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:537
#, no-wrap
msgid "    CodeUnderTest codeUnderTest = new CodeUnderTest();\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:543
#, no-wrap
msgid ""
"    @Test\n"
"    @ShouldNotPin\n"
"    public void testThatShouldNotPin() {\n"
"        // ...\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:549
#, no-wrap
msgid ""
"    @Test\n"
"    @ShouldPin(atMost = 1)\n"
"    public void testThatShouldPinAtMostOnce() {\n"
"        codeUnderTest.pin();\n"
"    }\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/virtual-threads.adoc:553
#, no-wrap
msgid "Additional references"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:555
msgid "https://dl.acm.org/doi/10.1145/3583678.3596895[Considerations for integrating virtual threads in a Java framework: a Quarkus example in a resource-constrained environment]"
msgstr ""

# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-09-12 12:31+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: YAML Front Matter: author
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:1
#, fuzzy, no-wrap
msgid "cescoffier"
msgstr "鹤壁市"

#. type: YAML Front Matter: date
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:1
#, fuzzy, no-wrap
msgid "2022-09-15"
msgstr "2022-09-15"

#. type: YAML Front Matter: layout
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:1
#, fuzzy, no-wrap
msgid "post"
msgstr "职位"

#. type: YAML Front Matter: synopsis
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:1
#, fuzzy, no-wrap
msgid "Implementing a job queue using Redis list and the Quarkus Redis extension"
msgstr "使用Redis列表和Quarkus Redis扩展实现一个作业队列"

#. type: YAML Front Matter: tags
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:1
#, fuzzy, no-wrap
msgid "redis"
msgstr "Redis"

#. type: YAML Front Matter: title
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:1
#, fuzzy, no-wrap
msgid "How to implement a job queue with Redis"
msgstr "如何用Redis实现一个作业队列"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:14
#, fuzzy
msgid "In https://quarkus.io/blog/redis-api-intro/[how to cache with Redis], we implemented a simple cache backed by Redis. + That's just one use case of Redis.  Redis is also used as a messaging server to implement the processing of background jobs or other kinds of messaging tasks.  This post explores implementing this pattern with Quarkus and the new Redis data source API."
msgstr "在 link:https://quarkus.io/blog/redis-api-intro/[如何使用Redis缓存] 中，我们实现了一个由Redis支持的简单缓存。+ 这只是Redis的一个用例。Redis也被用作消息服务器，以实现对后台作业或其他类型的消息任务的处理。这篇文章探讨了用Quarkus和新的Redis数据源API实现这种模式。"

#. type: Title ==
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:15
#, fuzzy, no-wrap
msgid "Job Queues and Supes!"
msgstr "工作排队和超员!"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:20
#, fuzzy
msgid "A job queue is a data structure storing _execution_ requests.  Job dispatchers submit the tasks they want to execute in that data structure.  On the other side, job consumers poll the requests and execute them."
msgstr "工作队列是一个存储 _执行_ 请求的数据结构。工作调度员在该数据结构中提交他们想要执行的任务。在另一边，工作消费者轮询请求并执行它们。"

#. type: Target for macro image
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:21
#, no-wrap
msgid "/assets/images/posts/redis-job-queue/pattern.png"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:27
#, fuzzy
msgid "There are plenty of variants of that pattern, so let's focus on the following application.  We have an application managing heroes and villains.  The application offers the possibility to simulate a fight between a random hero and a random villain.  The fight simulation is delegated to _fight simulators_, applications dedicated to that task."
msgstr "这种模式有很多变种，所以让我们专注于下面的应用。我们有一个管理英雄和恶棍的应用程序。该应用程序提供了模拟一个随机英雄和一个随机反派之间的战斗的可能性。战斗模拟被委托给 _战斗模拟器_ ，即专门用于该任务的应用程序。"

#. type: Target for macro image
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:28
#, no-wrap
msgid "/assets/images/posts/redis-job-queue/application.png"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:32
#, fuzzy
msgid "In this context, the main application submits the fight request to the job queue.  Then, the fight simulators poll the submitted fight request and execute them."
msgstr "在这种情况下，主应用程序将战斗请求提交到工作队列中。然后，战斗模拟器轮询所提交的战斗请求并执行它们。"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:36
#, fuzzy
msgid "The fight outcomes are communicated using another Redis feature: pub/sub communication.  The simulators send the outcome to a _channel_ consumed by the application.  The application then broadcasts these outcomes to a web page."
msgstr "斗争的结果是使用另一个Redis功能进行交流的：pub/sub通信。模拟器将结果发送到应用程序所使用的 _通道_ 。然后应用程序将这些结果广播到一个网页上。"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:40
#, fuzzy
msgid "This post only discusses the interaction with Redis.  The rest of the application is straightforward and just uses RESTEasy Reactive and Hibernate ORM with Panache.  You can find the full code of the application on https://github.com/cescoffier/quarkus-redis-job-queue-demo."
msgstr "这篇文章只讨论了与Redis的交互。该应用的其他部分很简单，只是使用了RESTEasy Reactive和Hibernate ORM与Panache。你可以在 https://github.com/cescoffier/quarkus-redis-job-queue-demo ，找到该应用的完整代码。"

#. type: Title ==
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:41
#, fuzzy, no-wrap
msgid "Submitting jobs"
msgstr "提交工作"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:45
#, fuzzy
msgid "The first task is to model the job queue.  We are using a https://redis.io/docs/data-types/#lists[Redis list] to store the https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/fight-simulator/src/main/java/me/escoffier/quarkus/redis/fight/FightRequest.java[FightRequest]."
msgstr "第一个任务是对作业队列进行建模。我们使用一个 link:https://redis.io/docs/data-types/#lists[Redis列表] 来存储 link:https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/fight-simulator/src/main/java/me/escoffier/quarkus/redis/fight/FightRequest.java[FightRequest] 。"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:49
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:153
#, no-wrap
msgid "package me.escoffier.quarkus.redis.fight;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:51
#, no-wrap
msgid "public record FightRequest(String id, Hero hero, Villain villain) {\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:53
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:157
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:57
#, fuzzy
msgid "Redis lists distinguish the left side of the list from the right side of the list.  This distinction allows implementing a FIFO queue where we write on the left side and consume from the right side."
msgstr "Redis 列表区分了列表的左边和右边。这种区分允许实现一个先进先出的队列，我们在左边写，从右边消耗。"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:60
#, fuzzy
msgid "To manipulate a Redis list, we need the _group of commands_ associated with this data structure.  In the https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/supes-application/src/main/java/me/escoffier/quarkus/redis/supes/SupesService.java[SupesService class], we inject the `RedisDataSource` and retrieve the group of commands:"
msgstr "为了操作Redis列表，我们需要与该数据结构相关的 _命令组_ 。在 link:https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/supes-application/src/main/java/me/escoffier/quarkus/redis/supes/SupesService.java[SupesService类中] ，我们注入 `RedisDataSource` ，并检索命令组。"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:67
#, no-wrap
msgid ""
"public SupesService(RedisDataSource dataSource, ...) {\n"
"    commands = dataSource.list(FightRequest.class);\n"
"  // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:70
#, fuzzy
msgid "Let's now look at the `submitAFight` method:"
msgstr "现在让我们来看看 `submitAFight` 方法。"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:81
#, no-wrap
msgid ""
"public FightRequest submitAFight() {\n"
"    var hero = Hero.getRandomHero();\n"
"    var villain = Villain.getRandomVillain();\n"
"    var id = UUID.randomUUID().toString();\n"
"    var request = new FightRequest(id, hero, villain);\n"
"    commands.lpush(\"fight-requests\", request);\n"
"    return request;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:85
#, fuzzy
msgid "The `submitAFight` method retrieves the random fighters, computes an id, builds the `FightRequest` instance, and executes the `LPUSH` command.  The `LPUSH` command writes the given item to the left side of the list stored at the given key (`fight-requests`)."
msgstr " `submitAFight` 方法检索随机战士，计算出一个id，建立 `FightRequest` 实例，并执行 `LPUSH` 命令。 `LPUSH` 命令将给定的项目写入存储在给定键( `fight-requests` )的列表的左边。"

#. type: Title ==
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:86
#, fuzzy, no-wrap
msgid "Receiving the job requests"
msgstr "接收工作请求"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:90
#, fuzzy
msgid "Let's now look at the other side: the fight simulators.  The simulators poll the `FightRequests` from the Redis list representing our job queue and simulate the fight."
msgstr "现在让我们来看看另一边：战斗模拟器。模拟器从代表我们工作队列的Redis列表中轮询 `FightRequests` ，并模拟战斗。"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:94
#, fuzzy
msgid "The simulator is implemented in https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/fight-simulator/src/main/java/me/escoffier/quarkus/redis/fight/FightSimulator.java[`me.escoffier.quarkus.redis.fight.FightSimulator`].  The constructor receives a configured name (to distinguish multiple simulators) and the Redis data source.  It creates the objects to emit the Redis commands to read from a Redis list:"
msgstr "模拟器是在 link:https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/fight-simulator/src/main/java/me/escoffier/quarkus/redis/fight/FightSimulator.java[`me.escoffier.quarkus.redis.fight.FightSimulator`] .构造函数接收一个配置的名称（以区分多个模拟器）和Redis数据源。它创建对象以发射Redis命令，从Redis列表中读取。"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:102
#, no-wrap
msgid ""
"public FightSimulator(@ConfigProperty(name = \"simulator-name\") String name, RedisDataSource ds) {\n"
"    this.name = name;\n"
"    this.queue = ds.list(FightRequest.class);\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:109
#, fuzzy
msgid "The simulator polls the fight requests and for each of them simulate the fight.  The implementation is an _infinite_ loop (it only stops when the application is shut down).  In each iteration, it reads the pending `FightRequest` from the right side of the queue with the `BRPOP` command.  If there is no pending request, it restarts from the beginning of the loop.  If it has a request, it simulates the fight:"
msgstr "模拟器轮询战斗请求，并为每个请求模拟战斗。该实现是一个 _无限的_ 循环（只有在应用程序关闭时才停止）。在每次迭代中，它用 `BRPOP` 命令从队列的右侧读取待定的 `FightRequest` 。如果没有待处理的请求，它就从循环的起点重新开始。如果有一个请求，它就模拟战斗。"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:125
#, no-wrap
msgid ""
"@Override\n"
"public void run() {\n"
"    logger.infof(\"Simulator %s starting\", name);\n"
"    while ((!stopped)) {\n"
"        KeyValue<String, FightRequest> item =\n"
"            queue.brpop(Duration.ofSeconds(1), \"fight-requests\");\n"
"        if (item != null) {\n"
"            var request = item.value();\n"
"            var result = simulate(request);\n"
"            //...\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:134
#, fuzzy
msgid "The `BRPOP` command retrieves and removes the last (right) element of the list.  Unlike the `RPOP`, it waits for a given amount of time (1 second in the code above) if there are no elements in the list.  So, if the list contains an element, it gets it.  Otherwise, it waits up to one second before giving up.  It returns `null` in this case.  The `BRPOP` command returns a `KeyValue` composed of the key of the list and the `FightRequest`.  It uses that structure because you can pass multiple keys, which is convenient when you have lists with priorities."
msgstr " `BRPOP` 命令检索并删除列表中最后一个（右边）元素。与 `RPOP` 不同的是，如果列表中没有元素，它将等待一定的时间（在上面的代码中为 1 秒）。所以，如果列表中包含一个元素，它就会得到它。否则，它在放弃之前最多等待一秒钟。在这种情况下，它返回 `null` 。 `BRPOP` 命令返回一个由列表的键和 `FightRequest` 组成的 `KeyValue` 。它使用这种结构是因为你可以传递多个键，这在你有优先级的列表时很方便。"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:139
#, fuzzy
msgid "The `BRPOP` command also avoids spinning indefinitely if the list is empty, as it waits for 1 second during each iteration.  Finally, the `BRPOP` command is _atomic_.  It means that if you have multiple simulators, they cannot retrieve the same item.  It dispatches each item once."
msgstr " `BRPOP` 命令也避免了在列表为空的情况下无限期地旋转，因为它在每次迭代时都要等待1秒钟。最后， `BRPOP` 命令是 _原子性的_ 。这意味着，如果你有多个模拟器，它们不能检索到相同的项目。它对每个项目进行一次派发。"

#. type: Title ==
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:140
#, fuzzy, no-wrap
msgid "Sending the fight outcome"
msgstr "发送战斗结果"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:144
#, fuzzy
msgid "The pool loop retrieves the `FightRequests` from the queue and simulates the fights, but how to communicate the results? For this, we use another Redis feature: pub/sub communication."
msgstr "池循环从队列中检索 `FightRequests` ，并模拟战斗，但如何沟通结果？为此，我们使用了另一个Redis功能：pub/sub通信。"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:147
#, fuzzy
msgid "In simple words, we are going to send the `FightResult` to a _channel_.  Applications subscribing to that channel will receive the emitted `FightResult`."
msgstr "简单地说，我们要把 `FightResult` 到一个 _通道_ 。订阅该通道的应用程序将收到发出的 `FightResult` 。"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:149
#, fuzzy
msgid "A `FightResult` contains the request id, the two fighters, and the name of the winner:"
msgstr "一个 `FightResult` ，其中包含请求ID、两名拳手和赢家的名字。"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:155
#, no-wrap
msgid "public record FightResult(String id, Hero hero, Villain villain, String winner) {\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:161
#, fuzzy
msgid "To use Redis _pub/sub_ commands, we need the object associated with this group.  In the `FightSimulator`, we also uses the `pubsub` method to get that object:"
msgstr "为了使用Redis _的pub/sub_ 命令，我们需要与该组相关的对象。在 `FightSimulator` ，我们也使用 `pubsub` 方法来获得该对象。"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:170
#, no-wrap
msgid ""
"public FightSimulator(@ConfigProperty(name = \"simulator-name\") String name, Logger logger, RedisDataSource ds) {\n"
"    this.name = name;\n"
"    this.logger = logger;\n"
"    this.queue = ds.list(FightRequest.class);\n"
"    this.publisher = ds.pubsub(FightResult.class);  // <--- this is it!\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:174
#, fuzzy
msgid "Now, we can use this `publisher` to send the `FightResults`.  After each fight, we call `publisher.publish` to send the `FightResult` instance to the `fight-results` channel:"
msgstr "现在，我们可以使用这个 `publisher` 来发送 `FightResults` 。在每次战斗之后，我们调用 `publisher.publish` 来发送 `FightResult` 实例到 `fight-results` 通道。"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:189
#, no-wrap
msgid ""
"@Override\n"
"public void run() {\n"
"    logger.infof(\"Simulator %s starting\", name);\n"
"    while ((!stopped)) {\n"
"        KeyValue<String, FightRequest> item = queue.brpop(Duration.ofSeconds(1), \"fight-requests\");\n"
"        if (item != null) {\n"
"            var request = item.value();\n"
"            var result = simulate(request);\n"
"            publisher.publish(\"fight-results\", result);  // Send the outcome\n"
"           }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:191
#, fuzzy, no-wrap
msgid "Receiving the fight outcome"
msgstr "接收战斗结果"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:194
#, fuzzy
msgid "At that point:"
msgstr "在这一点上。"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:196
#, fuzzy
msgid "we submit the fight request into the job queue,"
msgstr "我们将战斗请求提交到工作队列中。"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:197
#, fuzzy
msgid "we consume that queue and simulate the fight,"
msgstr "我们消耗该队列并模拟战斗。"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:198
#, fuzzy
msgid "we send the outcome to the `fight-results` channel."
msgstr "我们将结果发送到 `fight-results` 频道。"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:203
#, fuzzy
msgid "So, the only missing piece is the consumption of that channel.  Let's return to the https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/supes-application/src/main/java/me/escoffier/quarkus/redis/supes/SupesService.java[`me.escoffier.quarkus.redis.supes.SupesService`] class.  In the constructor, we also inject the `ReactiveRedisDataSource`, the reactive variant of the Redis data source.  Then, in the constructor code, we subscribe to the `fight-results`."
msgstr "因此，唯一缺少的部分是该渠道的消费。让我们返回到 link:https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/supes-application/src/main/java/me/escoffier/quarkus/redis/supes/SupesService.java[`me.escoffier.quarkus.redis.supes.SupesService`] 类。在构造函数中，我们还注入了 `ReactiveRedisDataSource` ，即Redis数据源的反应式变体。然后，在构造函数代码中，我们订阅了 `fight-results` 。"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:211
#, no-wrap
msgid ""
"public SupesService(RedisDataSource dataSource, ReactiveRedisDataSource reactiveRedisDataSource) {\n"
"    commands = dataSource.list(FightRequest.class);\n"
"    stream = reactiveRedisDataSource.pubsub(FightResult.class).subscribe(\"fight-results\")\n"
"            .broadcast().toAllSubscribers();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:214
#, fuzzy
msgid "Because we use the reactive data source, this subscription returns a `Multi<FightResult>`, ready to be served by Quarkus and an SSE (see https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/supes-application/src/main/java/me/escoffier/quarkus/redis/supes/SupesResource.java[SupesResource.java]):"
msgstr "因为我们使用了反应式数据源，这个订阅返回一个 `Multi<FightResult>` ，准备由Quarkus和SSE提供服务（见 link:https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/supes-application/src/main/java/me/escoffier/quarkus/redis/supes/SupesResource.java[SupesResource.java] ）。"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:223
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.SERVER_SENT_EVENTS)\n"
"@RestStreamElementType(MediaType.APPLICATION_JSON)\n"
"public Multi<FightResult> fights() {\n"
"    return supes.getFightResults();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:227
#, fuzzy
msgid "`.broadcast().toAllSubscribers()` instructs Quarkus to broadcast all the received `FightResult` to all the connected SSE.  So, the browser filters out unrequested results."
msgstr " `.broadcast().toAllSubscribers()` 指示Quarkus将所有收到的 ，广播给所有连接的SSE。所以，浏览器会过滤掉未被请求的结果。 `FightResult` "

#. type: Title ==
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:228
#, fuzzy, no-wrap
msgid "Running the system"
msgstr "运行系统"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:233
#, fuzzy
msgid "The circle is complete! The full code source is available from https://github.com/cescoffier/quarkus-redis-job-queue-demo.  To run the system, open three terminals."
msgstr "循环完成了!完整的代码源可从 https://github.com/cescoffier/quarkus-redis-job-queue-demo 要运行该系统，请打开三个终端。"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:240
#, fuzzy
msgid "First, we start the `supes-application`.  In the first terminal, navigate to the `supes-application` and run `mvn quarkus:dev` Quarkus automatically starts the PostgreSQL and Redis instances (if your machine can run containers).  In the console, hit `h` and then `c`.  It displays the running dev services.  Look for the redis one, and copy the `quarkus.redis.hosts` injected configuration:"
msgstr "首先，我们启动 `supes-application` 。在第一个终端，导航到 `supes-application` ，然后运行 `mvn quarkus:dev` Quarkus自动启动PostgreSQL和Redis实例（如果你的机器可以运行容器）。在控制台中，点击 `h` ，然后点击 `c` 。它会显示正在运行的开发服务。寻找redis的那个，并复制 `quarkus.redis.hosts` 注入的配置。"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:248
#, no-wrap
msgid ""
"redis-client - Up About a minute\n"
"  Container:        348edec50f80/trusting_jennings  docker.io/redis:7-alpine\n"
"  Network:          bridge - 0.0.0.0:53853->6379/tcp\n"
"  Exec command:     docker exec -it 348edec50f80 /bin/bash\n"
"  Injected Config:  quarkus.redis.hosts=redis://localhost:53853\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:253
#, fuzzy
msgid "In the previous snippet, copy: `quarkus.redis.hosts=redis://localhost:53853`.  This is the address of the redis server.  We need to configure to the simulators with that address."
msgstr "在前面的片段中，复制： `quarkus.redis.hosts=redis://localhost:53853` 。这就是redis服务器的地址。我们需要用这个地址配置到模拟器上。"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:256
#, fuzzy
msgid "If you go to http://localhost:8080, the web page is served.  You can hit the `fights!` button a few times."
msgstr "如果你去 http://localhost:8080 网页就会被提供。你可以多按几次 `fights!` 按钮。"

#. type: Target for macro image
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:257
#, no-wrap
msgid "/assets/images/posts/redis-job-queue/screenshot.png"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:262
#, fuzzy
msgid "The fight won't happen as we have no simulator.  However, the fight requests have been submitted and stored in the list.  So they are not lost."
msgstr "这场战斗不会发生，因为我们没有模拟器。然而，战斗请求已经提交并存储在列表中。所以他们并没有丢失。"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:264
#, fuzzy
msgid "Now, in the second terminal, navigate to the `fight-simulator` directory, and run:"
msgstr "现在，在第二个终端，导航到 `fight-simulator` 目录，并运行。"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:269
#, no-wrap
msgid ""
"mvn package\n"
"java -Dsimulator-name=A -Dquarkus.redis.hosts=redis://localhost:53853 -jar target/quarkus-app/quarkus-run.jar\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:272
#, fuzzy, no-wrap
msgid "*IMPORTANT*: update the `quarkus.redis-hosts` with the one copied above.\n"
msgstr " *重要的是* ：用上面复制的内容更新 `quarkus.redis-hosts` 。"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:274
#, fuzzy
msgid "As soon as you start it, it processes the pending fight requests:"
msgstr "一旦你启动它，它就会处理待处理的战斗请求。"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:280
#, no-wrap
msgid ""
"2022-09-11 15:31:58,914 INFO  [me.esc.qua.red.fig.FightSimulator] (Thread-3) Simulator A is going to simulate a fight between Pakku and Tulon Voidgazer\n"
"2022-09-11 15:31:59,786 INFO  [me.esc.qua.red.fig.FightSimulator] (Thread-3) Simulator A is going to simulate a fight between Comet Zuko and Arishem The Judge (Knullified)\n"
"2022-09-11 15:32:01,809 INFO  [me.esc.qua.red.fig.FightSimulator] (Thread-3) Simulator A is going to simulate a fight between Ms. America and Kazumi (Devil Form)\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:283
#, fuzzy
msgid "If you go back to the web page, the winners get a _halo_:"
msgstr "如果你回到网页上，获奖者会得到一个 _光环_ 。"

#. type: Target for macro image
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:284
#, no-wrap
msgid "/assets/images/posts/redis-job-queue/screenshot-winner.png"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:287
#, fuzzy
msgid "Now, in the third terminal, navigate to the `fight-simulator` directory, and run:"
msgstr "现在，在第三个终端，导航到 `fight-simulator` 目录，并运行。"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:291
#, no-wrap
msgid "java -Dsimulator-name=B -Dquarkus.redis.hosts=redis://localhost:53853 -jar target/quarkus-app/quarkus-run.jar\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:294
#, no-wrap
msgid "*IMPORTANT*: as in the previous command, update the `quarkus.redis-hosts` with the one copied above.\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:297
msgid "Go back to the web page and click on the `fight!` button a few times.  Check the logs of both simulators to see that the fight requests are now dispatched beween the two simulators."
msgstr ""

#. type: Title ==
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:298
#, no-wrap
msgid "Summary"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:301
msgid "This posts explains how you can implement a job queue with Redis and the Quarkus Redis datasource API."
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:303
msgid "Learn more about the Redis data source API from the https://quarkus.io/guides/redis[Quarkus documentation].  We will publish more content about Redis patterns, so stay tuned!"
msgstr ""

# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-07-05 14:18+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title =
#: upstream/_guides/telemetry-micrometer.adoc:7
#, fuzzy, no-wrap
msgid "Micrometer Metrics"
msgstr "测微计指标"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:17
#, fuzzy
msgid "Micrometer provides an abstraction layer for metrics collection.  It defines an API for basic meter types, like counters, gauges, timers, and distribution summaries, along with a `MeterRegistry` API that generalizes metrics collection and propagation for different backend monitoring systems."
msgstr "Micrometer为度量衡的收集提供了一个抽象层。它为基本的仪表类型定义了一个API，如计数器、仪表、计时器和分布式总结，同时还定义了一个 `MeterRegistry` API，为不同的后端监控系统提供通用的指标收集和传播。"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:19
#, fuzzy
msgid "Micrometer is the recommended approach to metrics for Quarkus."
msgstr "Micrometer是Quarkus推荐的度量方法。"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:22
#, fuzzy
msgid "By default, the metrics are exposed on the main HTTP server.  If you would like to surface metrics from a separate management port, see the xref:management-interface[Managed interface] section."
msgstr "默认情况下，指标是在主HTTP服务器上公开的。如果你想从一个单独的管理端口显示指标，请看 link:#management-interface[管理接口] 部分。"

#. type: Title ==
#: upstream/_guides/telemetry-micrometer.adoc:23
#, fuzzy, no-wrap
msgid "Micrometer and monitoring system extensions"
msgstr "测微计和监测系统的扩展"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:28
#, fuzzy
msgid "Quarkus Micrometer extensions are structured in the same way as the Micrometer project.  The `quarkus-micrometer` extension provides core Micrometer support and runtime integration.  Other Quarkus and Quarkiverse extensions use the Quarkus Micrometer extension to provide support for other monitoring systems."
msgstr "Quarkus Micrometer扩展的结构与Micrometer项目相同。 `quarkus-micrometer` 扩展提供核心Micrometer支持和运行时集成。其他Quarkus和Quarkiverse扩展使用Quarkus Micrometer扩展来提供对其他监控系统的支持。"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:30
#, fuzzy
msgid "Quarkus extensions:"
msgstr "夸库斯扩展："

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:32
#, fuzzy
msgid "micrometer"
msgstr "千分尺"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:33
#, fuzzy
msgid "micrometer-registry-prometheus"
msgstr "微米-注册-普罗米修斯"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:35
#, fuzzy
msgid "link:https://github.com/quarkiverse/quarkus-micrometer-registry[Quarkiverse extensions] (may be incomplete):"
msgstr "link:https://github.com/quarkiverse/quarkus-micrometer-registry[夸克宇宙的扩展] （可能不完整）："

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:37
#, fuzzy
msgid "micrometer-registry-azure-monitor"
msgstr "微量表-注册表-氮气-监测器"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:38
#, fuzzy
msgid "micrometer-registry-datadog"
msgstr "微米-注册表-数据狗"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:39
#, fuzzy
msgid "micrometer-registry-graphite"
msgstr "微米-注册-石墨"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:40
#, fuzzy
msgid "micrometer-registry-influx"
msgstr "微量表-注册-流量"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:41
#, fuzzy
msgid "micrometer-registry-jmx"
msgstr "微米-注册表-jmx"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:42
#, fuzzy
msgid "micrometer-registry-newrelic-telemetry"
msgstr "微量表-注册-新遗迹-遥测技术"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:43
#, fuzzy
msgid "micrometer-registry-otlp"
msgstr "微米-注册表-otlp"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:44
#, fuzzy
msgid "micrometer-registry-signalfx"
msgstr "微米-注册表-signalfx"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:45
#, fuzzy
msgid "micrometer-registry-stackdriver"
msgstr "千分尺-注册表-stackdriver"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:46
#, fuzzy
msgid "micrometer-registry-statsd"
msgstr "微量表-注册表-统计表"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:49
#, fuzzy
msgid "To add support for Prometheus metrics to your application, for example, use the `micrometer-registry-prometheus` extension.  It will bring in the Quarkus Micrometer extension and Micrometer core libraries as dependencies."
msgstr "例如，要在你的应用程序中添加对Prometheus度量的支持，请使用 `micrometer-registry-prometheus` 扩展。它将把Quarkus Micrometer扩展和Micrometer核心库作为依赖项引入。"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:51
#, fuzzy
msgid "Add the extension to your project using following command (from your project directory):"
msgstr "使用以下命令将扩展名添加到你的项目中（从你的项目目录中）："

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:56
#, fuzzy
msgid "This will add the following to your build file:"
msgstr "这将在你的构建文件中添加以下内容："

#. type: Block title
#: upstream/_guides/telemetry-micrometer.adoc:58
#: upstream/_guides/telemetry-micrometer.adoc:82
#: upstream/_guides/telemetry-micrometer.adoc:102
#, fuzzy, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:64
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-micrometer-registry-prometheus</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Block title
#: upstream/_guides/telemetry-micrometer.adoc:67
#: upstream/_guides/telemetry-micrometer.adoc:91
#: upstream/_guides/telemetry-micrometer.adoc:116
#, fuzzy, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:70
#, no-wrap
msgid "implementation(\"io.quarkus:quarkus-micrometer-registry-prometheus\")\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:73
#, fuzzy
msgid "And you're all set!"
msgstr "而你已经准备好了!"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:77
#, fuzzy
msgid "A similar process applies for other meter registry extensions.  To use the Micrometer StackDriver MeterRegistry, for example, you would use the `quarkus-micrometer-registry-stackdriver` extension from the Quarkiverse:"
msgstr "类似的过程也适用于其他仪表注册表扩展。例如，要使用Micrometer StackDriver MeterRegistry，你可以使用Quarkiverse中的 `quarkus-micrometer-registry-stackdriver` 扩展："

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:88
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkiverse.micrometer.registry</groupId>\n"
"    <artifactId>quarkus-micrometer-registry-stackdriver</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:94
#, no-wrap
msgid "implementation(\"io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-stackdriver\")\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/telemetry-micrometer.adoc:96
#, fuzzy, no-wrap
msgid "Other registry implementations"
msgstr "其他登记册的实施"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:100
#, fuzzy
msgid "If the Micrometer registry you would like to use does not yet have an associated extension, use the `quarkus-micrometer` extension and bring in the Micrometer meter registry dependency directly:"
msgstr "如果你想使用的Micrometer注册表还没有相关的扩展，请使用 `quarkus-micrometer` ，并直接带入Micrometer表注册表的依赖关系："

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:113
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-micrometer</artifactId>\n"
"</dependency>\n"
"<dependency>\n"
"    <groupId>com.acme</groupId>\n"
"    <artifactId>custom-micrometer-registry</artifactId>\n"
"    <version>...</version>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:120
#, no-wrap
msgid ""
"implementation(\"io.quarkus:quarkus-micrometer\")\n"
"implementation(\"com.acme:custom-micrometer-registry\")\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:124
#, fuzzy
msgid "You will then need to specify your own provider to configure and initialize the MeterRegistry, as discussed in the next section."
msgstr "然后，你将需要指定你自己的提供者来配置和初始化MeterRegistry，这将在下一节讨论。"

#. type: Title ===
#: upstream/_guides/telemetry-micrometer.adoc:125
#, fuzzy, no-wrap
msgid "Create a customized MeterRegistry"
msgstr "创建一个自定义的MeterRegistry"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:128
#, fuzzy
msgid "Use a custom `@Produces` method to create and configure a your own `MeterRegistry` if you need to."
msgstr "如果你需要的话，使用自定义的 `@Produces` 方法来创建和配置你自己的 `MeterRegistry` 。"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:130
#, fuzzy
msgid "The following example customizes the line format used for StatsD:"
msgstr "下面的例子自定义了用于StatsD的行格式："

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:138
#, no-wrap
msgid ""
"@Produces\n"
"@Singleton // <1>\n"
"public StatsdMeterRegistry createStatsdMeterRegistry(StatsdConfig statsdConfig, Clock clock) { // <2>\n"
"    // define what to do with lines\n"
"    Consumer<String> lineLogger = line -> logger.info(line);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:145
#, no-wrap
msgid ""
"    // inject a configuration object, and then customize the line builder\n"
"    return StatsdMeterRegistry.builder(statsdConfig)\n"
"          .clock(clock)\n"
"          .lineSink(lineLogger)\n"
"          .build();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:148
#, fuzzy
msgid "The method returns a `@Singleton`."
msgstr "该方法返回一个 `@Singleton` 。"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:149
#, fuzzy
msgid "The method returns the specific type of `MeterRegistry`"
msgstr "该方法返回的具体类型是 `MeterRegistry` "

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:151
#, fuzzy
msgid "This example corresponds to the following instructions in the Micrometer documentation: link:https://micrometer.io/docs/registry/statsD#_customizing_the_metrics_sink[Micrometer StatsD: Customizing the Metrics Sink]"
msgstr "这个例子对应于Micrometer文档中的以下说明： link:https://micrometer.io/docs/registry/statsD#_customizing_the_metrics_sink[Micrometer StatsD：定制度量衡水槽]"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:155
#, fuzzy
msgid "Use MicroProfile Config to inject any configuration attributes you need to configure the registry.  Most Micrometer registry extensions, like `quarkus-micrometer-registry-statsd`, provide registry-specific configuration objects that are integrated with the Quarkus configuration model.  The link:https://github.com/quarkiverse/quarkus-micrometer-registry[Quarkiverse GitHub Repository] can be a useful implementation reference."
msgstr "使用MicroProfile Config来注入你需要的任何配置属性，以配置注册表。大多数Micrometer注册表扩展，如 `quarkus-micrometer-registry-statsd` ，提供注册表特定的配置对象，与Quarkus配置模型集成。 link:https://github.com/quarkiverse/quarkus-micrometer-registry[Quarkiverse GitHub存储库] 可以作为有用的实现参考。"

#. type: Title ==
#: upstream/_guides/telemetry-micrometer.adoc:156
#, fuzzy, no-wrap
msgid "Create your own metrics"
msgstr "创建你自己的衡量标准"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:161
#, fuzzy
msgid "Metrics data is used in the aggregate to observe how data changes over time.  This data is used for trend analysis, anomaly detection, and alerting.  Data is stored by backend monitoring systems in time series databases, with new values appended to the end of the series."
msgstr "指标数据被用来观察数据如何随时间变化。这些数据被用于趋势分析、异常检测和警报。数据被后端监测系统存储在时间序列数据库中，新的数值被附加到序列的末端。"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:163
#, fuzzy
msgid "Metrics are constructed lazily. You may not see any data for the metric you're looking for until you've performed an action that will create it, like visiting an endpoint."
msgstr "指标的构建是懒散的。你可能不会看到你要找的指标的任何数据，直到你执行了一个会创建它的动作，比如访问一个端点。"

#. type: Title ===
#: upstream/_guides/telemetry-micrometer.adoc:164
#, fuzzy, no-wrap
msgid "Naming conventions"
msgstr "命名惯例"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:168
#, fuzzy
msgid "Meter names should use dots to separate segments, `a.name.like.this`.  Micrometer applies naming conventions to convert registered meter names to match the expectations of backend monitoring systems."
msgstr "仪表名称应使用点来分隔段， `a.name.like.this` 。Micrometer应用命名规则来转换注册的仪表名称，以符合后端监测系统的期望。"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:170
#, fuzzy
msgid "Given the following declaration of a timer: `registry.timer(\"http.server.requests\")`, applied naming conventions will emit the following metrics for different monitoring systems:"
msgstr "给出一个定时器的如下声明： `registry.timer(\"http.server.requests\")` ，应用命名惯例将为不同的监测系统发出以下指标："

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:172
#, fuzzy
msgid "Prometheus: `http_server_requests_duration_seconds`"
msgstr "普罗米修斯： `http_server_requests_duration_seconds` "

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:173
#, fuzzy
msgid "Atlas: `httpServerRequests`"
msgstr "阿特拉斯： `httpServerRequests` "

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:174
#, fuzzy
msgid "Graphite: `http.server.requests`"
msgstr "石墨： `http.server.requests` "

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:175
#, fuzzy
msgid "InfluxDB: `http_server_requests`"
msgstr "InfluxDB： `http_server_requests` "

#. type: Title ===
#: upstream/_guides/telemetry-micrometer.adoc:177
#, fuzzy, no-wrap
msgid "Define dimensions for aggregation"
msgstr "定义用于聚合的维度"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:181
#, fuzzy
msgid "Metrics, single numerical measurements, often have additional data captured with them. This ancillary data is used to group or aggregate metrics for analysis.  The Micrometer API refers to this dimensional data as tags, but you may it referred to as \"labels\" or \"attributes\" in other documentation sources."
msgstr "衡量标准，单一的数字测量，往往有额外的数据被捕获。这些辅助数据被用来分组或聚合度量，以便进行分析。Micrometer API将这种维度数据称为标签，但在其他文档来源中可能被称为 \"标签 \"或 \"属性\"。"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:184
#, fuzzy
msgid "Micrometer is built primariliy for backend monitoring systems that support dimensional data (metric names that are enchriched with key/value pairs).  For heirarchical systems that only support a flat metric name, Micrometer will flatten the set of key/value pairs (sorted by key) and add them to the name."
msgstr "Micrometer主要是为支持维度数据（用键/值对充实公制名称）的后台监控系统而建立的。对于只支持平面度量名称的分层系统，Micrometer会将键/值对的集合扁平化（按键排序）并将它们添加到名称中。"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:186
#, fuzzy
msgid "Tags can be specified when a meter is registered with a `MeterRegistry` or using a xref:meter-filter[Meter Filter]."
msgstr "当电表在 `MeterRegistry` ，或使用 link:#meter-filter[电表过滤器] 注册时，可以指定标签。"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:188
#, fuzzy
msgid "See the Micrometer documentation for additional advice on link:{concepts}#_tag_naming[tag naming]."
msgstr "关于 link:{concepts}#_tag_naming[标签命名] 的其他建议，请参见Micrometer文档。"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:191
#, fuzzy
msgid "Each unique combination of metric name and dimension produces a unique time series.  Using an unbounded set of dimensional data can lead to a \"cardinality explosion\", an exponential increase in the creation of new time series."
msgstr "每个独特的度量名称和维度的组合产生一个独特的时间序列。使用无限制的维度数据集会导致 \"cardinality爆炸\"，即新时间序列的创建呈指数级增长。"

#. type: Title ===
#: upstream/_guides/telemetry-micrometer.adoc:192
#, fuzzy, no-wrap
msgid "Obtain a reference to a MeterRegistry"
msgstr "获取一个对电表注册表的引用"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:195
#, fuzzy
msgid "To register meters, you need a reference to a `MeterRegistry`, which is configured and maintained by the Micrometer extension."
msgstr "要注册仪表，你需要一个对 `MeterRegistry` 的参考，这个参考是由测微仪扩展配置和维护的。"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:197
#, fuzzy
msgid "Use one of the following methods to obtain a reference to a `MeterRegistry`:"
msgstr "使用以下方法之一来获得对一个 `MeterRegistry` ："

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:199
#, fuzzy
msgid "Use CDI Constructor injection:"
msgstr "使用CDI构造器注入："

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:203
#, no-wrap
msgid "package org.acme.micrometer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:205
#, no-wrap
msgid "import io.micrometer.core.instrument.MeterRegistry;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:209
#, no-wrap
msgid ""
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.Produces;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:213
#, no-wrap
msgid ""
"@Path(\"/example\")\n"
"@Produces(\"text/plain\")\n"
"public class ExampleResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:215
#, no-wrap
msgid "    private final MeterRegistry registry;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:220
#, no-wrap
msgid ""
"    ExampleResource(MeterRegistry registry) {\n"
"        this.registry = registry;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:223
#, fuzzy
msgid "Use a `MeterRegistry` member variable and use `@Inject`:"
msgstr "使用一个 `MeterRegistry` 成员变量，并使用 `@Inject` ："

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:228
#, no-wrap
msgid ""
"    @Inject\n"
"    MeterRegistry registry;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:231
#, fuzzy
msgid "Use the global `MeterRegistry`:"
msgstr "使用全局 `MeterRegistry` ："

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:235
#, no-wrap
msgid "    MeterRegistry registry = Metrics.globalRegistry;\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/telemetry-micrometer.adoc:237
#, fuzzy, no-wrap
msgid "Gauges"
msgstr "计量器"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:241
#, fuzzy
msgid "Gauges measure a value that can increase or decrease over time, like the speedometer on a car.  Gauges can be useful when monitoring the statistics for a cache or collection."
msgstr "仪表测量的是一个可以随时间增加或减少的数值，就像汽车上的速度表。计量器在监测一个藏品或收藏品的统计数据时很有用。"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:244
#, fuzzy
msgid "Gauge values are sampled rather than set; there is no record of how the value associated with a gauge may have changed between measurements."
msgstr "测量值是取样的，而不是设定的；没有记录与一个测量值相关的数值在两次测量之间可能发生的变化。"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:246
#, fuzzy
msgid "Micrometer provides a few mechanisms for creating gauges:"
msgstr "千分表提供了一些创建量具的机制："

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:248
#, fuzzy
msgid "Wrap construction of a collection to monitor its size:"
msgstr "包裹构建一个集合，以监测其规模："

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:254
#, no-wrap
msgid ""
"List<String> list = registry.gaugeCollectionSize(\"fantastic.list\", // <1>\n"
"        Tags.of(\"key\", \"value\") // optional <2>\n"
"        new ArrayList<>());  // <3>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:257
#, fuzzy
msgid "Create a new gauge, `list.size`, using the dot-separated convention."
msgstr "创建一个新的仪表， `list.size` ，使用点分隔的惯例。"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:259
#, fuzzy
msgid "Associate xref:define-tags[tags] with the gauge.  Gauge tag values are constant, and must be assigned at construction time."
msgstr "将 link:#define-tags[标签] 与仪表相关联。仪表盘的标签值是恒定的，必须在构造时分配。"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:260
#, fuzzy
msgid "Construct the array list whose size should be observed."
msgstr "构建数组列表，其大小应被观察。"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:262
#, fuzzy
msgid "Use a builder to create a Gauge that will call a function:"
msgstr "使用一个构建器来创建一个Gauge，它将调用一个函数："

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:270
#, no-wrap
msgid ""
"Gauge.builder(\"jvm.threads.peak\", threadBean, ThreadMXBean::getPeakThreadCount) // <1>\n"
"    .baseUnit(BaseUnits.THREADS) // optional <2>\n"
"    .description(\"The peak live thread count...\") // optional <3>\n"
"    .tags(\"key\", \"value\") // optional <4>\n"
"    .register(registry); // <5>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:273
#, fuzzy
msgid "Create a new gauge called `jvm.threads.peak` that will call `getPeakThreadCount` on `threadBean`, an instance of `ThreadMXBean`"
msgstr "创建一个名为 `jvm.threads.peak` 的新仪表，它将在 `threadBean` 上调用 `getPeakThreadCount` ，一个 `ThreadMXBean` "

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:274
#, fuzzy
msgid "Define the base unit, see link:{base-units}[BaseUnits.java] for predefined values."
msgstr "定义基本单位，见 link:{base-units}[BaseUnits.java] 的预定义值。"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:275
#, fuzzy
msgid "Provide a description of the Gauge"
msgstr "提供测量仪的描述"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:276
#, fuzzy
msgid "Associate xref:define-tags[tags] with the gauge"
msgstr "将 link:#define-tags[标签] 与仪表相关联"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:277
#, fuzzy
msgid "Register the Gauge with the MeterRegistry"
msgstr "在仪表注册处注册仪表"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:280
#, fuzzy
msgid "See link:{concepts}#_gauges[Gauges] in the Micrometer documentation for more information and examples.  Of note are two special cases: `TimeGauge` for measuring time, and a `MultiGauge` for reporting several criteria together."
msgstr "更多信息和例子请见千分尺文档中的 link:{concepts}#_gauges[量具] 。值得注意的是两个特殊情况：用于测量时间的 `TimeGauge` ，以及用于一起报告几个标准的 `MultiGauge` 。"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:284
#, fuzzy
msgid "Micrometer does not create strong references to the objects it observes by default.  Depending on the registry, Micrometer either omits gauges that observe objects that have been garbage-collected entirely or uses `NaN` (not a number) as the observed value."
msgstr "Micrometer默认不会对其观察的对象创建强引用。根据注册表，Micrometer或者完全省略观察已经被垃圾收集的对象的量具，或者使用 `NaN` （不是数字）作为观察值。"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:289
#, fuzzy
msgid "When should you use a gauge? Only use a gauge when you can't use something else.  Gauges can be less straight-forward to use than other meters.  If what you are measuring can be counted (because the value always increments), use a counter instead."
msgstr "什么时候应该使用量具？只有在你不能使用其他东西时才使用仪表。仪表的使用可能不如其他仪表那么直接。如果你要测量的东西可以计算（因为数值总是递增的），就用计数器代替。"

#. type: Title ===
#: upstream/_guides/telemetry-micrometer.adoc:290
#, fuzzy, no-wrap
msgid "Counters"
msgstr "计数器"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:294
#, fuzzy
msgid "Counters measure values that only increase.  Use one of the methods below to create a counter."
msgstr "计数器测量的是只增加的数值。使用下面的方法之一来创建一个计数器。"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:296
#: upstream/_guides/telemetry-micrometer.adoc:359
#, fuzzy
msgid "Use a convenience method on the `MeterRegistry`:"
msgstr "在 `MeterRegistry` ，使用一种方便的方法："

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:300
#, no-wrap
msgid "registry.counter(\"example.prime.number\", \"type\", \"prime\"); // <1> <2>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:303
#, fuzzy
msgid "`example.prime.number` is the counter name."
msgstr " `example.prime.number` 是计数器的名称。"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:304
#, fuzzy
msgid "`type` is a dimensional tag with value `prime`."
msgstr " `type` 是一个维度标签，值为 。 `prime` "

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:307
#, fuzzy
msgid "Use `Counter.builder` to provide a description and units:"
msgstr "使用 `Counter.builder` ，提供描述和单位："

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:315
#, no-wrap
msgid ""
"Counter.builder(\"count.me\") // <1>\n"
"    .baseUnit(\"beans\")            // optional <2>\n"
"    .description(\"a description\") // optional <3>\n"
"    .tags(\"region\", \"test\")       // optional <4>\n"
"    .register(registry);\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:318
#, fuzzy
msgid "Create a new counter called `count.me`"
msgstr "创建一个新的计数器，名为 `count.me` "

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:319
#, fuzzy
msgid "Define a custom base unit. See link:{base-units}[BaseUnits.java] for predefined values."
msgstr "定义一个自定义的基本单位。参见 link:{base-units}[BaseUnits.java] 中的预定义值。"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:320
#, fuzzy
msgid "Provide a description for the counter"
msgstr "提供计数器的描述"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:321
#, fuzzy
msgid "Associate xref:define-tags[tags] with the counter"
msgstr "将 link:#define-tags[标签] 与计数器联系起来"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:323
#, fuzzy
msgid "xref:annotations[Annotate] a method"
msgstr "link:#annotations[注释] 一个方法"

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:330
#, no-wrap
msgid ""
"@Counted(value = \"counted.method\", extraTags = { \"extra\", \"annotated\" }) // <1> <2>\n"
"void countThisMethod(){\n"
"    ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:333
#, fuzzy
msgid "A CDI interceptor will create and register a counter called `counted.method`"
msgstr "一个CDI拦截器将创建并注册一个叫做 `counted.method` "

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:334
#, fuzzy
msgid "The interceptor-created counter will have the \"extra\" dimension tag with value \"annotated\""
msgstr "拦截器创建的计数器将有 \"额外 \"维度标签，其值为 \"注释\"。"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:336
#, fuzzy
msgid "See link:{concepts}#_counters[Counters] in the Micrometer documentation for more information and examples, including the less common `FunctionCounter` that can be used to measure the result returned by an always increasing function."
msgstr "更多信息和例子请参见千分尺文档中的 link:{concepts}#_counters[计数器] ，包括不太常见的 `FunctionCounter` ，它可以用来测量一个总是增加的函数所返回的结果。"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:342
#, fuzzy
msgid "When should you use a counter? Use a counter if you are doing something that can not be either timed or summarized.  If you want to understand more about how a value is changing, a timer (when the base unit of measurement is time) or a distribution summary might be more appropriate."
msgstr "什么时候应该使用计数器？如果你正在做一些既不能计时也不能总结的事情，就使用计数器。如果你想更多地了解一个值是如何变化的，计时器（当基本测量单位是时间时）或分布汇总可能更合适。"

#. type: Title ===
#: upstream/_guides/telemetry-micrometer.adoc:343
#, fuzzy, no-wrap
msgid "Summaries and Timers"
msgstr "总结和定时器"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:346
#, fuzzy
msgid "Timers and distribution summaries in Micrometer are very similar. Both meters record data, and can capture additional histogram or percentile data. While distribution summaries can be use for arbitrary types of data, timers are optimized for measuring time and durations."
msgstr "Micrometer中的计时器和分布汇总表非常相似。两种仪表都能记录数据，并能捕获额外的直方图或百分位数数据。虽然分布汇总表可以用于任意类型的数据，但计时器是为测量时间和持续时间而优化的。"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:348
#, fuzzy
msgid "Timers and distribution summaries store at least three values internally:"
msgstr "计时器和分配汇总表在内部至少存储三个值："

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:350
#, fuzzy
msgid "the aggregation of all recorded values as a sum"
msgstr "将所有记录的数值汇总为一个总和"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:351
#, fuzzy
msgid "the number of values that have been recorded (a counter)"
msgstr "已经记录的数值的数量（一个计数器）。"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:352
#, fuzzy
msgid "the highest value seen within a decaying time window (a gauge)."
msgstr "在一个衰减的时间窗口内看到的最高值（一个仪表）。"

#. type: Title ====
#: upstream/_guides/telemetry-micrometer.adoc:353
#, fuzzy, no-wrap
msgid "Create a distribution summary"
msgstr "创建一个分发摘要"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:357
#, fuzzy
msgid "Use a distribution summary to record a value, not time.  Use one of the following methods to create a distribution summary."
msgstr "使用分配摘要来记录一个值，而不是时间。使用下列方法之一来创建一个分布摘要。"

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:363
#, no-wrap
msgid "registry.summary(\"bytes.written\", \"protocol\", \"http\"); // <1> <2>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:366
#, fuzzy
msgid "`bytes.written` is the summary name"
msgstr " `bytes.written` 是摘要名称"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:367
#, fuzzy
msgid "`protocol` is a dimensional tag with value `http`."
msgstr " `protocol` 是一个维度标签，值为 。 `http` "

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:370
#, fuzzy
msgid "Use `DistributionSummary.builder` to provide a description and units:"
msgstr "使用 `DistributionSummary.builder` ，提供描述和单位："

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:374
#, fuzzy
msgid "  DistributionSummary.builder(\"response.size\") // <1>"
msgstr "DistributionSummary.builder(\"response.size\") //(1)"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:378
#, fuzzy, no-wrap
msgid ""
".baseUnit(\"bytes\")            // optional <2>\n"
".description(\"a description\") // optional <3>\n"
".tags(\"protocol\", \"http\")     // optional <4>\n"
".register(registry);\n"
msgstr ""
".baseUnit(\"bytes\")            // optional <2>\n"
".description(\"a description\") // optional <3>\n"
".tags(\"protocol\", \"http\")     // optional <4>\n"
".register(registry);\n"

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:384
#, no-wrap
msgid ""
"+\n"
"<1> Create a new distribution summary called `response.size`\n"
"<2> Use `bytes` as a base unit. See link:{base-units}[BaseUnits.java] for predefined values.\n"
"<3> Provide a description for the distribution summary\n"
"<4> Associate xref:define-tags[tags] with the distribution summary\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/telemetry-micrometer.adoc:385
#, fuzzy, no-wrap
msgid "Create a timer"
msgstr "创建一个定时器"

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:388
msgid "Timers measure short-duration latencies and how often they occur. Negative values are not supported, and longer durations could cause an overflow of the total time (Long.MAX_VALUE nanoseconds (292.3 years))."
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:390
msgid "Use one of the following methods to construct a timer."
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:394
#, no-wrap
msgid ""
"1. Use a convenience method on the `MeterRegistry`:\n"
"+\n"
"[source,java]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:396
#, fuzzy
msgid "registry.timer(\"fabric.selection\", \"primary\", \"blue\"); // <1> <2>"
msgstr "registry.timer(\"fabric.selection\", \"primary\", \"blue\"); // <一> <二>"

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:400
#, no-wrap
msgid ""
"+\n"
"<1> `fabric.selection` is the summary name\n"
"<2> `primary` is a dimensional tag with value `blue`.\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:405
#, no-wrap
msgid ""
"2. Use `Timer.builder` to provide a description and units:\n"
"+\n"
"[source,java]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:410
#, fuzzy, no-wrap
msgid ""
"Timer.builder(\"my.timer\")        // <1> <2>\n"
"    .description(\"description \") // optional <3>\n"
"    .tags(\"region\", \"test\")      // optional <4>\n"
"    .register(registry);\n"
msgstr "Timer.builder(\"my.timer\") // <1> <2> .description(\"描述\") // optional <3> .tags(\"region\", \"test\") // optional <4> .register(registry) ；"

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:416
#, no-wrap
msgid ""
"+\n"
"<1> Create a new timer called `my.timer`\n"
"<2> Timers measure time, and will convert it into the units required by the monitoring backend\n"
"<3> Provide a description for the distribution summary\n"
"<4> Associate xref:define-tags[tags] with the timer\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:420
#, no-wrap
msgid ""
"3. xref:annotations[Annotate] a method\n"
"+\n"
"[source,java]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:422
#, fuzzy
msgid "@Timed(value = \"call\", extraTags = {\"region\", \"test\"}) // <1> <2>"
msgstr "@Timed(value = \"call\", extraTags = {\"regional\", \"test\"}) // <1> <2>"

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:426
#, no-wrap
msgid ""
"+\n"
"<1> A CDI interceptor will create and register a timer called `call`\n"
"<2> The interceptor-created timer will have the \"region\" dimension tag with value \"test\"\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/telemetry-micrometer.adoc:427
#, fuzzy, no-wrap
msgid "Measure durations with Timers"
msgstr "用定时器测量持续时间"

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:430
msgid "Micrometer provides the following convenience mechanisms for recording durations."
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:434
#, no-wrap
msgid ""
"1. Wrap the invocation of a `Runnable`:\n"
"+\n"
"[source,java]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:436
#, fuzzy
msgid "timer.record(() -> noReturnValue());"
msgstr "timer.record）→ noReturnValue（；"

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:441
#, no-wrap
msgid ""
"2. Wrap the invocation of a `Callable`:\n"
"+\n"
"[source,java]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:443
#, fuzzy
msgid "timer.recordCallable(() -> returnValue());"
msgstr "timer.recordCallable) → returnValue(；"

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:448
#, no-wrap
msgid ""
"3. Create a wrapped `Runnable` for repeated invocation:\n"
"+\n"
"[source,java]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:450
#, fuzzy
msgid "Runnable r = timer.wrap(() -> noReturnValue());"
msgstr "Runnable r = timer.wrap) → noReturnValue(；"

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:455
#, no-wrap
msgid ""
"4. Create a wrapped `Callable` for repeated invocation:\n"
"+\n"
"[source,java]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:457
#, fuzzy
msgid "Callable c = timer.wrap(() -> returnValue());"
msgstr "Callable c = timer.wrap) → returnValue(；"

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:462
#, no-wrap
msgid ""
"5. Use a `Sample` for more complex code paths:\n"
"+\n"
"[source,java]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:464
#, fuzzy
msgid "Sample sample = Timer.start(registry); // <1>"
msgstr "Sample sample = Timer.start(registry); // <1>"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:466
#, fuzzy
msgid "doStuff; // <2>"
msgstr "doStuff; // <2>"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:468
#, fuzzy
msgid "sample.stop(registry.timer(\"my.timer\", \"response\", response.status())); // <3>"
msgstr "sample.stop(registry.timer(\"my.timer\", \"response\", response.status())); // <3>"

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:473
#, no-wrap
msgid ""
"+\n"
"<1> We create a sample, which records the start of the timer.\n"
"<2> The sample can be passed along as context\n"
"<3> We can choose the timer when the sample is stopped. This example uses a response status as a tag identifying the timer, which won't be known until processing is complete.\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/telemetry-micrometer.adoc:474
#, fuzzy, no-wrap
msgid "Histograms and percentiles"
msgstr "柱状图和百分位数"

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:478
msgid "Both timers and distribution summaries can be configured to emit additional statistics, like histogram data, precomputed percentiles, or service level objective (SLO) boundaries.  See link:{concepts}#_timers[Timers] and link:{concepts}#_distribution_summaries[Distribution Summaries] in the Micrometer documentation for more information and examples, including memory footprint estimation for both types."
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:482
msgid "[IMPORTANT] ==== The count, sum, and histogram data associated with timers and distribution summaries can be re-aggregated across dimensions (or across a series of instances)."
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:485
msgid "Precomputed percentile values can not. Percentiles are unique to each dataset (the 90th percentile of this collection of measurements).  ===="
msgstr ""

#. type: Title ==
#: upstream/_guides/telemetry-micrometer.adoc:486
#, fuzzy, no-wrap
msgid "Automatically generated metrics"
msgstr "自动生成的指标"

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:492
msgid "The Micrometer extension automatically times HTTP server requests. Following Prometheus naming conventions for timers, look for `http_server_requests_seconds_count`, `http_server_requests_seconds_sum`, and `http_server_requests_seconds_max`. Dimensional labels have been added for the requested uri, the HTTP method (GET, POST, etc.), the status code (200, 302, 404, etc.), and a more general outcome field."
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:494
msgid ".Ignoring endpoints"
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:503
msgid "You can disable measurement of HTTP endpoints using the `quarkus.micrometer.binder.http-server.ignore-patterns` property.  This property accepts a comma-separated list of simple regex match patterns identifying URI paths that should be ignored.  For example, setting `quarkus.micrometer.binder.http-server.ignore-patterns=/example/prime/[0-9]+` will ignore a request to `http://localhost:8080/example/prime/7919`.  A request to `http://localhost:8080/example/gauge/7919` would still be measured."
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:505
msgid ".URI templates"
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:509
msgid "The micrometer extension will make a best effort at representing URIs containing path parameters in templated form.  Using examples from above, a request to `http://localhost:8080/example/prime/7919` should appear as an attribute of `http_server_requests_seconds_*` metrics with a value of `uri=/example/prime/{number}`."
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:516
msgid "Use the `quarkus.micrometer.binder.http-server.match-patterns` property if the correct URL can not be determined.  This property accepts a comma-separated list defining an association between a simple regex match pattern and a replacement string.  For example, setting `quarkus.micrometer.binder.http-server.match-patterns=/example/prime/[0-9]+=/example/{jellybeans}` would use the value `/example/{jellybeans}` for the uri attribute any time the requested uri matches `/example/prime/[0-9]+`."
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:518
msgid ".Exported metrics format"
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:521
msgid "By default, the metrics are exported using the Prometheus format `application/openmetrics-text`, you can revert to the former format by specifying the `Accept` request header to `text/plain` (`curl -H \"Accept: text/plain\" localhost:8080/q/metrics/`)."
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:523
msgid "[[meter-filter]]"
msgstr ""

#. type: Title ==
#: upstream/_guides/telemetry-micrometer.adoc:523
#, fuzzy, no-wrap
msgid "Use `MeterFilter` to customize emitted tags and metrics"
msgstr "使用 `MeterFilter` 来定制发射的标签和指标"

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:528
msgid "Micrometer uses `MeterFilter` instances to customize the metrics emitted by `MeterRegistry` instances.  The Micrometer extension will detect `MeterFilter` CDI beans and use them when initializing `MeterRegistry` instances."
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:530
#: upstream/_guides/telemetry-micrometer.adoc:603
msgid "[source,java]"
msgstr ""

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:533
#, fuzzy
msgid "@Singleton public class CustomConfiguration {"
msgstr "@Singleton public class CustomConfiguration {"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:536
#, fuzzy, no-wrap
msgid ""
"    @ConfigProperty(name = \"deployment.env\")\n"
"    String deploymentEnv;\n"
msgstr ""
"@ConfigProperty(name = \"deployment.env\")\n"
"String deploymentEnv；"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:545
#, fuzzy, no-wrap
msgid ""
"    /** Define common tags that apply only to a Prometheus Registry */\n"
"    @Produces\n"
"    @Singleton\n"
"    @MeterFilterConstraint(applyTo = PrometheusMeterRegistry.class)\n"
"    public MeterFilter configurePrometheusRegistries() {\n"
"        return MeterFilter.commonTags(Arrays.asList(\n"
"                Tag.of(\"registry\", \"prometheus\")));\n"
"    }\n"
msgstr ""
"/**定义只适用于普罗米修斯注册中心的普通标签 */*。\n"
"@生产\n"
"@Singleton\n"
"@MeterFilterConstraint(applyTo = PrometheusMeterRegistry.class)\n"
"public MeterFilter configurePrometheusRegistries() {\n"
"    返回MeterFilter.commonTags(Arrays.asList(\n"
"            Tag.of(\"registry\", \"prometheus\"))；\n"
"}"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:553
#, fuzzy, no-wrap
msgid ""
"    /** Define common tags that apply globally */\n"
"    @Produces\n"
"    @Singleton\n"
"    public MeterFilter configureAllRegistries() {\n"
"        return MeterFilter.commonTags(Arrays.asList(\n"
"                Tag.of(\"env\", deploymentEnv)));\n"
"    }\n"
msgstr ""
"/**定义适用于全局的通用标签 */**\n"
"@生产\n"
"@Singleton\n"
"public MeterFilter configureAllRegistries() {\n"
"    返回MeterFilter.commonTags(Arrays.asList(\n"
"            Tag.of(\"env\", deploymentEnv)))；\n"
"}"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:573
#, fuzzy, no-wrap
msgid ""
"    /** Enable histogram buckets for a specific timer */\n"
"    @Produces\n"
"    @Singleton\n"
"    public MeterFilter enableHistogram() {\n"
"        return new MeterFilter() {\n"
"            @Override\n"
"            public DistributionStatisticConfig configure(Meter.Id id, DistributionStatisticConfig config) {\n"
"                if(id.getName().startsWith(\"myservice\")) {\n"
"                    return DistributionStatisticConfig.builder()\n"
"                        .percentiles(0.5, 0.95)     // median and 95th percentile, not aggregable\n"
"                        .percentilesHistogram(true) // histogram buckets (e.g. prometheus histogram_quantile)\n"
"                        .build()\n"
"                        .merge(config);\n"
"                }\n"
"                return config;\n"
"            }\n"
"        };\n"
"    }\n"
"}\n"
msgstr ""
"    /**为一个特定的计时器启用直方图桶 */*\n"
"    @产生\n"
"    @Singleton\n"
"    public MeterFilter enableHistogram() {\n"
"        返回新的MeterFilter() {\n"
"            @Override\n"
"            public DistributionStatisticConfig configure(Meter.Id Id, DistributionStatisticConfig config) {\n"
"                if(id.getName().startsWith(\"myservice\")) {\n"
"                    返回 DistributionStatisticConfig.builder()\n"
"                        .percentiles(0.5, 0.95) // 中位数和第95百分位数，不可聚合\n"
"                        .percentilesHistogram(true) // 直方图桶（例如，Prometheus histogram_quantile）。\n"
"                        .build()\n"
"                        .merge(config)；\n"
"                }\n"
"                返回config；\n"
"            }\n"
"        };\n"
"    }\n"
"}"

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:582
#, no-wrap
msgid ""
"In this example, a singleton CDI bean will produce two different `MeterFilter` beans.\n"
"One will be applied only to\n"
"Prometheus `MeterRegistry` instances (using the `@MeterFilterConstraint` qualifier), and another will be applied\n"
"to all `MeterRegistry` instances.\n"
"An application configuration property is also injected and used as a tag value.\n"
"Additional examples of MeterFilters can be found in the\n"
"link:https://micrometer.io/docs/concepts[official documentation].\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:584
#, no-wrap
msgid "[[annotations]]\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/telemetry-micrometer.adoc:584
#, fuzzy, no-wrap
msgid "Does Micrometer support annotations?"
msgstr "Micrometer支持注释吗？"

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:590
msgid "Micrometer does define two annotations, `@Counted` and `@Timed`, that can be added to methods.  The `@Timed` annotation will wrap the execution of a method and will emit the following tags in addition to any tags defined on the annotation itself: class, method, and exception (either \"none\" or the simple class name of a detected exception)."
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:593
msgid "Using annotations is limited, as you can't dynamically assign meaningful tag values.  Also note that many methods, e.g. REST endpoint methods or Vert.x Routes, are counted and timed by the micrometer extension out of the box."
msgstr ""

#. type: Title ==
#: upstream/_guides/telemetry-micrometer.adoc:594
#, fuzzy, no-wrap
msgid "Support for the MicroProfile Metrics API"
msgstr "支持MicroProfile Metrics API"

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:599
msgid "If you use the MicroProfile Metrics API in your application, the Micrometer extension will create an adaptive layer to map those metrics into the Micrometer registry.  Note that naming conventions between the two systems is different, so the metrics that are emitted when using MP Metrics with Micrometer will change."
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:601
msgid "Use a `MeterFilter` to remap names or tags according to your conventions."
msgstr ""

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:608
#, fuzzy, no-wrap
msgid ""
"@Produces\n"
"@Singleton\n"
"public MeterFilter renameApplicationMeters() {\n"
"    final String targetMetric = MPResourceClass.class.getName() + \".mpAnnotatedMethodName\";\n"
msgstr "@Produces @Singleton public MeterFilter renameApplicationMeters() { final String targetMetric = MPResourceClass.class.getName() + \" .mpAnnotatedMethodName\"；"

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:623
#, fuzzy, no-wrap
msgid ""
"    return MeterFilter() {\n"
"        @Override\n"
"        public Meter.Id map(Meter.Id id) {\n"
"            if (id.getName().equals(targetMetric)) {\n"
"                // Drop the scope tag (MP Registry type: application, vendor, base)\n"
"                List<Tag> tags = id.getTags().stream().filter(x -> !\"scope\".equals(x.getKey()))\n"
"                        .collect(Collectors.toList());\n"
"                // rename the metric\n"
"                return id.withName(\"my.metric.name\").replaceTags(tags);\n"
"            }\n"
"            return id;\n"
"        }\n"
"    };\n"
"}\n"
msgstr ""
"    返回MeterFilter() {\n"
"        @Override\n"
"        public Meter.Id map(Meter.Id id) {\n"
"            如果（id.getName().equals(targetMetric)） {\n"
"                // 删除范围标签（MP注册表类型：应用、供应商、基础）。\n"
"                List<Tag> tags = id.getTags().stream().filter(x -> !\"scope\".equals(x.getKey() ))\n"
"                        .collect(Collectors.toList())；\n"
"                //重命名度量衡\n"
"                return id.withName(\"my.metric.name\").replaceTags(tags)；\n"
"            }\n"
"            返回id；\n"
"        }\n"
"    };\n"
"}"

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:626
#, no-wrap
msgid "Ensure the following dependency is present if you require the MicroProfile Metrics API:\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:629
#, no-wrap
msgid ""
"[source,xml,role=\"primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven\"]\n"
".pom.xml\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:634
#, fuzzy, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>org.eclipse.microprofile.metrics</groupId>\n"
"    <artifactId>microprofile-metrics-api</artifactId>\n"
"</dependency>\n"
msgstr "<dependency> <groupId>org.eclipse.microprofile.metrics</groupId> <artifactId>microprofile-metrics-api</artifactId> </dependency>"

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:638
#, no-wrap
msgid ""
"[source,gradle,role=\"secondary asciidoc-tabs-target-sync-gradle\"]\n"
".build.gradle\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:640
#, fuzzy
msgid "implementation(\"org.eclipse.microprofile.metrics:microprofile-metrics-api\")"
msgstr "implementation(\"org.eclipse.microprofile.metrics:microprofile-metrics-api\")"

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:643
#, no-wrap
msgid "NOTE: The MP Metrics API compatibility layer may be moved to a different extension in the future.\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:645
#, no-wrap
msgid "[[management-interface]]\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/telemetry-micrometer.adoc:645
#, fuzzy, no-wrap
msgid "Management interface"
msgstr "管理界面"

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:648
msgid "By default, the metrics are exposed on the main HTTP server."
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:652
msgid "You can expose them on a separate network interface and port by setting `quarkus.management.enabled=true` in your application configuration.  Note that this property is a build-time property.  The value cannot be overridden at runtime."
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:654
msgid "If you enable the management interface without customizing the management network interface and port, the metrics are exposed under: `http://0.0.0.0:9000/q/metrics`."
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:657
msgid "You can configure the path of each exposed format using: [source, properties]"
msgstr ""

#. type: Plain text
#: upstream/_guides/telemetry-micrometer.adoc:661
msgid "quarkus.micrometer.export.json.enabled=true # Enable json metrics quarkus.micrometer.export.json.path=metrics/json quarkus.micrometer.export.prometheus.path=metrics/prometheus"
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:665
#, no-wrap
msgid ""
"With such a configuration, the json metrics will be available from `http://0.0.0.0:9000/q/metrics/json`.\n"
"The prometheus metrics will be available from `http://0.0.0.0:9000/q/metrics/prometheus`.\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:667
#, no-wrap
msgid "Refer to the xref:./management-interface-reference.adoc[management interface reference] for more information.\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/telemetry-micrometer.adoc:668
#, no-wrap
msgid "Configuration Reference"
msgstr ""

#. type: delimited block -
#: upstream/_guides/telemetry-micrometer.adoc:670
msgid "include::{generated-dir}/config/quarkus-micrometer.adoc[opts=optional, leveloffset=+1]"
msgstr ""

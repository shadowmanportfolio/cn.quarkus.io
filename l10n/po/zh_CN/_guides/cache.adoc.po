# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-04-26 15:09+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/cache.adoc:6
#, fuzzy, no-wrap
msgid "Application Data Caching"
msgstr "应用数据缓存"

#. type: Plain text
#: upstream/_guides/cache.adoc:13
#, fuzzy
msgid "In this guide, you will learn how to enable application data caching in any CDI managed bean of your Quarkus application."
msgstr "在本指南中，你将学习如何在Quarkus应用程序的任何CDI管理bean中启用应用程序数据缓存。"

#. type: Title ==
#: upstream/_guides/cache.adoc:16
#, fuzzy, no-wrap
msgid "Prerequisites"
msgstr "先决条件"

#. type: Title ==
#: upstream/_guides/cache.adoc:20
#, fuzzy, no-wrap
msgid "Scenario"
msgstr "场景"

#. type: Plain text
#: upstream/_guides/cache.adoc:25
#, fuzzy
msgid "Let's imagine you want to expose in your Quarkus application a REST API that allows users to retrieve the weather forecast for the next three days.  The problem is that you have to rely on an external meteorological service which only accepts requests for one day at a time and takes forever to answer.  Since the weather forecast is updated once every twelve hours, caching the service responses would definitely improve your API performances."
msgstr "让我们想象一下，你想在你的Quarkus应用程序中公开一个REST API，允许用户检索未来三天的天气预报。问题是你必须依赖一个外部的气象服务，而这个服务一次只接受一天的请求，而且要花很长时间来回答。由于天气预报每12小时更新一次，缓存服务响应肯定会改善你的API性能。"

#. type: Plain text
#: upstream/_guides/cache.adoc:27
#, fuzzy
msgid "We'll do that using a single Quarkus annotation."
msgstr "我们将使用一个单一的Quarkus注释来做到这一点。"

#. type: delimited block =
#: upstream/_guides/cache.adoc:33
msgid "In this guide, we use the default Quarkus Cache backend (Caffeine).  You can use Redis instead.  Refer to the xref:cache-redis-reference.adoc[Redis cache backend reference] to configure the Redis backend."
msgstr ""

#. type: Title ==
#: upstream/_guides/cache.adoc:35
#, fuzzy, no-wrap
msgid "Solution"
msgstr "解决方案"

#. type: Plain text
#: upstream/_guides/cache.adoc:39
#, fuzzy
msgid "We recommend that you follow the instructions in the next sections and create the application step by step.  However, you can go right to the completed example."
msgstr "我们建议你按照下面几节的说明，一步一步地创建应用程序。然而，你可以直接进入已完成的例子。"

#. type: Plain text
#: upstream/_guides/cache.adoc:41
#, fuzzy
msgid "Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive]."
msgstr "克隆 Git 仓库。 `git clone {quickstarts-clone-url}` ，或者下载一个{quickstarts-archive-url}[存档]。"

#. type: Plain text
#: upstream/_guides/cache.adoc:43
#, fuzzy
msgid "The solution is located in the `cache-quickstart` {quickstarts-tree-url}/cache-quickstart[directory]."
msgstr "该解决方案位于 `cache-quickstart` {quickstarts-treeurl}/cache-quickstart[目录]中。"

#. type: Title ==
#: upstream/_guides/cache.adoc:44
#, fuzzy, no-wrap
msgid "Creating the Maven project"
msgstr "创建Maven项目"

#. type: Plain text
#: upstream/_guides/cache.adoc:47
#, fuzzy
msgid "First, we need to create a new Quarkus project with the following command:"
msgstr "首先，我们需要用以下命令创建一个新的Quarkus项目。"

#. type: Plain text
#: upstream/_guides/cache.adoc:53
#, fuzzy
msgid "This command generates the project and imports the `cache` and `resteasy-reactive-jackson` extensions."
msgstr "该命令生成项目并导入 `cache` 和 `resteasy-reactive-jackson` 扩展。"

#. type: Plain text
#: upstream/_guides/cache.adoc:56
#, fuzzy
msgid "If you already have your Quarkus project configured, you can add the `cache` extension to your project by running the following command in your project base directory:"
msgstr "如果你已经配置了你的Quarkus项目，你可以通过在你的项目基础目录下运行以下命令，将 `cache` 扩展到你的项目。"

#. type: Plain text
#: upstream/_guides/cache.adoc:61
#, fuzzy
msgid "This will add the following to your build file:"
msgstr "这将在你的构建文件中添加以下内容。"

#. type: Block title
#: upstream/_guides/cache.adoc:63
#, fuzzy, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: delimited block -
#: upstream/_guides/cache.adoc:69
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-cache</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Block title
#: upstream/_guides/cache.adoc:72
#, fuzzy, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#. type: delimited block -
#: upstream/_guides/cache.adoc:75
#, no-wrap
msgid "implementation(\"io.quarkus:quarkus-cache\")\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/cache.adoc:77
#, fuzzy, no-wrap
msgid "Creating the REST API"
msgstr "创建REST API"

#. type: Plain text
#: upstream/_guides/cache.adoc:81
#, fuzzy
msgid "Let's start by creating a service that will simulate an extremely slow call to the external meteorological service.  Create `src/main/java/org/acme/cache/WeatherForecastService.java` with the following content:"
msgstr "让我们先创建一个服务，模拟对外部气象服务的极慢调用。创建 `src/main/java/org/acme/cache/WeatherForecastService.java` ，内容如下。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:85 upstream/_guides/cache.adoc:126
#: upstream/_guides/cache.adoc:156 upstream/_guides/cache.adoc:218
#: upstream/_guides/cache.adoc:353 upstream/_guides/cache.adoc:403
#: upstream/_guides/cache.adoc:433 upstream/_guides/cache.adoc:456
#: upstream/_guides/cache.adoc:505 upstream/_guides/cache.adoc:548
#: upstream/_guides/cache.adoc:590 upstream/_guides/cache.adoc:619
#: upstream/_guides/cache.adoc:651 upstream/_guides/cache.adoc:680
#: upstream/_guides/cache.adoc:819 upstream/_guides/cache.adoc:850
#: upstream/_guides/cache.adoc:882 upstream/_guides/cache.adoc:913
#: upstream/_guides/cache.adoc:943
#, no-wrap
msgid "package org.acme.cache;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:87 upstream/_guides/cache.adoc:220
#, no-wrap
msgid "import java.time.LocalDate;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:89 upstream/_guides/cache.adoc:222
#: upstream/_guides/cache.adoc:355 upstream/_guides/cache.adoc:458
#: upstream/_guides/cache.adoc:592 upstream/_guides/cache.adoc:621
#: upstream/_guides/cache.adoc:653 upstream/_guides/cache.adoc:821
#, no-wrap
msgid "import jakarta.enterprise.context.ApplicationScoped;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:92 upstream/_guides/cache.adoc:227
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class WeatherForecastService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:101
#, no-wrap
msgid ""
"    public String getDailyForecast(LocalDate date, String city) {\n"
"        try {\n"
"            Thread.sleep(2000L); <1>\n"
"        } catch (InterruptedException e) {\n"
"            Thread.currentThread().interrupt();\n"
"        }\n"
"        return date.getDayOfWeek() + \" will be \" + getDailyResult(date.getDayOfMonth() % 4) + \" in \" + city;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:117 upstream/_guides/cache.adoc:253
#, no-wrap
msgid ""
"    private String getDailyResult(int dayOfMonthModuloFour) {\n"
"        switch (dayOfMonthModuloFour) {\n"
"            case 0:\n"
"                return \"sunny\";\n"
"            case 1:\n"
"                return \"cloudy\";\n"
"            case 2:\n"
"                return \"chilly\";\n"
"            case 3:\n"
"                return \"rainy\";\n"
"            default:\n"
"                throw new IllegalArgumentException();\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:119
#, fuzzy
msgid "This is where the slowness comes from."
msgstr "这就是迟钝的来源。"

#. type: Plain text
#: upstream/_guides/cache.adoc:122
#, fuzzy
msgid "We also need a class that will contain the response sent to the users when they ask for the next three days weather forecast.  Create `src/main/java/org/acme/cache/WeatherForecast.java` this way:"
msgstr "我们还需要一个类，它将包含当用户询问未来三天的天气预报时发送给他们的响应。这样创建 `src/main/java/org/acme/cache/WeatherForecast.java` 。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:128
#, no-wrap
msgid "import java.util.List;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:130
#, no-wrap
msgid "public class WeatherForecast {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:132
#, no-wrap
msgid "    private List<String> dailyForecasts;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:134
#, no-wrap
msgid "    private long executionTimeInMs;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:139
#, no-wrap
msgid ""
"    public WeatherForecast(List<String> dailyForecasts, long executionTimeInMs) {\n"
"        this.dailyForecasts = dailyForecasts;\n"
"        this.executionTimeInMs = executionTimeInMs;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:143
#, no-wrap
msgid ""
"    public List<String> getDailyForecasts() {\n"
"        return dailyForecasts;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:148
#, no-wrap
msgid ""
"    public long getExecutionTimeInMs() {\n"
"        return executionTimeInMs;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:152
#, fuzzy
msgid "Now, we just need to create the REST resource.  Create the `src/main/java/org/acme/cache/WeatherForecastResource.java` file with this content:"
msgstr "现在，我们只需要创建REST资源。用这个内容创建 `src/main/java/org/acme/cache/WeatherForecastResource.java` 文件。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:160
#, no-wrap
msgid ""
"import java.time.LocalDate;\n"
"import java.util.Arrays;\n"
"import java.util.List;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:165
#, no-wrap
msgid ""
"import jakarta.inject.Inject;\n"
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:167
#, no-wrap
msgid "import org.jboss.resteasy.reactive.RestQuery;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:170
#, no-wrap
msgid ""
"@Path(\"/weather\")\n"
"public class WeatherForecastResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:173
#, no-wrap
msgid ""
"    @Inject\n"
"    WeatherForecastService service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:185
#, no-wrap
msgid ""
"    @GET\n"
"    public WeatherForecast getForecast(@RestQuery String city, @RestQuery long daysInFuture) { <1>\n"
"        long executionStart = System.currentTimeMillis();\n"
"        List<String> dailyForecasts = Arrays.asList(\n"
"                service.getDailyForecast(LocalDate.now().plusDays(daysInFuture), city),\n"
"                service.getDailyForecast(LocalDate.now().plusDays(daysInFuture + 1L), city),\n"
"                service.getDailyForecast(LocalDate.now().plusDays(daysInFuture + 2L), city));\n"
"        long executionEnd = System.currentTimeMillis();\n"
"        return new WeatherForecast(dailyForecasts, executionEnd - executionStart);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:188
#, fuzzy
msgid "If the `daysInFuture` query parameter is omitted, the three days weather forecast will start from the current day.  Otherwise, it will start from the current day plus the `daysInFuture` value."
msgstr "如果省略了 `daysInFuture` 查询参数，三天的天气预报将从当天开始。否则，它将从当前日期加上 `daysInFuture` 值开始。"

#. type: Plain text
#: upstream/_guides/cache.adoc:190
#, fuzzy
msgid "We're all done! Let's check if everything's working."
msgstr "我们都完成了!让我们检查一下是否一切正常。"

#. type: Plain text
#: upstream/_guides/cache.adoc:192
#, fuzzy
msgid "First, run the application using dev mode from the project directory:"
msgstr "首先，从项目目录中使用开发模式运行该应用程序。"

#. type: Plain text
#: upstream/_guides/cache.adoc:197
#, fuzzy
msgid "Then, call `http://localhost:8080/weather?city=Raleigh` from a browser.  After six long seconds, the application will answer something like this:"
msgstr "然后，调用 `<a href=\"http://localhost:8080/weather?city=Raleigh\" class=\"bare\">http://localhost:8080/weather?city=Raleigh</a>` 从浏览器中调用。经过六秒钟的漫长时间，该应用程序将回答类似这样的问题。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:201
#, no-wrap
msgid "{\"dailyForecasts\":[\"MONDAY will be cloudy in Raleigh\",\"TUESDAY will be chilly in Raleigh\",\"WEDNESDAY will be rainy in Raleigh\"],\"executionTimeInMs\":6001}\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/cache.adoc:206
#, fuzzy
msgid "The response content may vary depending on the day you run the code."
msgstr "响应内容可能因你运行代码的日子而不同。"

#. type: Plain text
#: upstream/_guides/cache.adoc:209
#, fuzzy
msgid "You can try calling the same URL again and again, it will always take six seconds to answer."
msgstr "你可以试着反复拨打同一个网址，它总是需要6秒钟才能接听。"

#. type: Title ==
#: upstream/_guides/cache.adoc:210
#, fuzzy, no-wrap
msgid "Enabling the cache"
msgstr "启用缓存"

#. type: Plain text
#: upstream/_guides/cache.adoc:214
#, fuzzy
msgid "Now that your Quarkus application is up and running, let's tremendously improve its response time by caching the external meteorological service responses.  Update the `WeatherForecastService` class like this:"
msgstr "现在你的Quarkus应用程序已经启动并运行了，让我们通过缓存外部气象服务的响应来极大地改善它的响应时间。像这样更新 `WeatherForecastService` 类。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:224
#, no-wrap
msgid "import io.quarkus.cache.CacheResult;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:237
#, no-wrap
msgid ""
"    @CacheResult(cacheName = \"weather-cache\") <1>\n"
"    public String getDailyForecast(LocalDate date, String city) {\n"
"        try {\n"
"            Thread.sleep(2000L);\n"
"        } catch (InterruptedException e) {\n"
"            Thread.currentThread().interrupt();\n"
"        }\n"
"        return date.getDayOfWeek() + \" will be \" + getDailyResult(date.getDayOfMonth() % 4) + \" in \" + city;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:255
#, fuzzy
msgid "We only added this annotation (and the associated import of course)."
msgstr "我们只添加了这个注释（当然还有相关的导入）。"

#. type: Plain text
#: upstream/_guides/cache.adoc:259
#, fuzzy
msgid "Let's try to call `http://localhost:8080/weather?city=Raleigh` again.  You're still waiting a long time before receiving an answer.  This is normal since the server just restarted and the cache was empty."
msgstr "让我们试着打电话 `<a href=\"http://localhost:8080/weather?city=Raleigh\" class=\"bare\">http://localhost:8080/weather?city=Raleigh</a>` 再打一次。你仍然要等很长时间才能收到答复。这是正常的，因为服务器刚刚重启，缓存是空的。"

#. type: Plain text
#: upstream/_guides/cache.adoc:262
#, fuzzy
msgid "Wait a second! The server restarted by itself after the `WeatherForecastService` update? Yes, this is one of Quarkus amazing features for developers called `live coding`."
msgstr "等一下! `WeatherForecastService` 更新后，服务器自己重新启动了？是的，这是Quarkus为开发者提供的一个惊人的功能，叫做 `live coding` 。"

#. type: Plain text
#: upstream/_guides/cache.adoc:265
#, fuzzy
msgid "Now that the cache was loaded during the previous call, try calling the same URL.  This time, you should get a super fast answer with an `executionTimeInMs` value close to 0."
msgstr "现在，在之前的调用中已经加载了缓存，试着调用同一个URL。这一次，你应该得到一个超级快的答案， `executionTimeInMs` 值接近于0。"

#. type: Plain text
#: upstream/_guides/cache.adoc:268
#, fuzzy
msgid "Let's see what happens if we start from one day in the future using the `http://localhost:8080/weather?city=Raleigh&daysInFuture=1` URL.  You should get an answer two seconds later since two of the requested days were already loaded in the cache."
msgstr "让我们看看如果我们从未来的某一天开始使用 `<a href=\"http://localhost:8080/weather?city=Raleigh&daysInFuture=1\" class=\"bare\">http://localhost:8080/weather?city=Raleigh&daysInFuture=1</a>` 网址。你应该在两秒钟后得到答案，因为请求的两天已经在缓存中加载。"

#. type: Plain text
#: upstream/_guides/cache.adoc:271
#, fuzzy
msgid "You can also try calling the same URL with a different city and see the cache in action again.  The first call will take six seconds and the following ones will be answered immediately."
msgstr "你也可以尝试用不同的城市调用同一个网址，再看看缓存的作用。第一次调用需要6秒钟，而后面的调用将立即得到回应。"

#. type: Plain text
#: upstream/_guides/cache.adoc:273
#, fuzzy
msgid "Congratulations! You just added application data caching to your Quarkus application with a single line of code!"
msgstr "恭喜你！你刚刚用一行代码在你的Quarkus应用程序中添加了应用程序数据缓存。你只用了一行代码就为你的Quarkus应用程序添加了应用数据缓存!"

#. type: Plain text
#: upstream/_guides/cache.adoc:276
#, fuzzy
msgid "Do you want to learn more about the Quarkus application data caching abilities? The following sections will show you everything there is to know about it."
msgstr "你想了解更多关于Quarkus应用程序的数据缓存能力吗？下面的章节将向你展示关于它的所有知识。"

#. type: Title ==
#: upstream/_guides/cache.adoc:278
#, fuzzy, no-wrap
msgid "Caching using annotations"
msgstr "使用注解进行缓存"

#. type: Plain text
#: upstream/_guides/cache.adoc:281
#, fuzzy
msgid "Quarkus offers a set of annotations that can be used in a CDI managed bean to enable caching abilities."
msgstr "Quarkus提供了一套注解，可以在CDI管理的Bean中使用，以实现缓存能力。"

#. type: delimited block =
#: upstream/_guides/cache.adoc:286
#, fuzzy
msgid "Caching annotations are not allowed on private methods.  They will work fine with any other access modifier including package-private (no explicit modifier)."
msgstr "缓存注解在私有方法上是不允许的。它们在任何其他访问修饰符下都能正常工作，包括package-private（无明确修饰符）。"

#. type: Title ===
#: upstream/_guides/cache.adoc:288
#, fuzzy, no-wrap
msgid "@CacheResult"
msgstr "@CacheResult"

#. type: Plain text
#: upstream/_guides/cache.adoc:291
#, fuzzy
msgid "Loads a method result from the cache without executing the method body whenever possible."
msgstr "尽可能地从缓存中加载方法结果，而不执行方法主体。"

#. type: Plain text
#: upstream/_guides/cache.adoc:296
#, fuzzy
msgid "When a method annotated with `@CacheResult` is invoked, Quarkus will compute a cache key and use it to check in the cache whether the method has been already invoked.  See the xref:cache-keys-building-logic[Cache keys building logic] section of this guide to learn how the cache key is computed.  If a value is found in the cache, it is returned and the annotated method is never actually executed.  If no value is found, the annotated method is invoked and the returned value is stored in the cache using the computed key."
msgstr "当一个注有 `@CacheResult` 的方法被调用时，Quarkus将计算一个缓存密钥，并使用它在缓存中检查该方法是否已经被调用。如果该方法有一个或多个参数，如果没有一个参数被注解为 `@CacheKey` ，则从所有的方法参数中进行密钥计算，否则就从所有被注解为 `@CacheKey` 的参数中计算。每个作为密钥一部分的非原始方法参数必须正确实现 `equals()` 和 `hashCode()` ，这样缓存才能如期工作。这个注解也可以用在没有参数的方法上，在这种情况下，会使用一个从缓存名称衍生出来的默认键。如果在缓存中找到了一个值，它将被返回，而被注释的方法将不会被实际执行。如果没有找到值，注释的方法会被调用，返回的值会使用计算的键存储在缓存中。"

#. type: Plain text
#: upstream/_guides/cache.adoc:303
#, fuzzy
msgid "A method annotated with `CacheResult` is protected by a lock on cache miss mechanism.  If several concurrent invocations try to retrieve a cache value from the same missing key, the method will only be invoked once.  The first concurrent invocation will trigger the method invocation while the subsequent concurrent invocations will wait for the end of the method invocation to get the cached result.  The `lockTimeout` parameter can be used to interrupt the lock after a given delay.  The lock timeout is disabled by default, meaning the lock is never interrupted.  See the parameter Javadoc for more details."
msgstr "一个被注解为 `CacheResult` 的方法受到缓存丢失机制的锁定保护。如果几个并发的调用试图从同一个丢失的键中获取缓存值，该方法将只被调用一次。第一个并发调用将触发方法的调用，而随后的并发调用将等待方法调用的结束来获得缓存结果。 `lockTimeout` 参数可以用来在给定的延迟后中断锁定。默认情况下，锁的超时是禁用的，这意味着锁永远不会被中断。更多细节见参数Javadoc。"

#. type: Plain text
#: upstream/_guides/cache.adoc:305
#, fuzzy
msgid "This annotation cannot be used on a method returning `void`."
msgstr "该注释不能用于返回 `void` 的方法。"

#. type: delimited block =
#: upstream/_guides/cache.adoc:310
#, fuzzy
msgid "Quarkus is able to also cache `null` values unlike the underlying Caffeine provider.  See xref:negative-cache[more on this topic below]."
msgstr "与底层的Caffeine提供者不同，Quarkus还能够缓存 `null` 。请看 link:#negative-cache[下面关于这个主题的更多内容] 。"

#. type: Title ===
#: upstream/_guides/cache.adoc:312
#, fuzzy, no-wrap
msgid "@CacheInvalidate"
msgstr "@CacheInvalidate"

#. type: Plain text
#: upstream/_guides/cache.adoc:315
#, fuzzy
msgid "Removes an entry from the cache."
msgstr "从缓存中删除一个条目。"

#. type: Plain text
#: upstream/_guides/cache.adoc:319
#, fuzzy
msgid "When a method annotated with `@CacheInvalidate` is invoked, Quarkus will compute a cache key and use it to try to remove an existing entry from the cache.  See the xref:cache-keys-building-logic[Cache keys building logic] section of this guide to learn how the cache key is computed.  If the key does not identify any cache entry, nothing will happen."
msgstr "当一个注有 `@CacheInvalidate` 的方法被调用时，Quarkus将计算一个缓存密钥，并使用它来尝试从缓存中删除一个现有条目。如果该方法有一个或多个参数，如果没有一个参数被注解为 `@CacheKey` ，则从所有的方法参数中进行密钥计算，否则就从所有被注解为 `@CacheKey` 的参数中进行。这个注释也可以用在没有参数的方法上，在这种情况下，会使用一个从缓存名称衍生出来的默认密钥。如果该键没有识别任何缓存条目，则不会发生任何事情。"

#. type: Title ===
#: upstream/_guides/cache.adoc:320
#, fuzzy, no-wrap
msgid "@CacheInvalidateAll"
msgstr "@CacheInvalidateAll"

#. type: Plain text
#: upstream/_guides/cache.adoc:323
#, fuzzy
msgid "When a method annotated with `@CacheInvalidateAll` is invoked, Quarkus will remove all entries from the cache."
msgstr "当一个用 `@CacheInvalidateAll` 注解的方法被调用时，Quarkus将从缓存中删除所有条目。"

#. type: Title ===
#: upstream/_guides/cache.adoc:324
#, fuzzy, no-wrap
msgid "@CacheKey"
msgstr "@CacheKey"

#. type: Plain text
#: upstream/_guides/cache.adoc:328
#, fuzzy
msgid "When a method argument is annotated with `@CacheKey`, it is identified as a part of the cache key during an invocation of a method annotated with `@CacheResult` or `@CacheInvalidate`."
msgstr "当一个方法参数被注解为 `@CacheKey` ，在调用被注解为 `@CacheResult` 或 `@CacheInvalidate` 的方法时，它被识别为缓存键的一个部分。"

#. type: Plain text
#: upstream/_guides/cache.adoc:330
#, fuzzy
msgid "This annotation is optional and should only be used when some method arguments are NOT part of the cache key."
msgstr "这个注解是可选的，只有当一些方法参数不是缓存键的一部分时才应该使用。"

#. type: Title ===
#: upstream/_guides/cache.adoc:332
#, fuzzy, no-wrap
msgid "Cache keys building logic"
msgstr "复合缓存密钥构建逻辑"

#. type: Plain text
#: upstream/_guides/cache.adoc:335
#, fuzzy
msgid "Cache keys are built by the annotations API using the following logic:"
msgstr "缓存键是由注释API使用以下逻辑建立的。"

#. type: Plain text
#: upstream/_guides/cache.adoc:337
#, fuzzy
msgid "If an `io.quarkus.cache.CacheKeyGenerator` is declared in a `@CacheResult` or a `@CacheInvalidate` annotation, then it is used to generate the cache key. The `@CacheKey` annotations that might be present on some method arguments are ignored."
msgstr "如果在 `@CacheResult` 或 `@CacheInvalidate` 注释中声明了一个 `io.quarkus.cache.CacheKeyGenerator` ，那么它将被用来生成缓存密钥。在一些方法参数上可能存在的 `@CacheKey` 注释被忽略。"

#. type: Plain text
#: upstream/_guides/cache.adoc:338
#, fuzzy
msgid "Otherwise, if the method has no arguments, then the cache key is an instance of `io.quarkus.cache.DefaultCacheKey` built from the cache name."
msgstr "如果该方法没有参数，那么缓存密钥就是一个由缓存名称构建的 `io.quarkus.cache.DefaultCacheKey` 的实例。"

#. type: Plain text
#: upstream/_guides/cache.adoc:339
#, fuzzy
msgid "Otherwise, if the method has exactly one argument, then that argument is the cache key."
msgstr "如果该方法正好有一个参数，那么这个参数就是缓存密钥。"

#. type: Plain text
#: upstream/_guides/cache.adoc:340
#, fuzzy
msgid "Otherwise, if the method has multiple arguments but only one annotated with `@CacheKey`, then that annotated argument is the cache key."
msgstr "如果方法有多个参数，但只有一个被注解为 `@CacheKey` ，那么这个被注解的参数就是缓存密钥。"

#. type: Plain text
#: upstream/_guides/cache.adoc:341
#, fuzzy
msgid "Otherwise, if the method has multiple arguments annotated with `@CacheKey`, then the cache key is an instance of `io.quarkus.cache.CompositeCacheKey` built from these annotated arguments."
msgstr "如果该方法没有参数，那么缓存密钥就是一个由缓存名称构建的 `io.quarkus.cache.DefaultCacheKey` 的实例。"

#. type: Plain text
#: upstream/_guides/cache.adoc:342
#, fuzzy
msgid "Otherwise, if the method has multiple arguments and none of them are annotated with `@CacheKey`, the cache key is an instance of `io.quarkus.cache.CompositeCacheKey` built from all the method arguments."
msgstr "如果该方法没有参数，那么缓存密钥就是一个由缓存名称构建的 `io.quarkus.cache.DefaultCacheKey` 的实例。"

#. type: delimited block =
#: upstream/_guides/cache.adoc:346
#, fuzzy
msgid "Each non-primitive method argument that is part of the key must implement `equals()` and `hashCode()` correctly for the cache to work as expected."
msgstr "作为键的一部分的每个非原始方法参数必须正确实现 `equals()` 和 `hashCode()` ，以便缓存能够如期工作。"

#. type: Plain text
#: upstream/_guides/cache.adoc:349
#, fuzzy
msgid "When a cache key is built from several method arguments, whether they are explicitly identified with `@CacheKey` or not, the building logic depends on the order of these arguments in the method signature. On the other hand, the arguments names are not used at all and do not have any effect on the cache key."
msgstr "当一个缓存键由几个方法参数构建而成时，无论它们是否明确地用 `@CacheKey` ，构建逻辑都取决于这些参数在方法签名中的顺序。另一方面，参数名称根本不被使用，对缓存密钥没有任何影响。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:358
#, no-wrap
msgid ""
"import io.quarkus.cache.CacheInvalidate;\n"
"import io.quarkus.cache.CacheResult;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:361 upstream/_guides/cache.adoc:468
#: upstream/_guides/cache.adoc:828
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class CachedService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:366
#, no-wrap
msgid ""
"    @CacheResult(cacheName = \"foo\")\n"
"    public Object load(String keyElement1, Integer keyElement2) {\n"
"        // Call expensive service here.\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:370
#, no-wrap
msgid ""
"    @CacheInvalidate(cacheName = \"foo\")\n"
"    public void invalidate1(String keyElement2, Integer keyElement1) { <1>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:374
#, no-wrap
msgid ""
"    @CacheInvalidate(cacheName = \"foo\")\n"
"    public void invalidate2(Integer keyElement2, String keyElement1) { <2>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:378
#, no-wrap
msgid ""
"    @CacheInvalidate(cacheName = \"foo\")\n"
"    public void invalidate3(Object notPartOfTheKey, @CacheKey String keyElement1, @CacheKey Integer keyElement2) { <3>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:383
#, no-wrap
msgid ""
"    @CacheInvalidate(cacheName = \"foo\")\n"
"    public void invalidate4(Object notPartOfTheKey, @CacheKey Integer keyElement2, @CacheKey String keyElement1) { <4>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:385
#, fuzzy
msgid "Calling this method WILL invalidate values cached by the `load` method even if the key elements names have been swapped."
msgstr "调用此方法将使 `load` 方法的缓存值无效，即使关键元素的名字被交换了。"

#. type: Plain text
#: upstream/_guides/cache.adoc:386 upstream/_guides/cache.adoc:388
#, fuzzy
msgid "Calling this method WILL NOT invalidate values cached by the `load` method because the key elements order is different."
msgstr "调用这个方法不会因为关键元素的顺序不同而使 `load` 方法所缓存的值失效。"

#. type: Plain text
#: upstream/_guides/cache.adoc:387
#, fuzzy
msgid "Calling this method WILL invalidate values cached by the `load` method because the key elements order is the same."
msgstr "调用此方法将使 `load` 方法缓存的值无效，因为关键元素的顺序是相同的。"

#. type: Title ===
#: upstream/_guides/cache.adoc:389
#, fuzzy, no-wrap
msgid "Generating a cache key with `CacheKeyGenerator`"
msgstr "注入一个带有 `@CacheName` 注解的 `Cache` 。"

#. type: Plain text
#: upstream/_guides/cache.adoc:393
#, fuzzy
msgid "You may want to include more than the arguments of a method into a cache key.  This can be done by implementing the `io.quarkus.cache.CacheKeyGenerator` interface and declaring that implementation in the `keyGenerator` field of a `@CacheResult` or `@CacheInvalidate` annotation."
msgstr "你可能想把一个方法的参数以上的内容纳入缓存键。这可以通过实现 `io.quarkus.cache.CacheKeyGenerator` 接口并在 `@CacheResult` 或 `@CacheInvalidate` 注释的 `keyGenerator` 字段中声明该实现来完成。"

#. type: Plain text
#: upstream/_guides/cache.adoc:397
#, fuzzy
msgid "If a CDI scope is declared on a key generator class and if that class has a default qualifier (no qualifier annotation or `@jakarta.enterprise.inject.Default`), then the key generator will be injected as a CDI bean during the cache key computation.  Otherwise, the key generator will be instantiated using its default constructor.  All CDI scopes supported by Quarkus can be used on a key generator."
msgstr "如果CDI作用域被声明在一个密钥生成器类上，并且如果该类有一个默认的限定符（没有限定符注释或 `@javax.enterprise.inject.Default` ），那么密钥生成器将在缓存密钥计算过程中被注入为CDI Bean。否则，密钥生成器将使用其默认构造函数被实例化。Quarkus支持的所有CDI作用域都可以在密钥生成器上使用。"

#. type: Plain text
#: upstream/_guides/cache.adoc:399
#, fuzzy
msgid "The following key generator will be injected as a CDI bean:"
msgstr "下面的密钥生成器将作为CDI Bean被注入。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:407
#, no-wrap
msgid ""
"import java.lang.reflect.Method;\n"
"import jakarta.enterprise.context.ApplicationScoped;\n"
"import jakarta.inject.Inject;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:410 upstream/_guides/cache.adoc:438
#, no-wrap
msgid ""
"import io.quarkus.cache.CacheKeyGenerator;\n"
"import io.quarkus.cache.CompositeCacheKey;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:413
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class ApplicationScopedKeyGen implements CacheKeyGenerator {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:416
#, no-wrap
msgid ""
"    @Inject\n"
"    AnythingYouNeedHere anythingYouNeedHere; <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:422
#, no-wrap
msgid ""
"    @Override\n"
"    public Object generate(Method method, Object... methodParams) { <2>\n"
"        return new CompositeCacheKey(anythingYouNeedHere.getData(), methodParams[1]); <3>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:424
#, fuzzy
msgid "External data can be included into the cache key by injecting a CDI bean in the key generator."
msgstr "通过在密钥生成器中注入CDI Bean，可以将外部数据纳入缓存密钥。"

#. type: Plain text
#: upstream/_guides/cache.adoc:425
#, fuzzy
msgid "Be careful while using `Method`, some of its methods can be expensive."
msgstr "在使用 `Method` 时要小心，它的一些方法可能很昂贵。"

#. type: Plain text
#: upstream/_guides/cache.adoc:427
#, fuzzy
msgid "Make sure the method has enough arguments before accessing them from their index.  Otherwise, an `IndexOutOfBoundsException` may be thrown during the cache key computation."
msgstr "确保该方法在从其索引访问它们之前有足够的参数。否则，在缓存密钥计算过程中可能会抛出一个 `IndexOutOfBoundsException` 。"

#. type: Plain text
#: upstream/_guides/cache.adoc:429
#, fuzzy
msgid "The following key generator will be instantiated using its default constructor:"
msgstr "下面的密钥生成器将使用其默认构造函数进行实例化。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:435
#, no-wrap
msgid "import java.lang.reflect.Method;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:440
#, no-wrap
msgid "public class NotABeanKeyGen implements CacheKeyGenerator {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:442
#, no-wrap
msgid "    // CDI injections won't work here because it's not a CDI bean.\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:448
#, no-wrap
msgid ""
"    @Override\n"
"    public Object generate(Method method, Object... methodParams) {\n"
"        return new CompositeCacheKey(method.getName(), methodParams[0]); <1>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:450
#, fuzzy
msgid "Including the method name into the cache key is not expensive, unlike other methods from `Method`."
msgstr "将方法名称纳入缓存密钥并不昂贵，与其他方法不同， `Method` 。"

#. type: Plain text
#: upstream/_guides/cache.adoc:452
#, fuzzy
msgid "Both kinds of key generators can be used in a similar way:"
msgstr "这两种密钥生成器的使用方法类似。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:461
#, no-wrap
msgid ""
"import org.acme.cache.ApplicationScopedKeyGen;\n"
"import org.acme.cache.NotABeanKeyGen;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:465
#, no-wrap
msgid ""
"import io.quarkus.cache.CacheKey;\n"
"import io.quarkus.cache.CacheInvalidate;\n"
"import io.quarkus.cache.CacheResult;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:473
#, no-wrap
msgid ""
"    @CacheResult(cacheName = \"foo\", keyGenerator = ApplicationScopedKeyGen.class) <1>\n"
"    public Object load(@CacheKey Object notUsedInKey, String keyElement) { <2>\n"
"        // Call expensive service here.\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:477
#, no-wrap
msgid ""
"    @CacheInvalidate(cacheName = \"foo\", keyGenerator = NotABeanKeyGen.class) <3>\n"
"    public void invalidate(Object keyElement) {\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:483
#, no-wrap
msgid ""
"    @CacheInvalidate(cacheName = \"foo\", keyGenerator = NotABeanKeyGen.class)\n"
"    @CacheInvalidate(cacheName = \"bar\")\n"
"    public void invalidate(Integer param0, @CacheKey BigDecimal param1) { <4>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:485
#, fuzzy
msgid "This key generator is a CDI bean."
msgstr "这个密钥生成器是一个CDI豆。"

#. type: Plain text
#: upstream/_guides/cache.adoc:486
#, fuzzy
msgid "The `@CacheKey` annotation will be ignored because a key generator is declared in the `@CacheResult` annotation."
msgstr " `@CacheKey` 注解将被忽略，因为在 `@CacheResult` 注解中声明了一个密钥发生器。"

#. type: Plain text
#: upstream/_guides/cache.adoc:487
#, fuzzy
msgid "This key generator is not a CDI bean."
msgstr "这个密钥生成器不是CDI豆。"

#. type: Plain text
#: upstream/_guides/cache.adoc:488
#, fuzzy
msgid "The `@CacheKey` annotation will be ignored when the `foo` cache data is invalidated, but `param1` will be the cache key when the `bar` cache data is invalidated."
msgstr "当 `foo` 缓存数据失效时， `@CacheKey` 注释将被忽略，但当 `bar` 缓存数据失效时， `param1` 将成为缓存密钥。"

#. type: Title ==
#: upstream/_guides/cache.adoc:490
#, fuzzy, no-wrap
msgid "Caching using the programmatic API"
msgstr "使用程序化的API进行缓存"

#. type: Plain text
#: upstream/_guides/cache.adoc:494
#, fuzzy
msgid "Quarkus also offers a programmatic API which can be used to store, retrieve or delete values from any cache declared using the annotations API.  All operations from the programmatic API are non-blocking and rely on https://smallrye.io/smallrye-mutiny/[Mutiny] under the hood."
msgstr "Quarkus还提供了一个编程API，可以用来存储、检索或删除使用注释API声明的任何缓存中的值。所有来自程序化API的操作都是非阻塞的，并依赖于 link:https://smallrye.io/smallrye-mutiny/[Mutiny] 的引擎。"

#. type: Plain text
#: upstream/_guides/cache.adoc:497
#, fuzzy
msgid "Before accessing programmatically the cached data, you need to retrieve an `io.quarkus.cache.Cache` instance.  The following sections will show you how to do that."
msgstr "在以编程方式访问缓存的数据之前，你需要检索一个 `io.quarkus.cache.Cache` 实例。下面的章节将告诉你如何做到这一点。"

#. type: Title ===
#: upstream/_guides/cache.adoc:498
#, fuzzy, no-wrap
msgid "Injecting a `Cache` with the `@CacheName` annotation"
msgstr "注入一个带有 `@CacheName` 注解的 `Cache` 。"

#. type: Plain text
#: upstream/_guides/cache.adoc:501
#, fuzzy
msgid "`io.quarkus.cache.CacheName` can be used on a field, a constructor parameter or a method parameter to inject a `Cache`:"
msgstr " `io.quarkus.cache.CacheName` 可以在一个字段、一个构造函数参数或一个方法参数上使用，以注入一个 。 `Cache` "

#. type: delimited block -
#: upstream/_guides/cache.adoc:508
#, no-wrap
msgid ""
"import jakarta.enterprise.context.ApplicationScoped;\n"
"import jakarta.inject.Inject;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:512
#, no-wrap
msgid ""
"import io.quarkus.cache.Cache;\n"
"import io.quarkus.cache.CacheName;\n"
"import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:515
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class CachedExpensiveService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:519
#, no-wrap
msgid ""
"    @Inject //<1>\n"
"    @CacheName(\"my-cache\")\n"
"    Cache cache;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:528
#, no-wrap
msgid ""
"    public Uni<String> getNonBlockingExpensiveValue(Object key) { //<2>\n"
"        return cache.get(key, k -> { //<3>\n"
"            /*\n"
"             * Put an expensive call here.\n"
"             * It will be executed only if the key is not already associated with a value in the cache.\n"
"             */\n"
"        });\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:535
#, no-wrap
msgid ""
"    public String getBlockingExpensiveValue(Object key) {\n"
"        return cache.get(key, k -> {\n"
"            // Put an expensive call here.\n"
"        }).await().indefinitely(); //<4>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:537
#, fuzzy
msgid "This is optional."
msgstr "这是可选的。"

#. type: Plain text
#: upstream/_guides/cache.adoc:538
#, fuzzy
msgid "This method returns the `Uni<String>` type which is non-blocking."
msgstr "该方法返回 `Uni<String>` ，该类型为非阻塞式。"

#. type: Plain text
#: upstream/_guides/cache.adoc:539
#, fuzzy
msgid "The `k` argument contains the cache key value."
msgstr " `k` 参数包含缓存键值。"

#. type: Plain text
#: upstream/_guides/cache.adoc:540
#, fuzzy
msgid "If you don't need the call to be non-blocking, this is how you can retrieve the cache value in a blocking way."
msgstr "如果你不需要非阻塞的调用，这就是你如何以阻塞的方式检索缓存值。"

#. type: Title ===
#: upstream/_guides/cache.adoc:541
#, fuzzy, no-wrap
msgid "Retrieving a `Cache` from the `CacheManager`"
msgstr "检索一个 `Cache` ，从 `CacheManager` "

#. type: Plain text
#: upstream/_guides/cache.adoc:544
#, fuzzy
msgid "Another way to retrieve a `Cache` instance consists in injecting the `io.quarkus.cache.CacheManager` first and then retrieving the desired `Cache` from its name:"
msgstr "另一种检索 `Cache` 实例的方法是先注入 `io.quarkus.cache.CacheManager` ，然后从其名称中检索出所需的 `Cache` 。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:551 upstream/_guides/cache.adoc:683
#: upstream/_guides/cache.adoc:946
#, no-wrap
msgid ""
"import jakarta.inject.Inject;\n"
"import jakarta.inject.Singleton;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:554
#, no-wrap
msgid ""
"import io.quarkus.cache.Cache;\n"
"import io.quarkus.cache.CacheManager;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:556
#, no-wrap
msgid "import java.util.Optional;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:559 upstream/_guides/cache.adoc:951
#, no-wrap
msgid ""
"@Singleton\n"
"public class CacheClearer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:561 upstream/_guides/cache.adoc:695
#: upstream/_guides/cache.adoc:953
#, no-wrap
msgid "    private final CacheManager cacheManager;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:565 upstream/_guides/cache.adoc:957
#, no-wrap
msgid ""
"    public CacheClearer(CacheManager cacheManager) {\n"
"        this.cacheManager = cacheManager;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:573
#, no-wrap
msgid ""
"    public void clearCache(String cacheName) {\n"
"        Optional<Cache> cache = cacheManager.getCache(cacheName);\n"
"        if (cache.isPresent()) {\n"
"            cache.get().invalidateAll().await().indefinitely();\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/cache.adoc:575
#, fuzzy, no-wrap
msgid "Building a programmatic cache key"
msgstr "建立一个程序化的缓存密钥"

#. type: Plain text
#: upstream/_guides/cache.adoc:579
#, fuzzy
msgid "Before building a programmatic cache key, you need to know how cache keys are built by the annotations API when an annotated method is invoked.  This is explained in the xref:cache-keys-building-logic[Cache keys building logic] section of this guide."
msgstr "在建立一个程序化的缓存密钥之前，你需要知道当一个被注释的方法被调用时，缓存密钥是如何被注释API建立的。"

#. type: Plain text
#: upstream/_guides/cache.adoc:581
#, fuzzy
msgid "Now, if you want to retrieve or delete, using the programmatic API, a cache value that was stored using the annotations API, you just need to make sure the same key is used with both APIs."
msgstr "现在，如果你想用程序化API检索或删除一个用注释API存储的缓存值，你只需要确保两个API使用的是同一个密钥。"

#. type: Title ===
#: upstream/_guides/cache.adoc:582
#, fuzzy, no-wrap
msgid "Retrieving all keys from a `CaffeineCache`"
msgstr "检索所有的键从一个 `CaffeineCache` "

#. type: Plain text
#: upstream/_guides/cache.adoc:586
#, fuzzy
msgid "The cache keys from a specific `CaffeineCache` can be retrieved as an unmodifiable `Set` as shown below.  If the cache entries are modified while an iteration over the set is in progress, the set will remain unchanged."
msgstr "从一个特定的 `CaffeineCache` ，缓存键可以作为一个不可修改的 `Set` ，如下图所示。如果在对该集合的迭代过程中，缓存条目被修改，该集合将保持不变。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:596 upstream/_guides/cache.adoc:625
#: upstream/_guides/cache.adoc:657
#, no-wrap
msgid ""
"import io.quarkus.cache.Cache;\n"
"import io.quarkus.cache.CacheName;\n"
"import io.quarkus.cache.CaffeineCache;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:598
#, no-wrap
msgid "import java.util.Set;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:601 upstream/_guides/cache.adoc:662
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class CacheKeysService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:604 upstream/_guides/cache.adoc:633
#: upstream/_guides/cache.adoc:665
#, no-wrap
msgid ""
"    @CacheName(\"my-cache\")\n"
"    Cache cache;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:609
#, no-wrap
msgid ""
"    public Set<Object> getAllCacheKeys() {\n"
"        return cache.as(CaffeineCache.class).keySet();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/cache.adoc:611
#, fuzzy, no-wrap
msgid "Populating a `CaffeineCache`"
msgstr "检索所有的键从一个 `CaffeineCache` "

#. type: Plain text
#: upstream/_guides/cache.adoc:615
#, fuzzy
msgid "You can populate a `CaffeineCache` using the `CaffeineCache#put(Object, CompletableFuture)` method.  This method associates the `CompletableFuture` with the given key in the cache. If the cache previously contained a value associated with the key, the old value is replaced by this `CompletableFuture`. If the asynchronous computation fails, the entry will be automatically removed."
msgstr "你可以使用 `CaffeineCache#put(Object, CompletableFuture)` 方法来填充一个 `CaffeineCache` 。这个方法将 `CompletableFuture` 与缓存中给定的键相关联。如果缓存中以前包含一个与该键相关的值，旧的值将被这个 `CompletableFuture` 。如果异步计算失败，该条目将被自动删除。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:627 upstream/_guides/cache.adoc:659
#, no-wrap
msgid "import java.util.concurrent.CompletableFuture;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:630
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class CacheService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:639
#, no-wrap
msgid ""
"    @PostConstruct\n"
"    public void initialize() {\n"
"        cache.as(CaffeineCache.class).put(\"foo\", CompletableFuture.completedFuture(\"bar\"));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/cache.adoc:641
#, fuzzy, no-wrap
msgid "Retrieving a value if a key is present from a `CaffeineCache`"
msgstr "检索所有的键从一个 `CaffeineCache` "

#. type: Plain text
#: upstream/_guides/cache.adoc:647
#, fuzzy
msgid "The cache value from a specific `CaffeineCache` can be retrieved if present as shown below.  If the given key is contained in the cache, the method will return the `CompletableFuture` the specified key is mapped to.  That `CompletableFuture` may be computing or may already be completed.  Otherwise, the method will return `null`."
msgstr "如果存在的话，可以从一个特定的 `CaffeineCache` ，检索出缓存值，如下图所示。如果给定的键包含在缓存中，该方法将返回指定键所映射的 `CompletableFuture` 。该 `CompletableFuture` 可能正在计算，也可能已经完成。否则，该方法将返回 `null` 。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:670
#, no-wrap
msgid ""
"    public CompletableFuture<Object> getIfPresent(Object key) {\n"
"        return cache.as(CaffeineCache.class).getIfPresent(key);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/cache.adoc:672
#, fuzzy, no-wrap
msgid "Changing the expiration policy or the maximum size of a `CaffeineCache` in real time"
msgstr "实时改变过期政策或 `CaffeineCache` 的最大尺寸"

#. type: Plain text
#: upstream/_guides/cache.adoc:676
#, fuzzy
msgid "The expiration policy of a `CaffeineCache` can be changed while a Quarkus app is running if that policy was initially specified in the Quarkus configuration.  Similarly, the maximum size of a `CaffeineCache` can be changed in real time if the cache was built with an initial maximum size defined in the configuration."
msgstr " `CaffeineCache` 的过期策略可以在Quarkus应用程序运行时被改变，如果该策略最初在Quarkus配置中被指定。同样，如果在配置中定义了缓存的初始最大尺寸， `CaffeineCache` 的最大尺寸也可以实时改变。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:687
#, no-wrap
msgid ""
"import io.quarkus.cache.Cache;\n"
"import io.quarkus.cache.CacheManager;\n"
"import io.quarkus.cache.CaffeineCache;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:690
#, no-wrap
msgid ""
"import java.time.Duration;\n"
"import java.util.Optional;import javax.inject.Singleton;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:693
#, no-wrap
msgid ""
"@Singleton\n"
"public class CacheConfigManager {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:699
#, no-wrap
msgid ""
"    public CacheConfigManager(CacheManager cacheManager) {\n"
"        this.cacheManager = cacheManager;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:706
#, no-wrap
msgid ""
"    public void setExpireAfterAccess(String cacheName, Duration duration) {\n"
"        Optional<Cache> cache = cacheManager.getCache(cacheName);\n"
"        if (cache.isPresent()) {\n"
"            cache.get().as(CaffeineCache.class).setExpireAfterAccess(duration); <1>\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:713
#, no-wrap
msgid ""
"    public void setExpireAfterWrite(String cacheName, Duration duration) {\n"
"        Optional<Cache> cache = cacheManager.getCache(cacheName);\n"
"        if (cache.isPresent()) {\n"
"            cache.get().as(CaffeineCache.class).setExpireAfterWrite(duration); <2>\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:721
#, no-wrap
msgid ""
"    public void setMaximumSize(String cacheName, long maximumSize) {\n"
"        Optional<Cache> cache = cacheManager.getCache(cacheName);\n"
"        if (cache.isPresent()) {\n"
"            cache.get().as(CaffeineCache.class).setMaximumSize(maximumSize); <3>\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:723
msgid "This line will only work if the cache was constructed with an `expire-after-access` configuration value. Otherwise, an `IllegalStateException` will be thrown."
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:724
msgid "This line will only work if the cache was constructed with an `expire-after-write` configuration value. Otherwise, an `IllegalStateException` will be thrown."
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:725
msgid "This line will only work if the cache was constructed with a `maximum-size` configuration value. Otherwise, an `IllegalStateException` will be thrown."
msgstr ""

#. type: delimited block =
#: upstream/_guides/cache.adoc:729
msgid "The `setExpireAfterAccess`, `setExpireAfterWrite` and `setMaximumSize` methods from `CaffeineCache` must never be invoked from within an atomic scope of a cache operation."
msgstr ""

#. type: Title ==
#: upstream/_guides/cache.adoc:731
#, fuzzy, no-wrap
msgid "Configuring the underlying caching provider"
msgstr "配置底层缓存提供者"

#. type: Plain text
#: upstream/_guides/cache.adoc:735
#, fuzzy
msgid "This extension uses https://github.com/ben-manes/caffeine[Caffeine] as its underlying caching provider.  Caffeine is a high performance, near optimal caching library."
msgstr "该扩展使用 link:https://github.com/ben-manes/caffeine[Caffeine] 作为其底层缓存提供者。Caffeine是一个高性能的、接近最佳的缓存库。"

#. type: Title ===
#: upstream/_guides/cache.adoc:736
#, fuzzy, no-wrap
msgid "Caffeine configuration properties"
msgstr "咖啡因配置特性"

#. type: Plain text
#: upstream/_guides/cache.adoc:740
#, fuzzy
msgid "Each of the Caffeine caches backing up the Quarkus application data caching extension can be configured using the following properties in the `application.properties` file. By default, caches do not perform any type of eviction if not configured."
msgstr "每个支持Quarkus应用程序数据缓存扩展的Caffeine缓存都可以使用 `application.properties` 文件中的以下属性进行配置。默认情况下，如果没有配置，缓存不执行任何类型的驱逐。"

#. type: delimited block =
#: upstream/_guides/cache.adoc:744
#, fuzzy
msgid "You need to replace `cache-name` in all the following properties with the real name of the cache you want to configure."
msgstr "你需要在以下所有属性中用你想配置的缓存的真实名称替换 `cache-name` 。"

#. type: Plain text
#: upstream/_guides/cache.adoc:749
#, fuzzy
msgid "Here's what your cache configuration could look like:"
msgstr "下面是你的缓存配置可能是这样的。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:756
#, no-wrap
msgid ""
"quarkus.cache.caffeine.\"foo\".initial-capacity=10 <1>\n"
"quarkus.cache.caffeine.\"foo\".maximum-size=20\n"
"quarkus.cache.caffeine.\"foo\".expire-after-write=60S\n"
"quarkus.cache.caffeine.\"bar\".maximum-size=1000 <2>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:758
#, fuzzy
msgid "The `foo` cache is being configured."
msgstr " `foo` 缓存正在配置中。"

#. type: Plain text
#: upstream/_guides/cache.adoc:759
#, fuzzy
msgid "The `bar` cache is being configured."
msgstr " `bar` 缓存正在配置中。"

#. type: Title ==
#: upstream/_guides/cache.adoc:760
#, fuzzy, no-wrap
msgid "Enabling Micrometer metrics"
msgstr "启用测微仪指标"

#. type: Plain text
#: upstream/_guides/cache.adoc:763
#, fuzzy
msgid "Each cache declared using the xref:annotations-api[annotations caching API] can be monitored using Micrometer metrics."
msgstr "使用 link:#annotations-api[注释缓存API] 声明的每个缓存都可以使用Micrometer指标进行监控。"

#. type: delimited block =
#: upstream/_guides/cache.adoc:768
#, fuzzy
msgid "The cache metrics collection will only work if your application depends on a `quarkus-micrometer-registry-*` extension.  See the xref:micrometer.adoc[Micrometer metrics guide] to learn how to use Micrometer in Quarkus."
msgstr "只有当你的应用程序依赖于 `quarkus-micrometer-registry-*` 扩展时，缓存指标收集才能发挥作用。参见 link:micrometer.html[Micrometer指标指南] ，了解如何在Quarkus中使用Micrometer。"

#. type: Plain text
#: upstream/_guides/cache.adoc:772
#, fuzzy
msgid "The cache metrics collection is disabled by default.  It can be enabled from the `application.properties` file:"
msgstr "缓存指标收集在默认情况下是禁用的。它可以从 `application.properties` 文件中启用。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:776
#, no-wrap
msgid "quarkus.cache.caffeine.\"foo\".metrics-enabled=true\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/cache.adoc:781
#, fuzzy
msgid "Like all instrumentation methods, collecting metrics comes with a small overhead that can impact the application performances."
msgstr "像所有的工具化方法一样，收集指标也会有少量的开销，会影响应用程序的性能。"

#. type: Plain text
#: upstream/_guides/cache.adoc:784
#, fuzzy
msgid "The collected metrics contain cache statistics such as:"
msgstr "收集到的指标包含缓存统计数据，如：。"

#. type: Plain text
#: upstream/_guides/cache.adoc:786
#, fuzzy
msgid "the approximate current number of entries in the cache"
msgstr "缓存中的条目的大致当前数量"

#. type: Plain text
#: upstream/_guides/cache.adoc:787
#, fuzzy
msgid "the number of entries that were added to the cache"
msgstr "被添加到缓存中的条目数"

#. type: Plain text
#: upstream/_guides/cache.adoc:788
#, fuzzy
msgid "the number of times a cache lookup has been performed, including information about hits and misses"
msgstr "缓存查询的次数，包括点击率和失误率的信息。"

#. type: Plain text
#: upstream/_guides/cache.adoc:789
#, fuzzy
msgid "the number of evictions and the weight of the evicted entries"
msgstr "驱逐的数量和被驱逐条目的权重"

#. type: Plain text
#: upstream/_guides/cache.adoc:791
#, fuzzy
msgid "Here is an example of cache metrics available for an application that depends on the `quarkus-micrometer-registry-prometheus` extension:"
msgstr "下面是一个依赖 `quarkus-micrometer-registry-prometheus` 扩展的应用程序可用的缓存指标的例子。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:810
#, no-wrap
msgid ""
"# HELP cache_size The number of entries in this cache. This may be an approximation, depending on the type of cache.\n"
"# TYPE cache_size gauge\n"
"cache_size{cache=\"foo\",} 8.0\n"
"# HELP cache_puts_total The number of entries added to the cache\n"
"# TYPE cache_puts_total counter\n"
"cache_puts_total{cache=\"foo\",} 12.0\n"
"# HELP cache_gets_total The number of times cache lookup methods have returned a cached value.\n"
"# TYPE cache_gets_total counter\n"
"cache_gets_total{cache=\"foo\",result=\"hit\",} 53.0\n"
"cache_gets_total{cache=\"foo\",result=\"miss\",} 12.0\n"
"# HELP cache_evictions_total cache evictions\n"
"# TYPE cache_evictions_total counter\n"
"cache_evictions_total{cache=\"foo\",} 4.0\n"
"# HELP cache_eviction_weight_total The sum of weights of evicted entries. This total does not include manual invalidations.\n"
"# TYPE cache_eviction_weight_total counter\n"
"cache_eviction_weight_total{cache=\"foo\",} 540.0\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/cache.adoc:812
#, fuzzy, no-wrap
msgid "Annotated beans examples"
msgstr "附有注释的豆子例子"

#. type: Title ===
#: upstream/_guides/cache.adoc:814
#, fuzzy, no-wrap
msgid "Implicit simple cache key"
msgstr "隐式简单缓存密钥"

#. type: delimited block -
#: upstream/_guides/cache.adoc:825 upstream/_guides/cache.adoc:888
#: upstream/_guides/cache.adoc:919
#, no-wrap
msgid ""
"import io.quarkus.cache.CacheInvalidate;\n"
"import io.quarkus.cache.CacheInvalidateAll;\n"
"import io.quarkus.cache.CacheResult;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:833
#, no-wrap
msgid ""
"    @CacheResult(cacheName = \"foo\")\n"
"    public Object load(Object key) { <1>\n"
"        // Call expensive service here.\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:837
#, no-wrap
msgid ""
"    @CacheInvalidate(cacheName = \"foo\")\n"
"    public void invalidate(Object key) { <1>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:842 upstream/_guides/cache.adoc:874
#: upstream/_guides/cache.adoc:905
#, no-wrap
msgid ""
"    @CacheInvalidateAll(cacheName = \"foo\")\n"
"    public void invalidateAll() {\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:844
#, fuzzy
msgid "The cache key is implicit since there's no `@CacheKey` annotation."
msgstr "因为没有 `@CacheKey` 注释，所以缓存键是隐含的。"

#. type: Title ===
#: upstream/_guides/cache.adoc:845
#, fuzzy, no-wrap
msgid "Explicit composite cache key"
msgstr "明确的复合缓存密钥"

#. type: delimited block -
#: upstream/_guides/cache.adoc:852 upstream/_guides/cache.adoc:884
#, no-wrap
msgid "import jakarta.enterprise.context.Dependent;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:857
#, no-wrap
msgid ""
"import io.quarkus.cache.CacheInvalidate;\n"
"import io.quarkus.cache.CacheInvalidateAll;\n"
"import io.quarkus.cache.CacheKey;\n"
"import io.quarkus.cache.CacheResult;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:860 upstream/_guides/cache.adoc:891
#, no-wrap
msgid ""
"@Dependent\n"
"public class CachedService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:865
#, no-wrap
msgid ""
"    @CacheResult(cacheName = \"foo\")\n"
"    public String load(@CacheKey Object keyElement1, @CacheKey Object keyElement2, Object notPartOfTheKey) { <1>\n"
"        // Call expensive service here.\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:869
#, no-wrap
msgid ""
"    @CacheInvalidate(cacheName = \"foo\")\n"
"    public void invalidate(@CacheKey Object keyElement1, @CacheKey Object keyElement2, Object notPartOfTheKey) { <1>\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:876
#, fuzzy
msgid "The cache key is explicitly composed of two elements. The method signature also contains a third argument which is not part of the key."
msgstr "缓存密钥明确地由两个元素组成。方法签名还包含了第三个参数，它不是密钥的一部分。"

#. type: Title ===
#: upstream/_guides/cache.adoc:877
#, fuzzy, no-wrap
msgid "Default cache key"
msgstr "默认缓存密钥"

#. type: delimited block -
#: upstream/_guides/cache.adoc:896
#, no-wrap
msgid ""
"    @CacheResult(cacheName = \"foo\")\n"
"    public String load() { <1>\n"
"        // Call expensive service here.\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:900
#, no-wrap
msgid ""
"    @CacheInvalidate(cacheName = \"foo\")\n"
"    public void invalidate() { <1>\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:907
#, fuzzy
msgid "A unique default cache key derived from the cache name is used because the method has no arguments."
msgstr "因为该方法没有参数，所以使用了一个从缓存名称派生的唯一默认缓存密钥。"

#. type: Title ===
#: upstream/_guides/cache.adoc:908
#, fuzzy, no-wrap
msgid "Multiple annotations on a single method"
msgstr "一个方法上的多个注释"

#. type: delimited block -
#: upstream/_guides/cache.adoc:915
#, no-wrap
msgid "import jakarta.inject.Singleton;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:922
#, no-wrap
msgid ""
"@Singleton\n"
"public class CachedService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:928
#, no-wrap
msgid ""
"    @CacheInvalidate(cacheName = \"foo\")\n"
"    @CacheResult(cacheName = \"foo\")\n"
"    public String forceCacheEntryRefresh(Object key) { <1>\n"
"        // Call expensive service here.\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:934
#, no-wrap
msgid ""
"    @CacheInvalidateAll(cacheName = \"foo\")\n"
"    @CacheInvalidateAll(cacheName = \"bar\")\n"
"    public void multipleInvalidateAll(Object key) { <2>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:936
#, fuzzy
msgid "This method can be used to force a refresh of the cache entry corresponding to the given key."
msgstr "这个方法可以用来强制刷新与给定键对应的缓存条目。"

#. type: Plain text
#: upstream/_guides/cache.adoc:937
#, fuzzy
msgid "This method will invalidate all entries from the `foo` and `bar` caches with a single call."
msgstr "这个方法将通过一次调用使 `foo` 和 `bar` 缓存中的所有条目失效。"

#. type: Title ===
#: upstream/_guides/cache.adoc:938
#, fuzzy, no-wrap
msgid "Clear all application caches"
msgstr "清除所有的应用程序缓存"

#. type: delimited block -
#: upstream/_guides/cache.adoc:948
#, no-wrap
msgid "import io.quarkus.cache.CacheManager;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:964
#, no-wrap
msgid ""
"    public void clearAllCaches() {\n"
"        for (String cacheName : cacheManager.getCacheNames()) {\n"
"            cacheManager.getCache(cacheName).get().invalidateAll().await().indefinitely();\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/cache.adoc:967
#, fuzzy, no-wrap
msgid "Negative caching and nulls"
msgstr "负数缓存和空数"

#. type: Plain text
#: upstream/_guides/cache.adoc:972
#, fuzzy
msgid "Sometimes one wants to cache the result of an (expensive) remote call.  If the remote call fails, one may not want to cache the result or exception, but rather re-try the remote call on the next invocation."
msgstr "有时我们想缓存一个（昂贵的）远程调用的结果。如果远程调用失败，人们可能不想缓存结果或异常，而是在下一次调用时重试远程调用。"

#. type: Plain text
#: upstream/_guides/cache.adoc:975
#, fuzzy
msgid "A simple approach could be to catch the exception and return `null`, so that the caller can act accordingly:"
msgstr "一个简单的方法是捕获异常并返回 `null` ，这样调用者就可以采取相应的行动。"

#. type: Block title
#: upstream/_guides/cache.adoc:976
#, fuzzy, no-wrap
msgid "Sample code"
msgstr "样品代码"

#. type: delimited block -
#: upstream/_guides/cache.adoc:980
#, no-wrap
msgid "    public void caller(int val) {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:988
#, no-wrap
msgid ""
"        Integer result = callRemote(val); //<1>\n"
"        if (result != null) {\n"
"            System.out.println(\"Result is \" + result);\n"
"        else {\n"
"            System.out.println(\"Got an exception\");\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:991
#, no-wrap
msgid ""
"    @CacheResult(cacheName = \"foo\")\n"
"    public Integer callRemote(int val)  {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:999
#, no-wrap
msgid ""
"        try {\n"
"            Integer val = remoteWebServer.getResult(val); //<2>\n"
"            return val;\n"
"        } catch (Exception e) {\n"
"            return null; // <3>\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:1001 upstream/_guides/cache.adoc:1034
#, fuzzy
msgid "Call the method to call the remote"
msgstr "调用该方法来调用远程"

#. type: Plain text
#: upstream/_guides/cache.adoc:1002
#, fuzzy
msgid "Do the remote call and return its result"
msgstr "进行远程调用并返回其结果"

#. type: Plain text
#: upstream/_guides/cache.adoc:1003
#, fuzzy
msgid "Return in case of exception"
msgstr "异常情况下的返回"

#. type: Plain text
#: upstream/_guides/cache.adoc:1008
#, fuzzy
msgid "This approach has an unfortunate side effect: as we said before, Quarkus can also cache `null` values. Which means that the next call to `callRemote()` with the same parameter value will be answered out of the cache, returning `null` and no remote call will be done.  This may be desired in some scenarios, but usually one wants to retry the remote call until it returns a result."
msgstr "这种方法有一个不幸的副作用：正如我们之前所说，Quarkus也可以缓存 `null` 。这意味着下一次用相同的参数值调用 `callRemote()` ，将从缓存中得到响应，返回 `null` ，而不会进行远程调用。这在某些情况下可能是需要的，但通常人们希望重试远程调用，直到它返回一个结果。"

#. type: Title ===
#: upstream/_guides/cache.adoc:1009
#, fuzzy, no-wrap
msgid "Let exceptions bubble up"
msgstr "让例外情况浮现出来"

#. type: Plain text
#: upstream/_guides/cache.adoc:1013
#, fuzzy
msgid "To prevent the cache from caching (marker) results from a remote call, we need to let the exception bubble out of the called method and catch it at the caller side:"
msgstr "为了防止缓存来自远程调用的（标记）结果，我们需要让异常从被调用的方法中冒出来，并在调用者一方捕获它。"

#. type: Block title
#: upstream/_guides/cache.adoc:1014
#, fuzzy, no-wrap
msgid "With Exception bubbling up"
msgstr "随着例外情况的涌现"

#. type: delimited block -
#: upstream/_guides/cache.adoc:1024
#, no-wrap
msgid ""
"   public void caller(int val) {\n"
"       try {\n"
"           Integer result = callRemote(val);  //<1>\n"
"           System.out.println(\"Result is \" + result);\n"
"       } catch (Exception e) {\n"
"           System.out.println(\"Got an exception\");\n"
"   }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:1027
#, no-wrap
msgid ""
"   @CacheResult(cacheName = \"foo\")\n"
"   public Integer callRemote(int val) throws Exception { // <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:1030
#, no-wrap
msgid ""
"      Integer val = remoteWebServer.getResult(val);  //<3>\n"
"      return val;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:1032
#, no-wrap
msgid "   }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:1035
#, fuzzy
msgid "Exceptions may bubble up"
msgstr "例外情况可能会涌现"

#. type: Plain text
#: upstream/_guides/cache.adoc:1036
#, fuzzy
msgid "This can throw all kinds of remote exceptions"
msgstr "这可能会抛出各种各样的远程异常"

#. type: Plain text
#: upstream/_guides/cache.adoc:1041
#, fuzzy
msgid "When the call to the remote throws an exception, the cache does not store the result, so that a subsequent call to `callRemote()` with the same parameter value will not be answered out of the cache.  It will instead result in another attempt to call the remote."
msgstr "当对远程的调用抛出一个异常时，缓存并不存储结果，所以随后对 `callRemote()` ，参数值相同的调用不会从缓存中得到回应。相反，它将导致再次尝试调用远程。"

#. type: Title ==
#: upstream/_guides/cache.adoc:1042
#, fuzzy, no-wrap
msgid "Going native"
msgstr "走向本土化"

#. type: Plain text
#: upstream/_guides/cache.adoc:1045
#, fuzzy
msgid "The Cache extension supports building native executables."
msgstr "缓存扩展支持构建本地可执行文件。"

#. type: Plain text
#: upstream/_guides/cache.adoc:1049
#, fuzzy
msgid "However, to optimize runtime memory, Caffeine embarks many cache implementation classes that are selected depending on the cache configuration.  We are not registering all of them for reflection (and the ones not registered are not included into the native executables) as registering all of them would be very costly."
msgstr "然而，为了优化运行速度，Caffeine嵌入了许多缓存实现类，这些类是根据缓存配置来选择的。我们没有注册所有的类来进行反射（没有注册的类也不包括在本地可执行文件中），因为注册所有的类会非常昂贵。"

#. type: Plain text
#: upstream/_guides/cache.adoc:1051
#, fuzzy
msgid "We are registering the most common implementations but, depending on your cache configuration, you might encounter errors like:"
msgstr "我们正在注册最常见的实现方式，但是，根据你的缓存配置，你可能会遇到这样的错误。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:1062
#, no-wrap
msgid ""
"2021-12-08 02:32:02,108 ERROR [io.qua.run.Application] (main) Failed to start application (with profile prod): java.lang.ClassNotFoundException: com.github.benmanes.caffeine.cache.PSAMS <1>\n"
"        at java.lang.Class.forName(DynamicHub.java:1433)\n"
"        at java.lang.Class.forName(DynamicHub.java:1408)\n"
"        at com.github.benmanes.caffeine.cache.NodeFactory.newFactory(NodeFactory.java:111)\n"
"        at com.github.benmanes.caffeine.cache.BoundedLocalCache.<init>(BoundedLocalCache.java:240)\n"
"        at com.github.benmanes.caffeine.cache.SS.<init>(SS.java:31)\n"
"        at com.github.benmanes.caffeine.cache.SSMS.<init>(SSMS.java:64)\n"
"        at com.github.benmanes.caffeine.cache.SSMSA.<init>(SSMSA.java:43)\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:1064
#, fuzzy
msgid "`PSAMS` is one of the many cache implementation classes of Caffeine so this part may vary."
msgstr " `PSAMS` 是Caffeine众多缓存实现类中的一个，所以这部分可能会有所不同。"

#. type: Plain text
#: upstream/_guides/cache.adoc:1067
#, fuzzy
msgid "When you encounter this error, you can easily fix it by adding the following annotation to any of your application classes (or you can create a new class such as `Reflections` just to host this annotation if you prefer):"
msgstr "当你遇到这个错误时，你可以通过在你的任何应用类中添加以下注解来轻松解决它（如果你愿意，也可以创建一个新的类，如 `Reflections` ，只是为了承载这个注解）。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:1071
#, no-wrap
msgid "@RegisterForReflection(classNames = { \"com.github.benmanes.caffeine.cache.PSAMS\" }) <1>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:1073
#, fuzzy
msgid "It is an array, so you can register several cache implementations in one go if your configuration requires several of them."
msgstr "它是一个数组，所以如果你的配置需要几个缓存实现，你可以一次性注册几个缓存。"

#. type: Plain text
#: upstream/_guides/cache.adoc:1074
msgid "This annotation will register the cache implementation classes for reflection and this will include the classes into the native executable."
msgstr ""

#, fuzzy
#~ msgid "In all other cases, the cache key is an instance of `io.quarkus.cache.CompositeCacheKey` built from multiple method arguments (annotated with `@CacheKey` or not)."
#~ msgstr "在所有其他情况下，缓存键是一个由多个方法参数（无论是否注有 `@CacheKey` ）构建的 `io.quarkus.cache.CompositeCacheKey` 的实例。"

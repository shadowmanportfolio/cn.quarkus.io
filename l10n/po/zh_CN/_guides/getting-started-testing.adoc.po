# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-10-25 13:16+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title =
#: upstream/_guides/getting-started-testing.adoc:7
#, fuzzy, no-wrap
msgid "Testing Your Application"
msgstr "测试你的应用程序"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:19
#, fuzzy
msgid "Learn how to test your Quarkus Application.  This guide covers:"
msgstr "了解如何测试你的Quarkus应用程序。本指南包括。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:21
#, fuzzy
msgid "Testing in JVM mode"
msgstr "在JVM模式下测试"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:22
#, fuzzy
msgid "Testing in native mode"
msgstr "在本地模式下测试"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:23
#, fuzzy
msgid "Injection of resources into tests"
msgstr "将资源注入测试中"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:24
#, fuzzy, no-wrap
msgid "Prerequisites"
msgstr "先决条件"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:28
#, fuzzy
msgid "The completed greeter application from the xref:getting-started.adoc[Getting Started Guide]"
msgstr "link:getting-started.html[入门指南》] 中填写好的迎宾员申请表"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:29
#, fuzzy, no-wrap
msgid "Architecture"
msgstr "建筑学"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:33
#, fuzzy
msgid "In this guide, we expand on the initial test that was created as part of the Getting Started Guide.  We cover injection into tests and also how to test native executables."
msgstr "在本指南中，我们对作为入门指南的一部分而创建的初始测试进行扩展。我们涵盖了注入测试以及如何测试本地可执行文件。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:35
#, fuzzy
msgid "Quarkus supports Continuous testing, but this is covered by the xref:continuous-testing.adoc[Continuous Testing Guide]."
msgstr "Quarkus支持持续测试，但这是由 link:continuous-testing.html[持续测试指南] 涵盖的。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:36
#, fuzzy, no-wrap
msgid "Solution"
msgstr "解决方案"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:40
#, fuzzy
msgid "We recommend that you follow the instructions in the next sections and create the application step by step.  However, you can go right to the completed example."
msgstr "我们建议你按照下面几节的说明，一步一步地创建应用程序。然而，你可以直接进入已完成的例子。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:42
#, fuzzy
msgid "Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive]."
msgstr "克隆 Git 仓库。 `git clone {quickstarts-clone-url}` ，或者下载一个{quickstarts-archive-url}[存档]。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:44
#, fuzzy
msgid "The solution is located in the `getting-started-testing` link:{quickstarts-tree-url}/getting-started-testing[directory]."
msgstr "该解决方案位于 `getting-started-testing` {quickstarts-treeurl}/getting-started-testing[目录]中。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:46
#, fuzzy
msgid "This guide assumes you already have the completed application from the `getting-started` directory."
msgstr "本指南假设你已经有了来自 `getting-started` 目录的完整申请。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:47
#, fuzzy, no-wrap
msgid "Recap of HTTP based Testing in JVM mode"
msgstr "在JVM模式下基于HTTP的测试的回顾"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:51
#, fuzzy
msgid "If you have started from the Getting Started example you should already have a completed test, including the correct tooling setup."
msgstr "如果你从入门的例子开始，你应该已经有一个完成的测试，包括正确的工具设置。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:53
#, fuzzy
msgid "In your build file you should see 2 test dependencies:"
msgstr "在你的构建文件中，你应该看到2个测试依赖项。"

#. type: Block title
#: upstream/_guides/getting-started-testing.adoc:54
#, fuzzy, no-wrap
msgid "Maven"
msgstr "雯雯"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:68
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-junit5</artifactId>\n"
"    <scope>test</scope>\n"
"</dependency>\n"
"<dependency>\n"
"    <groupId>io.rest-assured</groupId>\n"
"    <artifactId>rest-assured</artifactId>\n"
"    <scope>test</scope>\n"
"</dependency>\n"
msgstr ""

#. type: Block title
#: upstream/_guides/getting-started-testing.adoc:71
#, fuzzy, no-wrap
msgid "Gradle"
msgstr "渐进式"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:79
#, no-wrap
msgid ""
"dependencies {\n"
"    testImplementation(\"io.quarkus:quarkus-junit5\")\n"
"    testImplementation(\"io.rest-assured:rest-assured\")\n"
"}\n"
msgstr ""

#. type: delimited block *
#: upstream/_guides/getting-started-testing.adoc:85
#, fuzzy
msgid "`quarkus-junit5` is required for testing, as it provides the `@QuarkusTest` annotation that controls the testing framework.  `rest-assured` is not required but is a convenient way to test HTTP endpoints, we also provide integration that automatically sets the correct URL so no configuration is required."
msgstr " `quarkus-junit5` 是测试所必需的，因为它提供了控制测试框架的 注释。 不是必需的，但它是测试HTTP端点的一种方便方式，我们还提供了自动设置正确URL的集成，因此不需要配置。 `@QuarkusTest` `rest-assured` "

#. type: delimited block *
#: upstream/_guides/getting-started-testing.adoc:88
#, fuzzy
msgid "Because we are using JUnit 5, the version of the https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin] must be set, as the default version does not support Junit 5:"
msgstr "因为我们使用的是JUnit 5，所以必须设置 link:https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven插件] 的版本，因为默认版本不支持Junit 5。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:101
#, no-wrap
msgid ""
"<plugin>\n"
"    <artifactId>maven-surefire-plugin</artifactId>\n"
"    <version>${surefire-plugin.version}</version>\n"
"    <configuration>\n"
"       <systemPropertyVariables>\n"
"          <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>\n"
"          <maven.home>${maven.home}</maven.home>\n"
"       </systemPropertyVariables>\n"
"    </configuration>\n"
"</plugin>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:105
#, fuzzy
msgid "We also set the `java.util.logging.manager` system property to make sure tests will use the correct logmanager and `maven.home` to ensure that custom configuration from `${maven.home}/conf/settings.xml` is applied (if any)."
msgstr "我们还设置了 `java.util.logging.manager` 系统属性，以确保测试将使用正确的日志管理器和 `maven.home` ，以确保应用 `${maven.home}/conf/settings.xml` 的自定义配置（如果有的话）。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:107
#, fuzzy
msgid "The project should also contain a simple test:"
msgstr "该项目还应该包含一个简单的测试。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:111
#: upstream/_guides/getting-started-testing.adoc:206
#: upstream/_guides/getting-started-testing.adoc:270
#: upstream/_guides/getting-started-testing.adoc:311
#: upstream/_guides/getting-started-testing.adoc:350
#: upstream/_guides/getting-started-testing.adoc:438
#: upstream/_guides/getting-started-testing.adoc:501
#, no-wrap
msgid "package org.acme.getting.started.testing;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:114
#, no-wrap
msgid ""
"import io.quarkus.test.junit.QuarkusTest;\n"
"import org.junit.jupiter.api.Test;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:116
#: upstream/_guides/getting-started-testing.adoc:317
#, no-wrap
msgid "import java.util.UUID;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:119
#, no-wrap
msgid ""
"import static io.restassured.RestAssured.given;\n"
"import static org.hamcrest.CoreMatchers.is;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:122
#: upstream/_guides/getting-started-testing.adoc:1037
#, no-wrap
msgid ""
"@QuarkusTest\n"
"public class GreetingResourceTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:131
#, no-wrap
msgid ""
"    @Test\n"
"    public void testHelloEndpoint() {\n"
"        given()\n"
"          .when().get(\"/hello\")\n"
"          .then()\n"
"             .statusCode(200)\n"
"             .body(is(\"hello\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:142
#, no-wrap
msgid ""
"    @Test\n"
"    public void testGreetingEndpoint() {\n"
"        String uuid = UUID.randomUUID().toString();\n"
"        given()\n"
"          .pathParam(\"name\", uuid)\n"
"          .when().get(\"/hello/greeting/{name}\")\n"
"          .then()\n"
"            .statusCode(200)\n"
"            .body(is(\"hello \" + uuid));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:144
#: upstream/_guides/getting-started-testing.adoc:410
#: upstream/_guides/getting-started-testing.adoc:734
#: upstream/_guides/getting-started-testing.adoc:1054
#: upstream/_guides/getting-started-testing.adoc:1295
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:148
#, fuzzy
msgid "This test uses HTTP to directly test our REST endpoint. When the test is run the application will be started before the test is run."
msgstr "这个测试使用HTTP来直接测试我们的REST端点。当测试运行时，应用程序将在测试运行前被启动。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:149
#, fuzzy, no-wrap
msgid "Controlling the test port"
msgstr "控制测试端口"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:153
#, fuzzy
msgid "While Quarkus will listen on port `8080` by default, when running tests it defaults to `8081`. This allows you to run tests while having the application running in parallel."
msgstr "虽然Quarkus默认会监听端口 `8080` ，但当运行测试时，它默认为 `8081` 。这允许你在运行测试的同时让应用程序并行运行。"

#. type: Block title
#: upstream/_guides/getting-started-testing.adoc:155
#, fuzzy, no-wrap
msgid "Changing the test port"
msgstr "改变测试端口"

#. type: delimited block =
#: upstream/_guides/getting-started-testing.adoc:158
#, fuzzy
msgid "You can configure the ports used by tests by configuring `quarkus.http.test-port` for HTTP and `quarkus.http.test-ssl-port` for HTTPS in your `application.properties`:"
msgstr "你可以通过在你的 `quarkus.http.test-port` ，为HTTP配置 `quarkus.http.test-ssl-port` ，为HTTPS配置 `application.properties` ，来配置测试使用的端口。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:162
#, no-wrap
msgid ""
"quarkus.http.test-port=8083\n"
"quarkus.http.test-ssl-port=8446\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:164
#, fuzzy
msgid "`0` will result in the use of a random port (assigned by the operating system)."
msgstr " `0` 将导致使用一个随机端口（由操作系统分配）。"

#. type: delimited block =
#: upstream/_guides/getting-started-testing.adoc:168
#, fuzzy
msgid "Quarkus also provides RestAssured integration that updates the default port used by RestAssured before the tests are run, so no additional configuration should be required."
msgstr "Quarkus还提供了RestAssured集成，在测试运行前更新RestAssured使用的默认端口，所以不应该需要额外的配置。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:169
#, fuzzy, no-wrap
msgid "Controlling HTTP interaction timeout"
msgstr "控制HTTP交互超时"

#. type: delimited block =
#: upstream/_guides/getting-started-testing.adoc:173
#, fuzzy
msgid "When using REST Assured in your test, the connection and response timeouts are set to 30 seconds.  You can override this setting with the `quarkus.http.test-timeout` property:"
msgstr "在你的测试中使用REST Assured时，连接和响应超时被设置为30秒。你可以用 `quarkus.http.test-timeout` 属性覆盖这个设置。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:177
#, no-wrap
msgid "quarkus.http.test-timeout=10s\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:179
#, fuzzy, no-wrap
msgid "Injecting a URI"
msgstr "注入一个URI"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:183
#, fuzzy
msgid "It is also possible to directly inject the URL into the test which can make is easy to use a different client. This is done via the `@TestHTTPResource` annotation."
msgstr "也可以直接将URL注入测试中，这可以使使用不同的客户端变得容易。这是通过 `@TestHTTPResource` 注解完成的。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:186
#, fuzzy
msgid "Let's write a simple test that shows this off to load some static resources. First create a simple HTML file in `src/main/resources/META-INF/resources/index.html` :"
msgstr "让我们写一个简单的测试来展示这个加载一些静态资源。首先在 `src/main/resources/META-INF/resources/index.html` 中创建一个简单的HTML文件。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:198
#, no-wrap
msgid ""
"<html>\n"
"    <head>\n"
"        <title>Testing Guide</title>\n"
"    </head>\n"
"    <body>\n"
"        Information about testing\n"
"    </body>\n"
"</html>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:201
#, fuzzy
msgid "We will create a simple test to ensure that this is being served correctly:"
msgstr "我们将创建一个简单的测试，以确保这个服务是正确的。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:211
#: upstream/_guides/getting-started-testing.adoc:275
#, no-wrap
msgid ""
"import java.io.IOException;\n"
"import java.io.InputStream;\n"
"import java.net.URL;\n"
"import java.nio.charset.StandardCharsets;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:214
#: upstream/_guides/getting-started-testing.adoc:278
#: upstream/_guides/getting-started-testing.adoc:355
#, no-wrap
msgid ""
"import org.junit.jupiter.api.Assertions;\n"
"import org.junit.jupiter.api.Test;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:217
#, no-wrap
msgid ""
"import io.quarkus.test.common.http.TestHTTPResource;\n"
"import io.quarkus.test.junit.QuarkusTest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:220
#: upstream/_guides/getting-started-testing.adoc:285
#, no-wrap
msgid ""
"@QuarkusTest\n"
"public class StaticContentTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:223
#, no-wrap
msgid ""
"    @TestHTTPResource(\"index.html\") // <1>\n"
"    URL url;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:232
#, no-wrap
msgid ""
"    @Test\n"
"    public void testIndexHtml() throws IOException {\n"
"        try (InputStream in = url.openStream()) {\n"
"            String contents = new String(in.readAllBytes(), StandardCharsets.UTF_8);\n"
"            Assertions.assertTrue(contents.contains(\"<title>Testing Guide</title>\"));\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:234
#, fuzzy
msgid "This annotation allows you to directly inject the URL of the Quarkus instance, the value of the annotation will be the path component of the URL"
msgstr "这个注解允许你直接注入Quarkus实例的URL，注解的值将是URL的路径部分。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:236
#, fuzzy
msgid "For now `@TestHTTPResource` allows you to inject `URI`, `URL` and `String` representations of the URL."
msgstr "目前， `@TestHTTPResource` ，允许你注入 `URI` 、 `URL` 和 `String` 的URL表示。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:237
#, fuzzy, no-wrap
msgid "Testing a specific endpoint"
msgstr "测试一个特定的端点"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:242
#, fuzzy
msgid "Both RESTassured and `@TestHTTPResource` allow you to specify the endpoint class you are testing rather than hard coding a path. This currently supports both Jakarta REST endpoints, Servlets and Reactive Routes. This makes it a lot easier to see exactly which endpoints a given test is testing."
msgstr "RESTassured和 `@TestHTTPResource` 都允许你指定你要测试的端点类，而不是硬编码一个路径。这目前支持JAX-RS端点、Servlets和Reactive Routes。这使你更容易看到一个给定的测试到底在测试哪些端点。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:244
#, fuzzy
msgid "For the purposes of these examples I am going to assume we have an endpoint that looks like the following:"
msgstr "为了这些例子的目的，我将假设我们有一个看起来像以下的端点。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:249
#, no-wrap
msgid ""
"@Path(\"/hello\")\n"
"public class GreetingResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:256
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        return \"hello\";\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:260
#, fuzzy
msgid "This currently does not support the `@ApplicationPath()` annotation to set the Jakarta REST context path. Use the `quarkus.resteasy.path` config value instead if you want a custom context path."
msgstr "目前不支持使用 `@ApplicationPath()` 注解来设置 JAX-RS 上下文路径。如果你想要一个自定义的上下文路径，请使用 `quarkus.resteasy.path` 配置值代替。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:261
#, fuzzy, no-wrap
msgid "TestHTTPResource"
msgstr "呼叫中心"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:266
#, fuzzy
msgid "You can the use the `io.quarkus.test.common.http.TestHTTPEndpoint` annotation to specify the endpoint path, and the path will be extracted from the provided endpoint. If you also specify a value for the `TestHTTPResource` endpoint it will be appended to the end of the endpoint path."
msgstr "你可以使用 `io.quarkus.test.common.http.TestHTTPEndpoint` 注释来指定端点路径，该路径将从提供的端点中提取。如果你还为 `TestHTTPResource` 端点指定一个值，它将被附加到端点路径的末端。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:282
#, no-wrap
msgid ""
"import io.quarkus.test.common.http.TestHTTPEndpoint;\n"
"import io.quarkus.test.common.http.TestHTTPResource;\n"
"import io.quarkus.test.junit.QuarkusTest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:289
#, no-wrap
msgid ""
"    @TestHTTPEndpoint(GreetingResource.class)  // <1>\n"
"    @TestHTTPResource\n"
"    URL url;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:298
#, no-wrap
msgid ""
"    @Test\n"
"    public void testIndexHtml() throws IOException {\n"
"        try (InputStream in = url.openStream()) {\n"
"            String contents = new String(in.readAllBytes(), StandardCharsets.UTF_8);\n"
"            Assertions.assertEquals(\"hello\", contents);\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:301
#, fuzzy
msgid "Because `GreetingResource` is annotated with `@Path(\"/hello\")` the injected URL will end with `/hello`."
msgstr "因为 `GreetingResource` 被注释为 `@Path(\"/hello\")` ，注入的URL将以 `/hello` 结束。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:302
#, fuzzy, no-wrap
msgid "RESTassured"
msgstr "RESTassured"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:307
#, fuzzy
msgid "To control the RESTassured base path (i.e. the default path that serves as the root for every request) you can use the `io.quarkus.test.common.http.TestHTTPEndpoint` annotation. This can be applied at the class or method level. To test out greeting resource we would do:"
msgstr "为了控制RESTassured基本路径（即作为每个请求根的默认路径），你可以使用 `io.quarkus.test.common.http.TestHTTPEndpoint` 注释。这可以在类或方法层面上应用。为了测试问候资源，我们会这样做。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:315
#, no-wrap
msgid ""
"import io.quarkus.test.junit.QuarkusTest;\n"
"import io.quarkus.test.common.http.TestHTTPEndpoint;\n"
"import org.junit.jupiter.api.Test;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:320
#, no-wrap
msgid ""
"import static io.restassured.RestAssured.when;\n"
"import static org.hamcrest.CoreMatchers.is;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:324
#, no-wrap
msgid ""
"@QuarkusTest\n"
"@TestHTTPEndpoint(GreetingResource.class) //<1>\n"
"public class GreetingResourceTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:333
#, no-wrap
msgid ""
"    @Test\n"
"    public void testHelloEndpoint() {\n"
"        when().get()    //<2>\n"
"          .then()\n"
"             .statusCode(200)\n"
"             .body(is(\"hello\"));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:335
#, fuzzy
msgid "This tells RESTAssured to prefix all requests with `/hello`."
msgstr "这告诉RESTAssured要在所有请求前加上 `/hello` 。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:336
#, fuzzy
msgid "Note we don't need to specify a path here, as `/hello` is the default for this test"
msgstr "注意我们不需要在这里指定一个路径，因为 `/hello` 是这个测试的默认路径。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:337
#, fuzzy, no-wrap
msgid "Injection into tests"
msgstr "注入测试"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:341
#, fuzzy
msgid "So far we have only covered integration style tests that test the app via HTTP endpoints, but what if we want to do unit testing and test our beans directly?"
msgstr "到目前为止，我们只涉及了通过HTTP端点测试应用程序的集成式测试，但如果我们想做单元测试并直接测试我们的Bean怎么办？"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:345
#, fuzzy
msgid "Quarkus supports this by allowing you to inject CDI beans into your tests via the `@Inject` annotation (in fact, tests in Quarkus are full CDI beans, so you can use all CDI functionality). Let's create a simple test that tests the greeting service directly without using HTTP:"
msgstr "Quarkus支持这一点，允许你通过 `@Inject` 注释将CDI Bean注入你的测试中（事实上，Quarkus中的测试是完整的CDI Bean，所以你可以使用所有的CDI功能）。让我们创建一个简单的测试，直接测试问候服务，而不使用HTTP。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:352
#, no-wrap
msgid "import jakarta.inject.Inject;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:357
#, no-wrap
msgid "import io.quarkus.test.junit.QuarkusTest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:360
#, no-wrap
msgid ""
"@QuarkusTest\n"
"public class GreetingServiceTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:363
#, no-wrap
msgid ""
"    @Inject // <1>\n"
"    GreetingService service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:369
#, no-wrap
msgid ""
"    @Test\n"
"    public void testGreetingService() {\n"
"        Assertions.assertEquals(\"hello Quarkus\", service.greeting(\"Quarkus\"));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:371
#, fuzzy
msgid "The `GreetingService` bean will be injected into the test"
msgstr " `GreetingService` 豆子将被注入到测试中。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:372
#, fuzzy, no-wrap
msgid "Applying Interceptors to Tests"
msgstr "将拦截器应用于测试"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:377
#, fuzzy
msgid "As mentioned above Quarkus tests are actually full CDI beans, and as such you can apply CDI interceptors as you would normally. As an example, if you want a test method to run within the context of a transaction you can simply apply the `@Transactional` annotation to the method and the transaction interceptor will handle it."
msgstr "如上所述，Quarkus测试实际上是完整的CDI Bean，因此你可以像通常那样应用CDI拦截器。举个例子，如果你想让一个测试方法在一个事务的上下文中运行，你可以简单地将 `@Transactional` 注释应用到该方法中，事务拦截器将处理它。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:380
#, fuzzy
msgid "In addition to this you can also create your own test stereotypes. For example, we could create a `@TransactionalQuarkusTest` as follows:"
msgstr "除此以外，你还可以创建你自己的测试定型。例如，我们可以创建一个 `@TransactionalQuarkusTest` ，如下所示。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:390
#, no-wrap
msgid ""
"@QuarkusTest\n"
"@Stereotype\n"
"@Transactional\n"
"@Retention(RetentionPolicy.RUNTIME)\n"
"@Target(ElementType.TYPE)\n"
"public @interface TransactionalQuarkusTest {\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:394
#, fuzzy
msgid "If we then apply this annotation to a test class it will act as if we had applied both the `@QuarkusTest` and `@Transactional` annotations, e.g.:"
msgstr "如果我们将这个注解应用于测试类，它将像我们同时应用 `@QuarkusTest` 和 `@Transactional` 注解一样，例如。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:400
#, no-wrap
msgid ""
"@TransactionalQuarkusTest\n"
"public class TestStereotypeTestCase {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:403
#, no-wrap
msgid ""
"    @Inject\n"
"    UserTransaction userTransaction;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:408
#, no-wrap
msgid ""
"    @Test\n"
"    public void testUserTransaction() throws Exception {\n"
"        Assertions.assertEquals(Status.STATUS_ACTIVE, userTransaction.getStatus());\n"
"    }\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:412
#, fuzzy, no-wrap
msgid "Tests and Transactions"
msgstr "测试和交易"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:418
#, fuzzy
msgid "You can use the standard Quarkus `@Transactional` annotation on tests, but this means that the changes your test makes to the database will be persistent. If you want any changes made to be rolled back at the end of the test you can use the `io.quarkus.test.TestTransaction` annotation. This will run the test method in a transaction, but roll it back once the test method is complete to revert any database changes."
msgstr "你可以在测试中使用标准的Quarkus `@Transactional` 注解，但这意味着你的测试对数据库的改变将是持久的。如果你想在测试结束时回滚所做的任何改变，你可以使用 `io.quarkus.test.TestTransaction` 注释。这将在一个事务中运行测试方法，但一旦测试方法完成，就会回滚，以恢复任何数据库变化。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:419
#, fuzzy, no-wrap
msgid "Enrichment via QuarkusTest*Callback"
msgstr "通过QuarkusTest*Callback的丰富性"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:422
#, fuzzy
msgid "Alternatively or additionally to an interceptor, you can enrich *all* your `@QuarkusTest` classes by implementing the following callback interfaces:"
msgstr "作为拦截器的替代或补充，你可以通过实现以下回调接口来丰富你 *所有* 的 `@QuarkusTest` 类。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:424
#, fuzzy
msgid "`io.quarkus.test.junit.callback.QuarkusTestBeforeClassCallback`"
msgstr " `io.quarkus.test.junit.callback.QuarkusTestBeforeClassCallback` "

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:425
#, fuzzy
msgid "`io.quarkus.test.junit.callback.QuarkusTestAfterConstructCallback`"
msgstr " `io.quarkus.test.junit.callback.QuarkusTestAfterConstructCallback` "

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:426
#, fuzzy
msgid "`io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback`"
msgstr " `io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback` "

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:427
#, fuzzy
msgid "`io.quarkus.test.junit.callback.QuarkusTestBeforeTestExecutionCallback`"
msgstr " `io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback` "

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:428
#, fuzzy
msgid "`io.quarkus.test.junit.callback.QuarkusTestAfterTestExecutionCallback`"
msgstr " `io.quarkus.test.junit.callback.QuarkusTestAfterEachCallback` "

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:429
#, fuzzy
msgid "`io.quarkus.test.junit.callback.QuarkusTestAfterEachCallback`"
msgstr " `io.quarkus.test.junit.callback.QuarkusTestAfterEachCallback` "

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:431
#, fuzzy
msgid "Optionally, you can enable these callbacks also for the `@QuarkusIntegrationTest` tests if the property `quarkus.test.enable-callbacks-for-integration-tests` is `true`."
msgstr "可选的是，如果属性 `quarkus.test.enable-callbacks-for-integration-tests` 是 `true` ，你也可以为 `@QuarkusIntegrationTest` 测试启用这些回调。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:433
#, fuzzy
msgid "Such a callback implementation has to be registered as a \"service provider\" as defined by `java.util.ServiceLoader`."
msgstr "这样的回调实现必须作为 \"服务提供者 \"注册，正如 `java.util.ServiceLoader` 所定义的。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:435
#, fuzzy
msgid "E.g. the following sample callback:"
msgstr "例如，下面的回调样本。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:441
#, no-wrap
msgid ""
"import io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback;\n"
"import io.quarkus.test.junit.callback.QuarkusTestMethodContext;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:443
#, no-wrap
msgid "public class MyQuarkusTestBeforeEachCallback implements QuarkusTestBeforeEachCallback {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:449
#, no-wrap
msgid ""
"    @Override\n"
"    public void beforeEach(QuarkusTestMethodContext context) {\n"
"        System.out.println(\"Executing \" + context.getTestMethod());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:451
#, fuzzy
msgid "has to be registered via `src/main/resources/META-INF/services/io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback` as follows:"
msgstr "必须通过 `src/main/resources/META-INF/services/io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback` 注册，具体如下。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:454
#, no-wrap
msgid "org.acme.getting.started.testing.MyQuarkusTestBeforeEachCallback\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:457
#, fuzzy
msgid "It is possible to read annotations from the test class or method to control what the callback shall be doing."
msgstr "可以从测试类或方法中读取注解，以控制回调应做什么。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:460
#, fuzzy, no-wrap
msgid ""
"While it is possible to use JUnit Jupiter callback interfaces like `BeforeEachCallback`, you might run into classloading issues because Quarkus has\n"
"         to run tests in a custom classloader which JUnit is not aware of.\n"
msgstr "虽然可以使用JUnit Jupiter回调接口，如 `BeforeEachCallback` ，但你可能会遇到类加载问题，因为Quarkus必须在一个JUnit不知道的自定义类加载器中运行测试。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:462
#, fuzzy, no-wrap
msgid "Testing Different Profiles"
msgstr "测试不同的配置文件"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:467
#, fuzzy
msgid "So far in all our examples we only start Quarkus once for all tests. Before the first test is run Quarkus will boot, then all tests will run, then Quarkus will shut down at the end. This makes for a very fast testing experience however it is a bit limited as you can't test different configurations."
msgstr "到目前为止，在我们所有的例子中，我们只为所有的测试启动Quarkus一次。在第一个测试运行之前，Quarkus会启动，然后所有测试都会运行，最后Quarkus会关闭。这使得测试体验非常快，但是它有一点局限性，因为你不能测试不同的配置。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:471
#, fuzzy
msgid "To get around this Quarkus supports the idea of a test profile. If a test has a different profile to the previously run test then Quarkus will be shut down and started with the new profile before running the tests. This is obviously a bit slower, as it adds a shutdown/startup cycle to the test time, but gives a great deal of flexibility."
msgstr "为了解决这个问题，Quarkus支持测试配置文件的想法。如果一个测试有一个与之前运行的测试不同的配置文件，那么Quarkus将被关闭，并在运行测试之前用新的配置文件启动。这显然有点慢，因为它在测试时间上增加了一个关闭/启动周期，但提供了很大的灵活性。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:479
#, fuzzy
msgid "To reduce the amount of times Quarkus needs to restart, `io.quarkus.test.junit.util.QuarkusTestProfileAwareClassOrderer` is registered as a global `ClassOrderer` as described in the link:https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-execution-order-classes[JUnit 5 User Guide].  The behavior of this `ClassOrderer` is configurable via `junit-platform.properties` (see the source code or javadoc for more details).  It can also be disabled entirely by setting another `ClassOrderer` that is provided by JUnit 5 or even your own custom one. + Please note that as of JUnit 5.8.2 link:https://github.com/junit-team/junit5/issues/2794[only a single `junit-platform.properties` is picked up and a warning is logged if more than one is found].  If you encounter such warnings, you can get rid of them by removing the Quarkus-supplied `junit-platform.properties` from the classpath via an exclusion:"
msgstr "为了减少Quarkus需要重启的次数， `io.quarkus.test.junit.util.QuarkusTestProfileAwareClassOrderer` 被注册为全局 `ClassOrderer` ，如 link:https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-execution-order-classes[JUnit 5用户指南] 中所述。这个orderer的行为可以通过 `junit-platform.properties` （更多细节见源代码或javadoc）来配置。它也可以通过设置另一个由JUnit 5提供的订购器或甚至你自己的自定义订购器来完全禁用。+ 请注意，从JUnit 5.8.2开始 link:https://github.com/junit-team/junit5/issues/2794[，只有一个 `junit-platform.properties` ，如果发现超过一个，就会记录警告] 。如果你遇到这样的警告，你可以通过排除法从classpath中移除Quarkus提供的 `junit-platform.properties` ，从而摆脱它们。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:492
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-junit5</artifactId>\n"
"    <scope>test</scope>\n"
"    <exclusions>\n"
"        <exclusion>\n"
"            <groupId>io.quarkus</groupId>\n"
"            <artifactId>quarkus-junit5-properties</artifactId>\n"
"        </exclusion>\n"
"    </exclusions>\n"
"</dependency>\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:494
#, fuzzy, no-wrap
msgid "Writing a Profile"
msgstr "撰写简介"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:497
#, fuzzy
msgid "To implement a test profile we need to implement `io.quarkus.test.junit.QuarkusTestProfile`:"
msgstr "为了实现一个测试配置文件，我们需要实现 `io.quarkus.test.junit.QuarkusTestProfile` 。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:506
#, no-wrap
msgid ""
"import java.util.Collections;\n"
"import java.util.List;\n"
"import java.util.Map;\n"
"import java.util.Set;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:509
#, no-wrap
msgid ""
"import io.quarkus.test.junit.QuarkusTestProfile;\n"
"import io.quarkus.test.junit.QuarkusTestProfile.TestResourceEntry;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:511
#, no-wrap
msgid "public class MockGreetingProfile implements QuarkusTestProfile { <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:524
#, no-wrap
msgid ""
"    /**\n"
"     * Returns additional config to be applied to the test. This\n"
"     * will override any existing config (including in application.properties),\n"
"     * however existing config will be merged with this (i.e. application.properties\n"
"     * config will still take effect, unless a specific config key has been overridden).\n"
"     *\n"
"     * Here we are changing the Jakarta REST root path.\n"
"     */\n"
"    @Override\n"
"    public Map<String, String> getConfigOverrides() {\n"
"        return Collections.singletonMap(\"quarkus.resteasy.path\",\"/api\");\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:535
#, no-wrap
msgid ""
"    /**\n"
"     * Returns enabled alternatives.\n"
"     *\n"
"     * This has the same effect as setting the 'quarkus.arc.selected-alternatives' config key,\n"
"     * however it may be more convenient.\n"
"     */\n"
"    @Override\n"
"    public Set<Class<?>> getEnabledAlternatives() {\n"
"        return Collections.singleton(MockGreetingService.class);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:546
#, no-wrap
msgid ""
"    /**\n"
"     * Allows the default config profile to be overridden. This basically just sets the quarkus.test.profile system\n"
"     * property before the test is run.\n"
"     *\n"
"     * Here we are setting the profile to test-mocked\n"
"     */\n"
"    @Override\n"
"    public String getConfigProfile() {\n"
"        return \"test-mocked\";\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:558
#, no-wrap
msgid ""
"    /**\n"
"     * Additional {@link QuarkusTestResourceLifecycleManager} classes (along with their init params) to be used from this\n"
"     * specific test profile.\n"
"     *\n"
"     * If this method is not overridden, then only the {@link QuarkusTestResourceLifecycleManager} classes enabled via the {@link io.quarkus.test.common.QuarkusTestResource} class\n"
"     * annotation will be used for the tests using this profile (which is the same behavior as tests that don't use a profile at all).\n"
"     */\n"
"    @Override\n"
"    public List<TestResourceEntry> testResources() {\n"
"        return Collections.singletonList(new TestResourceEntry(CustomWireMockServerManager.class));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:568
#, no-wrap
msgid ""
"    /**\n"
"     * If this returns true then only the test resources returned from {@link #testResources()} will be started,\n"
"     * global annotated test resources will be ignored.\n"
"     */\n"
"    @Override\n"
"    public boolean disableGlobalTestResources() {\n"
"        return false;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:579
#, no-wrap
msgid ""
"    /**\n"
"     * The tags this profile is associated with.\n"
"     * When the {@code quarkus.test.profile.tags} System property is set (its value is a comma separated list of strings)\n"
"     * then Quarkus will only execute tests that are annotated with a {@code @TestProfile} that has at least one of the\n"
"     * supplied (via the aforementioned system property) tags.\n"
"     */\n"
"    @Override\n"
"    public Set<String> tags() {\n"
"        return Collections.emptySet();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:587
#, no-wrap
msgid ""
"    /**\n"
"     * The command line parameters that are passed to the main method on startup.\n"
"     */\n"
"    @Override\n"
"    public String[] commandLineParameters() {\n"
"        return new String[0];\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:595
#, no-wrap
msgid ""
"    /**\n"
"     * If the main method should be run.\n"
"     */\n"
"    @Override\n"
"    public boolean runMainMethod() {\n"
"        return false;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:605
#, no-wrap
msgid ""
"    /**\n"
"     * If this method returns true then all {@code StartupEvent} and {@code ShutdownEvent} observers declared on application\n"
"     * beans should be disabled.\n"
"     */\n"
"    @Override\n"
"    public boolean disableApplicationLifecycleObservers() {\n"
"        return false;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:607
#, fuzzy
msgid "All these methods have default implementations so just override the ones you need to override."
msgstr "所有这些方法都有默认的实现，所以只要覆盖你需要覆盖的方法就可以了。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:610
#, fuzzy
msgid "Now we have defined our profile we need to include it on our test class.  We do this by annotating the test class with `@TestProfile(MockGreetingProfile.class)`."
msgstr "现在我们已经定义了我们的配置文件，我们需要在我们的测试类中包含它。我们通过在测试类中注解 `@TestProfile(MockGreetingProfile.class)` 来做到这一点。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:613
#, fuzzy
msgid "All the test profile configuration is stored in a single class, which makes it easy to tell if the previous test ran with the same configuration."
msgstr "所有的测试配置文件配置都存储在一个单一的类中，这使得我们很容易知道以前的测试是否以相同的配置运行。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:614
#, fuzzy, no-wrap
msgid "Running specific tests"
msgstr "运行特定的测试"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:618
#, fuzzy
msgid "Quarkus provides the ability to limit test execution to tests with specific `@TestProfile` annotations.  This works by leveraging the `tags` method of `QuarkusTestProfile` in conjunction with the `quarkus.test.profile.tags` system property."
msgstr "Quarkus提供了将测试执行限制在具有特定 `@TestProfile` 注释的测试的能力。这是通过利用 `QuarkusTestProfile` 的 `tags` 方法和 `quarkus.test.profile.tags` 系统属性来实现的。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:622
#, fuzzy
msgid "Essentially, any `QuarkusTestProfile` with at least one matching tag matching the value of `quarkus.test.profile.tags` will be considered active and all the tests annotated with `@TestProfile` of active profiles, will be run while the rest will be skipped.  This is best shown in the following example."
msgstr "基本上，任何至少有一个匹配标签与 `quarkus.test.profile.tags` 的值相匹配的 `QuarkusTestProfile` 将被认为是活动的，所有被活动的配置文件注释为 `@TestProfile` 的测试将被运行，而其余的将被跳过。这在下面的例子中得到了最好的体现。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:624
#, fuzzy
msgid "First let's define a few `QuarkusTestProfile` implementations like so:"
msgstr "首先让我们像这样定义几个 `QuarkusTestProfile` 实现。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:627
#, no-wrap
msgid "public class Profiles {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:629
#, no-wrap
msgid "    public static class NoTags implements QuarkusTestProfile {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:631
#: upstream/_guides/getting-started-testing.adoc:1686
#, no-wrap
msgid "    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:638
#, no-wrap
msgid ""
"    public static class SingleTag implements QuarkusTestProfile {\n"
"        @Override\n"
"        public Set<String> tags() {\n"
"            return Collections.singleton(\"test1\");\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:646
#, no-wrap
msgid ""
"    public static class MultipleTags implements QuarkusTestProfile {\n"
"        @Override\n"
"        public Set<String> tags() {\n"
"            return new HashSet<>(Arrays.asList(\"test1\", \"test2\"));\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:649
#, fuzzy
msgid "Now let's assume that we have the following tests:"
msgstr "现在让我们假设我们有以下测试。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:654
#, no-wrap
msgid ""
"@QuarkusTest\n"
"public class NoQuarkusProfileTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:660
#: upstream/_guides/getting-started-testing.adoc:673
#: upstream/_guides/getting-started-testing.adoc:686
#: upstream/_guides/getting-started-testing.adoc:699
#, no-wrap
msgid ""
"    @Test\n"
"    public void test() {\n"
"        // test something\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:667
#, no-wrap
msgid ""
"@QuarkusTest\n"
"@TestProfile(Profiles.NoTags.class)\n"
"public class NoTagsTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:680
#, no-wrap
msgid ""
"@QuarkusTest\n"
"@TestProfile(Profiles.SingleTag.class)\n"
"public class SingleTagTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:693
#, no-wrap
msgid ""
"@QuarkusTest\n"
"@TestProfile(Profiles.MultipleTags.class)\n"
"public class MultipleTagsTest {\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:702
#, fuzzy
msgid "Let's consider the following scenarios:"
msgstr "让我们考虑以下情况。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:704
#, fuzzy
msgid "`quarkus.test.profile.tags` is not set: All tests will be executed."
msgstr " `quarkus.test.profile.tags` 未被设置。所有的测试都将被执行。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:706
#, fuzzy
msgid "`quarkus.test.profile.tags=foo`: In this case none of tests will be executed because none of the tags defined on the `QuarkusTestProfile` implementations match the value of `quarkus.test.profile.tags`.  Note that `NoQuarkusProfileTest` is not executed either because it is not annotated with `@TestProfile`."
msgstr " `quarkus.test.profile.tags=foo` :在这种情况下，没有一个测试会被执行，因为在 `QuarkusTestProfile` 实现上定义的标签没有一个与 `quarkus.test.profile.tags` 的值相匹配。注意， `NoQuarkusProfileTest` 也不会被执行，因为它没有被注释为 `@TestProfile` 。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:708
#, fuzzy
msgid "`quarkus.test.profile.tags=test1`: In this case `SingleTagTest` and `MultipleTagsTest` will be run because the tags on their respective `QuarkusTestProfile` implementations match the value of `quarkus.test.profile.tags`."
msgstr " `quarkus.test.profile.tags=test1` :在这种情况下， `SingleTagTest` 和 `MultipleTagsTest` 将被运行，因为它们各自的 `QuarkusTestProfile` 实现上的标签与 `quarkus.test.profile.tags` 的值一致。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:709
#, fuzzy
msgid "`quarkus.test.profile.tags=test1,test3`: This case results in the same tests being executed as the previous case."
msgstr " `quarkus.test.profile.tags=test1,test3` :这种情况下，执行的测试与前一种情况相同。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:711
#, fuzzy
msgid "`quarkus.test.profile.tags=test2,test3`: In this case only `MultipleTagsTest` will be run because `MultipleTagsTest` is the only `QuarkusTestProfile` implementation whose `tags` method matches the value of `quarkus.test.profile.tags`."
msgstr " `quarkus.test.profile.tags=test2,test3` :在这种情况下，只有 `MultipleTagsTest` 会被运行，因为 `MultipleTagsTest` 是唯一的 `QuarkusTestProfile` 实现，其 `tags` 方法与 `quarkus.test.profile.tags` 的值相匹配。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:712
#, fuzzy, no-wrap
msgid "Mock Support"
msgstr "模拟支持"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:716
#, fuzzy
msgid "Quarkus supports the use of mock objects using two different approaches. You can either use CDI alternatives to mock out a bean for all test classes, or use `QuarkusMock` to mock out beans on a per test basis."
msgstr "Quarkus支持使用两种不同的方法来模拟对象。你可以使用CDI替代方案来模拟所有测试类的Bean，或者使用 `QuarkusMock` 来模拟每个测试类的Bean。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:717
#, fuzzy, no-wrap
msgid "CDI `@Alternative` mechanism."
msgstr "CDI `@Alternative` 机制。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:723
#, fuzzy
msgid "To use this simply override the bean you wish to mock with a class in the `src/test/java` directory, and put the `@Alternative` and `@Priority(1)` annotations on the bean.  Alternatively, a convenient `io.quarkus.test.Mock` stereotype annotation could be used.  This built-in stereotype declares `@Alternative`, `@Priority(1)` and `@Dependent`.  For example if I have the following service:"
msgstr "要使用这个方法，只需用 `src/test/java` 目录中的一个类来覆盖你想模拟的Bean，并在Bean上加上 `@Alternative` 和 `@Priority(1)` 注解。另外，也可以使用一个方便的 `io.quarkus.test.Mock` 定型注释。这个内置的定型声明了 `@Alternative` 、 `@Priority(1)` 和 `@Dependent` 。例如，如果我有以下的服务。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:728
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class ExternalService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:732
#, no-wrap
msgid ""
"    public String service() {\n"
"        return \"external\";\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:737
#, fuzzy
msgid "I could mock it with the following class in `src/test/java`:"
msgstr "我可以在 `src/test/java` 中用以下类来模拟它。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:743
#, no-wrap
msgid ""
"@Mock\n"
"@ApplicationScoped // <1>\n"
"public class MockExternalService extends ExternalService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:749
#, no-wrap
msgid ""
"    @Override\n"
"    public String service() {\n"
"        return \"mock\";\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:751
#, fuzzy
msgid "Overrides the `@Dependent` scope declared on the `@Mock` stereotype."
msgstr "覆盖在 `@Mock` 定型上声明的 `@Dependent` 范围。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:754
#, fuzzy
msgid "It is important that the alternative be present in the `src/test/java` directory rather than `src/main/java`, as otherwise it will take effect all the time, not just when testing."
msgstr "重要的是，替代方案必须存在于 `src/test/java` 目录中，而不是 `src/main/java` ，否则它将一直生效，而不仅仅是在测试时。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:757
#, fuzzy
msgid "Note that at present this approach does not work with native image testing, as this would require the test alternatives to be baked into the native image."
msgstr "需要注意的是，目前这种方法不能用于原生图像测试，因为这需要将测试的替代方案烘烤到原生图像中。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:759
#, fuzzy, no-wrap
msgid "Mocking using QuarkusMock"
msgstr "使用QuarkusMock进行模拟"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:764
#, fuzzy
msgid "The `io.quarkus.test.junit.QuarkusMock` class can be used to temporarily mock out any normal scoped bean. If you use this method in a `@BeforeAll` method the mock will take effect for all tests on the current class, while if you use this in a test method the mock will only take effect for the duration of the current test."
msgstr " `io.quarkus.test.junit.QuarkusMock` 类可以被用来暂时模拟任何正常范围的bean。如果你在 `@BeforeAll` 方法中使用这个方法，模拟将对当前类的所有测试生效，而如果你在测试方法中使用这个方法，模拟将只在当前测试的时间内生效。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:767
#, fuzzy
msgid "This method can be used for any normal scoped CDI bean (e.g. `@ApplicationScoped`, `@RequestScoped` etc, basically every scope except `@Singleton` and `@Dependent`)."
msgstr "这个方法可以用于任何正常范围的CDI Bean（例如： `@ApplicationScoped` , `@RequestScoped` 等，基本上每个范围除了 `@Singleton` 和 `@Dependent` ）。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:769
#, fuzzy
msgid "An example usage could look like:"
msgstr "一个例子的用法可能是这样的。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:774
#: upstream/_guides/getting-started-testing.adoc:846
#, no-wrap
msgid ""
"@QuarkusTest\n"
"public class MockTestCase {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:777
#, no-wrap
msgid ""
"    @Inject\n"
"    MockableBean1 mockableBean1;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:780
#, no-wrap
msgid ""
"    @Inject\n"
"    MockableBean2 mockableBean2;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:787
#, no-wrap
msgid ""
"    @BeforeAll\n"
"    public static void setup() {\n"
"        MockableBean1 mock = Mockito.mock(MockableBean1.class);\n"
"        Mockito.when(mock.greet(\"Stuart\")).thenReturn(\"A mock for Stuart\");\n"
"        QuarkusMock.installMockForType(mock, MockableBean1.class);  // <1>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:793
#, no-wrap
msgid ""
"    @Test\n"
"    public void testBeforeAll() {\n"
"        Assertions.assertEquals(\"A mock for Stuart\", mockableBean1.greet(\"Stuart\"));\n"
"        Assertions.assertEquals(\"Hello Stuart\", mockableBean2.greet(\"Stuart\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:800
#, no-wrap
msgid ""
"    @Test\n"
"    public void testPerTestMock() {\n"
"        QuarkusMock.installMockForInstance(new BonjourGreeter(), mockableBean2); // <2>\n"
"        Assertions.assertEquals(\"A mock for Stuart\", mockableBean1.greet(\"Stuart\"));\n"
"        Assertions.assertEquals(\"Bonjour Stuart\", mockableBean2.greet(\"Stuart\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:803
#: upstream/_guides/getting-started-testing.adoc:873
#, no-wrap
msgid ""
"    @ApplicationScoped\n"
"    public static class MockableBean1 {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:808
#: upstream/_guides/getting-started-testing.adoc:816
#: upstream/_guides/getting-started-testing.adoc:878
#, no-wrap
msgid ""
"        public String greet(String name) {\n"
"            return \"Hello \" + name;\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:811
#: upstream/_guides/getting-started-testing.adoc:881
#, no-wrap
msgid ""
"    @ApplicationScoped\n"
"    public static class MockableBean2 {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:824
#, no-wrap
msgid ""
"    public static class BonjourGreeter extends MockableBean2 {\n"
"        @Override\n"
"        public String greet(String name) {\n"
"            return \"Bonjour \" + name;\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:826
#, fuzzy
msgid "As the injected instance is not available here we use `installMockForType`, this mock is used for both test methods"
msgstr "由于注入的实例在这里不可用，我们使用 `installMockForType` ，这个模拟用于两个测试方法。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:827
#, fuzzy
msgid "We use `installMockForInstance` to replace the injected bean, this takes effect for the duration of the test method."
msgstr "我们使用 `installMockForInstance` ，以取代注入的豆子，这在测试方法的持续时间内生效。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:830
#, fuzzy
msgid "Note that there is no dependency on Mockito, you can use any mocking library you like, or even manually override the objects to provide the behaviour you require."
msgstr "请注意，这里没有对Mockito的依赖性，你可以使用任何你喜欢的嘲讽库，甚至可以手动覆盖对象以提供你需要的行为。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:834
#, fuzzy
msgid "Using `@Inject` will get you a CDI proxy to the mock instance you install, which is not suitable for passing to methods such as `Mockito.verify` which want the mock instance itself.  So if you need to call methods such as `verify` you should hang on to the mock instance in your test, or use `@io.quarkus.test.InjectMock`."
msgstr "使用 `@Inject` ，你会得到一个CDI代理到你安装的模拟实例，这不适合传递给诸如 `Mockito.verify` ，这些方法需要模拟实例本身。因此，如果你需要调用诸如 `verify` 的方法，你需要在你的测试中挂上模拟实例，或者使用 `@InjectMock` ，如下所示。"

#. type: Title ====
#: upstream/_guides/getting-started-testing.adoc:835
#, fuzzy, no-wrap
msgid "Further simplification with `@InjectMock`"
msgstr "进一步简化了与 `@InjectMock` "

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:839
#, fuzzy
msgid "Building on the features provided by `QuarkusMock`, Quarkus also allows users to effortlessly take advantage of link:https://site.mockito.org/[Mockito] for mocking the beans supported by `QuarkusMock`.  This functionality is available with the `@io.quarkus.test.InjectMock` annotation if the `quarkus-junit5-mockito` dependency is present."
msgstr "基于 `QuarkusMock` 所提供的功能，Quarkus还允许用户毫不费力地利用 link:https://site.mockito.org/[Mockito] 来嘲弄 `QuarkusMock` 所支持的bean。这个功能可以通过 `@io.quarkus.test.junit.mockito.InjectMock` 注解来实现，该注解可以在 `quarkus-junit5-mockito` 依赖关系中使用。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:841
#, fuzzy
msgid "Using `@InjectMock`, the previous example could be written as follows:"
msgstr "使用 `@InjectMock` ，前面的例子可以写成如下。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:849
#, no-wrap
msgid ""
"    @InjectMock\n"
"    MockableBean1 mockableBean1; // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:852
#, no-wrap
msgid ""
"    @InjectMock\n"
"    MockableBean2 mockableBean2;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:857
#, no-wrap
msgid ""
"    @BeforeEach\n"
"    public void setup() {\n"
"        Mockito.when(mockableBean1.greet(\"Stuart\")).thenReturn(\"A mock for Stuart\"); // <2>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:863
#, no-wrap
msgid ""
"    @Test\n"
"    public void firstTest() {\n"
"        Assertions.assertEquals(\"A mock for Stuart\", mockableBean1.greet(\"Stuart\"));\n"
"        Assertions.assertEquals(null, mockableBean2.greet(\"Stuart\")); // <3>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:870
#, no-wrap
msgid ""
"    @Test\n"
"    public void secondTest() {\n"
"        Mockito.when(mockableBean2.greet(\"Stuart\")).thenReturn(\"Bonjour Stuart\"); // <4>\n"
"        Assertions.assertEquals(\"A mock for Stuart\", mockableBean1.greet(\"Stuart\"));\n"
"        Assertions.assertEquals(\"Bonjour Stuart\", mockableBean2.greet(\"Stuart\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:887
#, no-wrap
msgid ""
"        public String greet(String name) {\n"
"            return \"Hello \" + name;\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:889
#, fuzzy
msgid "`@InjectMock` results in a Mockito mock being created, which is then available in test methods of the test class (other test classes are *not* affected by this)"
msgstr " `@InjectMock` 导致一个模拟的存在，并在测试类的测试方法中可用（其他测试 *类不受* 此影响）。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:890
#, fuzzy
msgid "The `mockableBean1` is configured here for every test method of the class"
msgstr " `mockableBean1` 在这里为类的每个测试方法配置了"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:891
#, fuzzy
msgid "Since the `mockableBean2` mock has not been configured, it will return the default Mockito response."
msgstr "由于 `mockableBean2` mock还没有被配置，它将返回默认的Mockito响应。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:892
#, fuzzy
msgid "In this test the `mockableBean2` is configured, so it returns the configured response."
msgstr "在这个测试中， `mockableBean2` 是配置好的，所以它返回配置好的响应。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:896
#, fuzzy
msgid "Although the test above is good for showing the capabilities of `@InjectMock`, it is not a good representation of a real test. In a real test we would most likely configure a mock, but then test a bean that uses the mocked bean.  Here is an example:"
msgstr "尽管上面的测试很好地展示了 `@InjectMock` 的能力，但它并不能很好地代表一个真实的测试。在一个真实的测试中，我们很可能会配置一个模拟，然后测试一个使用模拟Bean的Bean。下面是一个例子。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:901
#, no-wrap
msgid ""
"@QuarkusTest\n"
"public class MockGreetingServiceTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:904
#, no-wrap
msgid ""
"    @InjectMock\n"
"    GreetingService greetingService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:914
#, no-wrap
msgid ""
"    @Test\n"
"    public void testGreeting() {\n"
"        when(greetingService.greet()).thenReturn(\"hi\");\n"
"        given()\n"
"                .when().get(\"/greeting\")\n"
"                .then()\n"
"                .statusCode(200)\n"
"                .body(is(\"hi\")); // <1>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:917
#: upstream/_guides/getting-started-testing.adoc:987
#, no-wrap
msgid ""
"    @Path(\"greeting\")\n"
"    public static class GreetingResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:919
#: upstream/_guides/getting-started-testing.adoc:989
#, no-wrap
msgid "        final GreetingService greetingService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:923
#: upstream/_guides/getting-started-testing.adoc:993
#, no-wrap
msgid ""
"        public GreetingResource(GreetingService greetingService) {\n"
"            this.greetingService = greetingService;\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:930
#: upstream/_guides/getting-started-testing.adoc:1000
#, no-wrap
msgid ""
"        @GET\n"
"        @Produces(\"text/plain\")\n"
"        public String greet() {\n"
"            return greetingService.greet();\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:938
#: upstream/_guides/getting-started-testing.adoc:1008
#, no-wrap
msgid ""
"    @ApplicationScoped\n"
"    public static class GreetingService {\n"
"        public String greet(){\n"
"            return \"hello\";\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:940
#, fuzzy
msgid "Since we configured `greetingService` as a mock, the `GreetingResource` which uses the `GreetingService` bean, we get the mocked response instead of the response of the regular `GreetingService` bean"
msgstr "由于我们将 `greetingService` 配置为一个模拟，即使用 `GreetingService` Bean的 `GreetingResource` ，我们得到模拟的响应，而不是普通 `GreetingService` Bean的响应。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:944
#, fuzzy
msgid "By default, the `@InjectMock` annotation can be used for any normal CDI scoped bean (e.g. `@ApplicationScoped`, `@RequestScoped`).  Mocking `@Singleton` beans can be performed by adding the `@MockitoConfig(convertScopes = true)` annotation.  This will convert the `@Singleton` bean to an `@ApplicationScoped` bean for the test."
msgstr "默认情况下， `@InjectMock` 注解可用于任何正常的CDI范围内的Bean（例如 `@ApplicationScoped` , `@RequestScoped` ）。嘲弄 `@Singleton` Bean可以通过设置 `convertScopes` 属性为真来进行（如 `@InjectMock(convertScopes = true` ）。这将把 `@Singleton` bean转换为 `@ApplicationScoped` bean进行测试。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:946
#, fuzzy
msgid "This is considered an advanced option and should only be performed if you fully understand the consequences of changing the scope of the bean."
msgstr "这被认为是一个高级选项，只有在你完全了解改变Bean的范围的后果时才可以执行。"

#. type: Title ====
#: upstream/_guides/getting-started-testing.adoc:947
#, fuzzy, no-wrap
msgid "Using Spies instead of Mocks with `@InjectSpy`"
msgstr "用Spies代替Mocks `@InjectSpy` "

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:951
#, fuzzy
msgid "Building on the features provided by `InjectMock`, Quarkus also allows users to effortlessly take advantage of link:https://site.mockito.org/[Mockito] for spying on the beans supported by `QuarkusMock`.  This functionality is available via the `@io.quarkus.test.junit.mockito.InjectSpy` annotation which is available in the `quarkus-junit5-mockito` dependency."
msgstr "基于 `InjectMock` 所提供的功能，Quarkus还允许用户毫不费力地利用 link:https://site.mockito.org/[Mockito] 来窥探 `QuarkusMock` 所支持的bean。这个功能可以通过 `@io.quarkus.test.junit.mockito.InjectSpy` 注解来实现，该注解可以在 `quarkus-junit5-mockito` 依赖关系中使用。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:955
#, fuzzy
msgid "Sometimes when testing you only need to verify that a certain logical path was taken, or you only need to stub out a single method's response while still executing the rest of the methods on the Spied clone. Please see link:https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html#13[Mockito documentation - Spying on real objects] for more details on Spy partial mocks.  In either of those situations a Spy of the object is preferable.  Using `@InjectSpy`, the previous example could be written as follows:"
msgstr "有时在测试时，你只需要验证某个逻辑路径，或者你只需要存根出一个方法的响应，同时仍然执行Spied clone上的其他方法。关于Spy部分模拟的更多细节，请参见 link:https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html#spy-T-[Mockito文档] 。在这两种情况下，一个对象的Spy是最好的。使用 `@InjectSpy` ，前面的例子可以写成如下。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:960
#, no-wrap
msgid ""
"@QuarkusTest\n"
"public class SpyGreetingServiceTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:963
#, no-wrap
msgid ""
"    @InjectSpy\n"
"    GreetingService greetingService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:971
#, no-wrap
msgid ""
"    @Test\n"
"    public void testDefaultGreeting() {\n"
"        given()\n"
"                .when().get(\"/greeting\")\n"
"                .then()\n"
"                .statusCode(200)\n"
"                .body(is(\"hello\"));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:974
#, no-wrap
msgid ""
"        Mockito.verify(greetingService, Mockito.times(1)).greet(); <1>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:984
#, no-wrap
msgid ""
"    @Test\n"
"    public void testOverrideGreeting() {\n"
"        doReturn(\"hi\").when(greetingService).greet(); <2>\n"
"        given()\n"
"                .when().get(\"/greeting\")\n"
"                .then()\n"
"                .statusCode(200)\n"
"                .body(is(\"hi\")); <3>\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1010
#, fuzzy
msgid "Instead of overriding the value, we just want to ensure that the greet method on our `GreetingService` was called by this test."
msgstr "我们没有重写这个值，而只是想确保我们的 `GreetingService` 上的greet方法被这个测试调用。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1011
#, fuzzy
msgid "Here we are telling the Spy to return \"hi\" instead of \"hello\". When the `GreetingResource` requests the greeting from `GreetingService` we get the mocked response instead of the response of the regular `GreetingService` bean. Sometimes it's impossible or impractical to use `when(Object)` for stubbing spies. Therefore when using spies please consider `doReturn|Answer|Throw()` family of methods for stubbing."
msgstr "这里我们告诉Spy返回 \"hi \"而不是 \"hello\"。当 `GreetingResource` 向 `GreetingService` 请求问候时，我们得到的是模拟的响应，而不是普通 `GreetingService` Bean的响应。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1012
#, fuzzy
msgid "We are verifying that we get the mocked response from the Spy."
msgstr "我们正在验证，我们从间谍那里得到了模拟的响应。"

#. type: Title ====
#: upstream/_guides/getting-started-testing.adoc:1013
#, fuzzy, no-wrap
msgid "Using `@InjectMock` with `@RestClient`"
msgstr "使用 `@InjectMock` 与 `@RestClient` "

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1016
#, fuzzy
msgid "The `@RegisterRestClient` registers the implementation of the rest-client at runtime, and because the bean needs to be a regular scope, you have to annotate your interface with `@ApplicationScoped`."
msgstr " `@RegisterRestClient` 在运行时注册了rest-client的实现，由于bean需要是一个常规的范围，你必须用 `@ApplicationScoped` 来注释你的接口。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1023
#, no-wrap
msgid ""
"@Path(\"/\")\n"
"@ApplicationScoped\n"
"@RegisterRestClient\n"
"public interface GreetingService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1029
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/hello\")\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    String hello();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1032
#, fuzzy
msgid "For the test class here is an example:"
msgstr "对于测试类，这里有一个例子。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1041
#, no-wrap
msgid ""
"    @InjectMock\n"
"    @RestClient // <1>\n"
"    GreetingService greetingService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1045
#, no-wrap
msgid ""
"    @Test\n"
"    public void testHelloEndpoint() {\n"
"        Mockito.when(greetingService.hello()).thenReturn(\"hello from mockito\");\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1052
#, no-wrap
msgid ""
"        given()\n"
"          .when().get(\"/hello\")\n"
"          .then()\n"
"             .statusCode(200)\n"
"             .body(is(\"hello from mockito\"));\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1056
#, fuzzy
msgid "Indicate that this injection point is meant to use an instance of `RestClient`."
msgstr "表示这个注入点是为了使用 `RestClient` 的实例。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:1057
#, fuzzy, no-wrap
msgid "Mocking with Panache"
msgstr "潇洒的嘲讽"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1060
#, fuzzy
msgid "If you are using the `quarkus-hibernate-orm-panache` or `quarkus-mongodb-panache` extensions, check out the xref:hibernate-orm-panache.adoc#mocking[Hibernate ORM with Panache Mocking] and xref:mongodb-panache.adoc#mocking[MongoDB with Panache Mocking] documentation for the easiest way to mock your data access."
msgstr "如果你使用 `quarkus-hibernate-orm-panache` 或 `quarkus-mongodb-panache` 扩展，请查看 link:hibernate-orm-panache.html#mocking[Hibernate ORM with Panache Mocking] 和 link:mongodb-panache.html#mocking[MongoDB with Panache Mocking] 文档，以了解模拟数据访问的最简单方法。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:1061
#, fuzzy, no-wrap
msgid "Testing Security"
msgstr "测试安全性"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1064
#, fuzzy
msgid "If you are using Quarkus Security, check out the xref:security-testing.adoc[Testing Security] section for information on how to easily test security features of the application."
msgstr "如果你正在使用Quarkus Security，请查看 link:security-testing.html[测试安全] 部分，了解如何轻松测试应用程序的安全功能。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:1066
#, fuzzy, no-wrap
msgid "Starting services before the Quarkus application starts"
msgstr "在Quarkus应用程序启动之前启动服务"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1069
#, fuzzy
msgid "A very common need is to start some services on which your Quarkus application depends, before the Quarkus application starts for testing. To address this need, Quarkus provides `@io.quarkus.test.common.QuarkusTestResource` and `io.quarkus.test.common.QuarkusTestResourceLifecycleManager`."
msgstr "一个非常常见的需求是在Quarkus应用程序启动测试之前，启动一些你的Quarkus应用程序所依赖的服务。为了解决这个需求，Quarkus提供了 `@io.quarkus.test.common.QuarkusTestResource` 和 `io.quarkus.test.common.QuarkusTestResourceLifecycleManager` 。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1072
#, fuzzy
msgid "By simply annotating any test in the test suite with `@QuarkusTestResource`, Quarkus will run the corresponding `QuarkusTestResourceLifecycleManager` before any tests are run.  A test suite is also free to utilize multiple `@QuarkusTestResource` annotations, in which case all the corresponding `QuarkusTestResourceLifecycleManager` objects will be run before the tests. When using multiple test resources they can be started concurrently. For that you need to set `@QuarkusTestResource(parallel = true)`."
msgstr "通过简单地在测试套件中用 `@QuarkusTestResource` 注释任何测试，Quarkus将在任何测试运行之前运行相应的 `QuarkusTestResourceLifecycleManager` 。一个测试套件也可以自由地利用多个 `@QuarkusTestResource` 注释，在这种情况下，所有相应的 `QuarkusTestResourceLifecycleManager` 对象将在测试前运行。当使用多个测试资源时，它们可以同时启动。为此，你需要设置 `@QuarkusTestResource(parallel = true)` 。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1075
#, fuzzy
msgid "Test resources are global, even if they are defined on a test class or custom profile, which means they will all be activated for all tests, even though we do remove duplicates. If you want to only enable a test resource on a single test class or test profile, you can use `@QuarkusTestResource(restrictToAnnotatedClass = true)`."
msgstr "测试资源是全局性的，即使它们被定义在一个测试类或自定义配置文件上，这意味着它们将全部被激活用于所有的测试，尽管我们确实删除了重复的测试。如果你想只在一个测试类或测试配置文件上启用一个测试资源，你可以使用 `@QuarkusTestResource(restrictToAnnotatedClass = true)` 。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1080
#, fuzzy
msgid "Quarkus provides a few implementations of `QuarkusTestResourceLifecycleManager` out of the box (see `io.quarkus.test.h2.H2DatabaseTestResource` which starts an H2 database, or `io.quarkus.test.kubernetes.client.KubernetesServerTestResource` which starts a mock Kubernetes API server), but it is common to create custom implementations to address specific application needs.  Common cases include starting docker containers using https://www.testcontainers.org/[Testcontainers] (an example of which can be found https://github.com/quarkusio/quarkus/blob/main/test-framework/keycloak-server/src/main/java/io/quarkus/test/keycloak/server/KeycloakTestResourceLifecycleManager.java[here]), or starting a mock HTTP server using https://wiremock.org/[Wiremock] (an example of which can be found https://github.com/geoand/quarkus-test-demo/blob/main/src/test/java/org/acme/getting/started/country/WiremockCountries.java[here])."
msgstr "Quarkus提供了一些开箱即用的 `QuarkusTestResourceLifecycleManager` （见 `io.quarkus.test.h2.H2DatabaseTestResource` ，它启动了一个H2数据库，或 `io.quarkus.test.kubernetes.client.KubernetesServerTestResource` ，它启动了一个模拟的Kubernetes API服务器），但创建自定义的实现以满足特定的应用需求是很常见的。常见的情况包括使用 link:https://www.testcontainers.org/[Testcontainers] 启动docker容器（例子 link:https://github.com/quarkusio/quarkus/blob/main/test-framework/keycloak-server/src/main/java/io/quarkus/test/keycloak/server/KeycloakTestResourceLifecycleManager.java[见这里] ），或使用 link:http://wiremock.org/[Wiremock] 启动一个模拟的HTTP服务器（例子 link:https://github.com/geoand/quarkus-test-demo/blob/main/src/test/java/org/acme/getting/started/country/WiremockCountries.java[见这里] ）。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:1082
#, fuzzy, no-wrap
msgid "Altering the test class"
msgstr "改动测试类"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1085
#, fuzzy
msgid "When creating a custom `QuarkusTestResourceLifecycleManager` that needs to inject the something into the test class, the `inject` methods can be used.  If for example you have a test like the following:"
msgstr "当创建一个自定义的 `QuarkusTestResourceLifecycleManager` ，需要将东西注入测试类时，可以使用 `inject` 方法。例如，如果你有一个像下面这样的测试。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1091
#, no-wrap
msgid ""
"@QuarkusTest\n"
"@QuarkusTestResource(MyWireMockResource.class)\n"
"public class MyTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1094
#, no-wrap
msgid ""
"    @InjectWireMock // this a custom annotation you are defining in your own application\n"
"    WireMockServer wireMockServer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1100
#, no-wrap
msgid ""
"    @Test\n"
"    public someTest() {\n"
"        // control wiremock in some way and perform test\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1103
#, fuzzy
msgid "Making `MyWireMockResource` inject the `wireMockServer` field can be done as shown in the `inject` method of the following code snippet:"
msgstr "使 `MyWireMockResource` 注入 `wireMockServer` 字段，可按以下代码片断中的 `inject` 方法进行。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1107
#, no-wrap
msgid "public class MyWireMockResource implements QuarkusTestResourceLifecycleManager {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1109
#, no-wrap
msgid "    WireMockServer wireMockServer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1114
#, no-wrap
msgid ""
"    @Override\n"
"    public Map<String, String> start() {\n"
"        wireMockServer = new WireMockServer(8090);\n"
"        wireMockServer.start();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1116
#, no-wrap
msgid "        // create some stubs\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1119
#, no-wrap
msgid ""
"        return Map.of(\"some.service.url\", \"localhost:\" + wireMockServer.port());\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1127
#, no-wrap
msgid ""
"    @Override\n"
"    public synchronized void stop() {\n"
"        if (wireMockServer != null) {\n"
"            wireMockServer.stop();\n"
"            wireMockServer = null;\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1133
#, no-wrap
msgid ""
"    @Override\n"
"    public void inject(TestInjector testInjector) {\n"
"        testInjector.injectIntoFields(wireMockServer, new TestInjector.AnnotatedAndMatchesType(InjectWireMock.class, WireMockServer.class));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1137
#, fuzzy
msgid "It is worth mentioning that this injection into the test class is not under the control of CDI and happens after CDI has performed any necessary injections into the test class."
msgstr "值得一提的是，这种对测试类的注入并不在CDI的控制之下，而是发生在CDI对测试类进行了任何必要的注入之后。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:1138
#, fuzzy, no-wrap
msgid "Annotation-based test resources"
msgstr "基于注释的测试资源"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1142
#, fuzzy
msgid "It is possible to write test resources that are enabled and configured using annotations. This is enabled by placing the `@QuarkusTestResource` on an annotation which will be used to enable and configure the test resource."
msgstr "可以编写使用注解来启用和配置的测试资源。这可以通过将 `@QuarkusTestResource` 在一个注解上启用，该注解将被用来启用和配置测试资源。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1145
#, fuzzy
msgid "For example, this defines the `@WithKubernetesTestServer` annotation, which you can use on your tests to activate the `KubernetesServerTestResource`, but only for the annotated test class. You can also place them on your `QuarkusTestProfile` test profiles."
msgstr "例如，这定义了 `@WithKubernetesTestServer` 注释，你可以在你的测试上使用它来激活 `KubernetesServerTestResource` ，但只针对被注释的测试类。你也可以把它们放在你的 `QuarkusTestProfile` 测试配置文件上。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1156
#, no-wrap
msgid ""
"@QuarkusTestResource(KubernetesServerTestResource.class)\n"
"@Retention(RetentionPolicy.RUNTIME)\n"
"@Target(ElementType.TYPE)\n"
"public @interface WithKubernetesTestServer {\n"
"    /**\n"
"     * Start it with HTTPS\n"
"     */\n"
"    boolean https() default false;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1161
#, no-wrap
msgid ""
"    /**\n"
"     * Start it in CRUD mode\n"
"     */\n"
"    boolean crud() default true;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1167
#, no-wrap
msgid ""
"    /**\n"
"     * Port to use, defaults to any available port\n"
"     */\n"
"    int port() default 0;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1171
#, fuzzy
msgid "The `KubernetesServerTestResource` class has to implement the `QuarkusTestResourceConfigurableLifecycleManager` interface in order to be configured using the previous annotation:"
msgstr " `KubernetesServerTestResource` 类必须实现 `QuarkusTestResourceConfigurableLifecycleManager` 接口，以便使用前面的注释进行配置。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1176
#, no-wrap
msgid ""
"public class KubernetesServerTestResource\n"
"        implements QuarkusTestResourceConfigurableLifecycleManager<WithKubernetesTestServer> {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1180
#, no-wrap
msgid ""
"    private boolean https = false;\n"
"    private boolean crud = true;\n"
"    private int port = 0;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1187
#, no-wrap
msgid ""
"    @Override\n"
"    public void init(WithKubernetesTestServer annotation) {\n"
"        this.https = annotation.https();\n"
"        this.crud = annotation.crud();\n"
"        this.port = annotation.port();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1190
#, no-wrap
msgid ""
"    // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1194
#, fuzzy
msgid "If you want to make the annotation repeatable, the containing annotation type must be annotated with `@QuarkusTestResourceRepeatable`.  For example, this would define a repeatable `@WithRepeatableTestResource` annotation."
msgstr "如果你想让注解可重复，包含的注解类型必须用 `@QuarkusTestResourceRepeatable` 。例如，这将定义一个可重复的 `@WithRepeatableTestResource` 注释。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1202
#, no-wrap
msgid ""
"@QuarkusTestResource(KubernetesServerTestResource.class)\n"
"@Retention(RetentionPolicy.RUNTIME)\n"
"@Target(ElementType.TYPE)\n"
"@Repeatable(WithRepeatableTestResource.List.class)\n"
"public @interface WithRepeatableTestResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1204
#, no-wrap
msgid "    String key() default \"\";\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1212
#, no-wrap
msgid ""
"    @Target(ElementType.TYPE)\n"
"    @Retention(RetentionPolicy.RUNTIME)\n"
"    @QuarkusTestResourceRepeatable(WithRepeatableTestResource.class)\n"
"    @interface List {\n"
"        WithRepeatableTestResource[] value();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:1216
#, fuzzy, no-wrap
msgid "Hang Detection"
msgstr "悬挂检测"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1221
#, fuzzy
msgid "`@QuarkusTest` has support for hang detection to help diagnose any unexpected hangs. If no progress is made for a specified time (i.e. no JUnit callbacks are invoked) then Quarkus will print a stack trace to the console to help diagnose the hang.  The default value for this timeout is 10 minutes."
msgstr " `@QuarkusTest` 支持挂起检测，以帮助诊断任何意外的挂起。如果在指定的时间内没有进展（即没有调用JUnit回调），那么Quarkus将打印一个堆栈跟踪到控制台以帮助诊断挂起。这个超时的默认值是10分钟。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1226
#, fuzzy
msgid "No further action will be taken, and the tests will continue as normal (generally until CI times out), however the printed stack traces should help diagnose why the build has failed. You can control this timeout with the `quarkus.test.hang-detection-timeout` system property (you can also set this in application.properties, but this won't be read until Quarkus has started, so the timeout for Quarkus start will be the default of 10 minutes)."
msgstr "将不会采取进一步的行动，测试将继续正常进行（通常直到CI超时），但是打印出来的堆栈痕迹应该有助于诊断为什么构建失败了。你可以用 `quarkus.test.hang-detection-timeout` 系统属性来控制这个超时（你也可以在application.properties中设置这个，但是在Quarkus启动之前不会被读取，所以Quarkus启动的超时将是默认的10分钟）。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:1227
#, fuzzy, no-wrap
msgid "Native Executable Testing"
msgstr "原生可执行程序测试"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1231
#, fuzzy
msgid "It is also possible to test native executables using `@QuarkusIntegrationTest`. This supports all the features mentioned in this guide except injecting into tests (and the native executable runs in a separate non-JVM process this is not really possible)."
msgstr "也可以使用 `@QuarkusIntegrationTest` 来测试本地可执行文件。这支持本指南中提到的所有功能，除了注入测试（本地可执行文件在一个单独的非JVM进程中运行，这实际上是不可能的）。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1234
#, fuzzy
msgid "This is covered in the xref:building-native-image.adoc[Native Executable Guide]."
msgstr "这在《 link:building-native-image.html[本地可执行文件指南》] 中有所涉及。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:1236
#, fuzzy, no-wrap
msgid "Using `@QuarkusIntegrationTest`"
msgstr "使用@QuarkusIntegrationTest"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1243
#, fuzzy
msgid "`@QuarkusIntegrationTest` should be used to launch and test the artifact produced by the Quarkus build, and supports testing a jar (of whichever type), a native image or container image.  Put simply, this means that if the result of a Quarkus build (`mvn package` or `gradle build`) is a jar, that jar will be launched as `java -jar ...` and tests run against it.  If instead a native image was built, then the application is launched as `./application ...` and again the tests run against the running application.  Finally, if a container image was created during the build (by including the `quarkus-container-image-jib` or `quarkus-container-image-docker` extensions and having the `quarkus.container-image.build=true` property configured), then a container is created and run (this requires the `docker` executable being present)."
msgstr " `@QuarkusIntegrationTest` 应该被用来启动和测试由Quarkus构建产生的工件，并支持测试一个jar（无论哪种类型），一个本地镜像或容器镜像。简单地说，这意味着如果Quarkus构建的结果（ 或 ）是一个jar，这个jar将被启动为 ，并针对它运行测试。如果构建的是一个本地镜像，那么应用程序将以 的形式启动，并再次针对运行中的应用程序进行测试。最后，如果在构建过程中创建了一个容器镜像（通过包括 或 扩展并配置了 属性），那么将创建并运行一个容器（这需要 可执行文件的存在）。 `mvn package` `gradle build` `java -jar ??` `./application ??` `quarkus-container-image-jib` `quarkus-container-image-docker` `quarkus.container-image.build=true` `docker` "

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1245
#, fuzzy
msgid "This is a black box test that supports the same set features and has the same limitations."
msgstr "如同 `@NativeImageTest` ，这是一个黑盒测试，支持相同的集合功能，具有相同的限制。"

#. type: delimited block =
#: upstream/_guides/getting-started-testing.adoc:1250
#, fuzzy
msgid "As a test annotated with `@QuarkusIntegrationTest` tests the result of the build, it should be run as part of the integration test suite - i.e. by setting `-DskipITs=false` if using Maven or the `quarkusIntTest` task if using Gradle.  These tests will **not** work if run in the same phase as `@QuarkusTest` as Quarkus has not yet created the final artifact."
msgstr "由于用 `@QuarkusIntegrationTest` 注释的测试是对构建结果的测试，它应该作为集成测试套件的一部分来运行--即如果使用Maven，则通过 `maven-failsafe-plugin` ，如果使用Gradle，则通过 `quarkusIntTest` 任务。如果与 `@QuarkusTest` 在同一阶段运行，这些测试将 *无法* 工作，因为Quarkus还没有创建最终的工件。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1253
#, fuzzy
msgid "The `pom.xml` file contains:"
msgstr " `pom.xml` 文件包含。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1276
#, no-wrap
msgid ""
"<plugin>\n"
"    <groupId>org.apache.maven.plugins</groupId>\n"
"    <artifactId>maven-failsafe-plugin</artifactId>\n"
"    <version>${surefire-plugin.version}</version>\n"
"    <executions>\n"
"        <execution>\n"
"            <goals>\n"
"                <goal>integration-test</goal>\n"
"                <goal>verify</goal>\n"
"            </goals>\n"
"            <configuration>\n"
"                <systemPropertyVariables>\n"
"                    <native.image.path>${project.build.directory}/${project.build.finalName}-runner</native.image.path>\n"
"                    <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>\n"
"                    <maven.home>${maven.home}</maven.home>\n"
"                </systemPropertyVariables>\n"
"            </configuration>\n"
"        </execution>\n"
"    </executions>\n"
"</plugin>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1279
#, fuzzy
msgid "This instructs the failsafe-maven-plugin to run integration-test."
msgstr "这将指示 failsafe-maven-plugin 运行集成测试。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1281
#, fuzzy
msgid "Then, open the `src/test/java/org/acme/quickstart/GreetingResourceIT.java`. It contains:"
msgstr "然后，打开 `src/test/java/org/acme/quickstart/GreetingResourceIT.java` 。它包含了。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1285
#, no-wrap
msgid "package org.acme.quickstart;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1288
#, fuzzy, no-wrap
msgid "import io.quarkus.test.junit.QuarkusIntegrationTest;\n"
msgstr " `io.quarkus.test.junit.callback.QuarkusTestAfterConstructCallback` "

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1291
#, no-wrap
msgid ""
"@QuarkusIntegrationTest // <1>\n"
"public class GreetingResourceIT extends GreetingResourceTest { // <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1293
#, no-wrap
msgid "    // Run the same tests\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1298
#, fuzzy
msgid "Use another test runner that starts the application from the native file before the tests.  The executable is retrieved by the _Failsafe Maven Plugin_."
msgstr "使用另一个测试运行器，在测试前从本地文件启动应用程序。该可执行文件由 _Failsafe Maven插件_ 检索。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1299
#, fuzzy
msgid "We extend our previous tests as a convenience, but you can also implement your tests."
msgstr "为了方便起见，我们扩展了以前的测试，但你也可以实现你的测试。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1301
#, fuzzy
msgid "More information can be found in the link:building-native-image#testing-the-native-executable[Testing the native executable Guide]."
msgstr "更多信息可以在《 link:building-native-image#testing-the-native-executable[测试本地可执行文件指南》] 中找到。"

#. type: delimited block =
#: upstream/_guides/getting-started-testing.adoc:1305
#, fuzzy
msgid "When the application is tested using `@QuarkusIntegrationTest` it is launched using the `prod` configuration profile, but this can be changed using the `quarkus.test.integration-test-profile` property."
msgstr "当使用 `@QuarkusIntegrationTest` 测试应用程序时，它是使用 `prod` 配置文件启动的，但这可以使用 `quarkus.test.integration-test-profile` 属性来改变。"

#. type: delimited block =
#: upstream/_guides/getting-started-testing.adoc:1311
msgid "While adding test-specific configuration properties using `src/test/resources/application.properties` (note there's `test`, not `main`)  is possible for unit tests, it's not possible for integration tests."
msgstr ""

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:1313
#, fuzzy, no-wrap
msgid "Launching containers"
msgstr "启动容器"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1318
#, fuzzy
msgid "When `@QuarkusIntegrationTest` results in launching a container (because the application was built with `quarkus.container-image.build` set to `true`), the container is launched on a predictable container network. This facilitates writing integration tests that need to launch services to support the application.  This means that `@QuarkusIntegrationTest` works out of the box with containers launched via xref:dev-services.adoc[Dev Services], but it also means that it enables using xref:quarkus-test-resource[QuarkusTestLifecycleManager] resources that launch additional containers.  This can be achieved by having your `QuarkusTestLifecycleManager` implement `io.quarkus.test.common.DevServicesContext.ContextAware`. A simple example could be the following:"
msgstr "当 `@QuarkusIntegrationTest` 的结果是启动一个容器时（因为应用程序在构建时将 `quarkus.container-image.build` 设置为 `true` ），该容器会在一个可预测的容器网络上启动。这有利于编写需要启动服务以支持应用程序的集成测试。这意味着 `@QuarkusIntegrationTest` 在开箱时就能与通过 link:dev-services.html[Dev Services] 启动的容器一起工作，但这也意味着它能够使用 link:#quarkus-test-resource[QuarkusTestLifecycleManager] 资源来启动额外的容器。这可以通过让你的 `QuarkusTestLifecycleManager` 实现 `io.quarkus.test.common.DevServicesContext.ContextAware` 来实现。一个简单的例子可以是这样的。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1322
#, fuzzy
msgid "The container running the resource to test against, for example PostgreSQL via Testcontainers, is assigned an IP address from the container's network.  Use the container's \"public\" IP from its network and the \"unmapped\" port number to connect to the service.  The Testcontainers library usually return connection strings without respecting the container network, so additional code is needed to provide Quarkus the \"correct\" connection string using the container's IP on the container network and the _unmapped_ port number."
msgstr "运行要测试的资源的容器，例如通过Testcontainers的PostgreSQL，会从容器的网络中分配一个IP地址。使用容器网络中的 \"公共 \"IP和 \"未映射 \"的端口号来连接到服务。Testcontainers库通常在不尊重容器网络的情况下返回连接字符串，因此需要额外的代码来为Quarkus提供 \"正确的 \"连接字符串，使用容器网络中的IP和 _未映射_ 的端口号。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1324
#, fuzzy
msgid "The following example illustrates the use with PostgreSQL, but the approach is applicable to all containers."
msgstr "下面的例子说明了在PostgreSQL上的使用，但这个方法适用于所有的容器。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1329
#, no-wrap
msgid ""
"import io.quarkus.test.common.DevServicesContext;\n"
"import io.quarkus.test.common.QuarkusTestResourceLifecycleManager;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1332
#, no-wrap
msgid ""
"import org.testcontainers.containers.JdbcDatabaseContainer;\n"
"import org.testcontainers.containers.PostgreSQLContainer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1336
#, no-wrap
msgid ""
"import java.util.HashMap;\n"
"import java.util.Map;\n"
"import java.util.Optional;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1338
#, no-wrap
msgid "public class CustomResource implements QuarkusTestResourceLifecycleManager, DevServicesContext.ContextAware {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1341
#, no-wrap
msgid ""
"    private Optional<String> containerNetworkId;\n"
"    private JdbcDatabaseContainer container;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1346
#, no-wrap
msgid ""
"    @Override\n"
"    public void setIntegrationTestContext(DevServicesContext context) {\n"
"        containerNetworkId = context.containerNetworkId();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1351
#, no-wrap
msgid ""
"    @Override\n"
"    public Map<String, String> start() {\n"
"        // start a container making sure to call withNetworkMode() with the value of containerNetworkId if present\n"
"        container = new PostgreSQLContainer<>(\"postgres:latest\").withLogConsumer(outputFrame -> {});\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1354
#, no-wrap
msgid ""
"        // apply the network to the container\n"
"        containerNetworkId.ifPresent(container::withNetworkMode);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1357
#, no-wrap
msgid ""
"        // start container before retrieving its URL or other properties\n"
"        container.start();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1364
#, no-wrap
msgid ""
"        String jdbcUrl = container.getJdbcUrl();\n"
"        if (containerNetworkId.isPresent()) {\n"
"            // Replace hostname + port in the provided JDBC URL with the hostname of the Docker container\n"
"            // running PostgreSQL and the listening port.\n"
"            jdbcUrl = fixJdbcUrl(jdbcUrl);\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1371
#, no-wrap
msgid ""
"        // return a map containing the configuration the application needs to use the service\n"
"        return ImmutableMap.of(\n"
"            \"quarkus.datasource.username\", container.getUsername(),\n"
"            \"quarkus.datasource.password\", container.getPassword(),\n"
"            \"quarkus.datasource.jdbc.url\", jdbcUrl);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1375
#, no-wrap
msgid ""
"    private String fixJdbcUrl(String jdbcUrl) {\n"
"        // Part of the JDBC URL to replace\n"
"        String hostPort = container.getHost() + ':' + container.getMappedPort(PostgreSQLContainer.POSTGRESQL_PORT);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1381
#, no-wrap
msgid ""
"        // Host/IP on the container network plus the unmapped port\n"
"        String networkHostPort =\n"
"            container.getCurrentContainerInfo().getConfig().getHostName()\n"
"            + ':'\n"
"            + PostgreSQLContainer.POSTGRESQL_PORT;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1384
#, no-wrap
msgid ""
"        return jdbcUrl.replace(hostPort, networkHostPort);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1390
#, no-wrap
msgid ""
"    @Override\n"
"    public void stop() {\n"
"        // close container\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1393
#, fuzzy
msgid "`CustomResource` would be activated on a `@QuarkusIntegrationTest` using `@QuarkusTestResource` as is described in the corresponding section of this doc."
msgstr " `CustomResource` 将在 上使用 激活，如本文件相应部分所述。 `@QuarkusIntegrationTest` `@QuarkusTestResource` "

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:1394
#, fuzzy, no-wrap
msgid "Executing against a running application"
msgstr "对正在运行的应用程序进行执行"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1398
#, fuzzy
msgid "`@QuarkusIntegrationTest` supports executing tests against an already running instance of the application. This can be achieved by setting the `quarkus.http.test-host` system property when running the tests."
msgstr " `@QuarkusIntegrationTest` 支持针对已经运行的应用程序的实例执行测试。这可以通过在运行测试时设置 系统属性来实现。 `quarkus.http.test-host` "

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1400
#, fuzzy
msgid "An example use of this could be the following Maven command, that forces `@QuarkusIntegrationTest` to execute against that is accessible at `http://1.2.3.4:4321`:"
msgstr "这方面的一个例子是下面的Maven命令，该命令强制 `@QuarkusIntegrationTest` ，以对可访问的网站进行执行。 `<a href=\"http://1.2.3.4:4321\" class=\"bare\">http://1.2.3.4:4321</a>` :"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1404
#, no-wrap
msgid "./mvnw verify -Dquarkus.http.test-host=1.2.3.4 -Dquarkus.http.test-port=4321\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1407
msgid "To test against a running instance that only accepts SSL/TLS connection (example: `https://1.2.3.4:4321`) set the system property `quarkus.http.test-ssl-enabled` to `true`."
msgstr ""

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:1408
#, fuzzy, no-wrap
msgid "Mixing `@QuarkusTest` with other type of tests"
msgstr "将 `@QuarkusTest` 与其他类型的测试相混合"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1413
#, fuzzy
msgid "Mixing tests annotated with `@QuarkusTest` with tests annotated with either `@QuarkusDevModeTest`, `@QuarkusProdModeTest` or `@QuarkusUnitTest` is not allowed in a single execution run (in a single Maven Surefire Plugin execution, for instance), while the latter three can coexist."
msgstr "在一次执行运行中（例如在一次Maven Surefire Plugin执行中），不允许将注释为 `@QuarkusTest` 的测试与注释为 `@QuarkusDevModeTest` 、 `@QuarkusProdModeTest` 或 `@QuarkusUnitTest` 的测试混合在一起，而后三者可以共存。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1416
#, fuzzy
msgid "The reason of this restriction is that `@QuarkusTest` starts a Quarkus server for the whole lifetime of the tests execution run, thus preventing the other tests to start their own Quarkus server."
msgstr "这个限制的原因是 `@QuarkusTest` ，在测试执行的整个过程中启动一个Quarkus服务器，从而防止其他测试启动自己的Quarkus服务器。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1419
#, fuzzy
msgid "To alleviate this restriction, the `@QuarkusTest` annotation defines a JUnit 5 `@Tag`: `io.quarkus.test.junit.QuarkusTest`.  You can use this tag to isolate the `@QuarkusTest` test in a specific execution run, for example with the Maven Surefire Plugin:"
msgstr "为缓解这一限制， `@QuarkusTest` 注解定义了一个 JUnit 5 `@Tag` : `io.quarkus.test.junit.QuarkusTest` 。您可以使用该标记在特定的执行运行中隔离 `@QuarkusTest` 测试，例如使用Maven Surefire插件。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1451
#, no-wrap
msgid ""
"<plugin>\n"
"    <artifactId>maven-surefire-plugin</artifactId>\n"
"    <version>${surefire-plugin.version}</version>\n"
"    <executions>\n"
"        <execution>\n"
"            <id>default-test</id>\n"
"            <goals>\n"
"                <goal>test</goal>\n"
"            </goals>\n"
"            <configuration>\n"
"                <excludedGroups>io.quarkus.test.junit.QuarkusTest</excludedGroups>\n"
"            </configuration>\n"
"        </execution>\n"
"        <execution>\n"
"            <id>quarkus-test</id>\n"
"            <goals>\n"
"                <goal>test</goal>\n"
"            </goals>\n"
"            <configuration>\n"
"                <groups>io.quarkus.test.junit.QuarkusTest</groups>\n"
"            </configuration>\n"
"        </execution>\n"
"    </executions>\n"
"    <configuration>\n"
"        <systemProperties>\n"
"            <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>\n"
"        </systemProperties>\n"
"    </configuration>\n"
"</plugin>\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:1454
#, fuzzy, no-wrap
msgid "Running `@QuarkusTest` from an IDE"
msgstr "从IDE中运行 `@QuarkusTest` "

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1457
#, fuzzy
msgid "Most IDEs offer the possibility to run a selected class as a JUnit test directly. For this you should set a few properties in the settings of your chosen IDE:"
msgstr "大多数IDE都提供了将选定的类直接作为JUnit测试运行的可能性。为此，你应该在你选择的IDE的设置中设置一些属性。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1459
#, fuzzy
msgid "`java.util.logging.manager` (see xref:logging.adoc[Logging Guide])"
msgstr " `java.util.logging.manager` (见 link:logging.html[日志指南] )"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1461
#, fuzzy
msgid "`maven.home` (only if there are any custom settings in `${maven.home}/conf/settings.xml`, see xref:maven-tooling.adoc[Maven Guide])"
msgstr " `maven.home` (仅当 中有任何自定义设置时，见 `${maven.home}/conf/settings.xml` link:maven-tooling.html[Maven指南] )"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1463
#, fuzzy
msgid "`maven.settings` (in case a custom version of `settings.xml` file should be used for the tests)"
msgstr " `maven.settings` (以备在测试中使用自定义版本的 文件) `settings.xml` "

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:1464
#, fuzzy, no-wrap
msgid "Eclipse separate JRE definition"
msgstr "Eclipse独立的JRE定义"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1467
#, fuzzy
msgid "Copy your current \"Installed JRE\" definition into a new one, where you will add the properties as a new VM arguments:"
msgstr "将你当前的 \"已安装的JRE \"定义复制到一个新的定义中，在这里你将把属性作为一个新的虚拟机参数加入。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1469
#, fuzzy
msgid "`-Djava.util.logging.manager=org.jboss.logmanager.LogManager`"
msgstr " `-Djava.util.logging.manager=org.jboss.logmanager.LogManager` "

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1471
#, fuzzy
msgid "`-Dmaven.home=<path-to-your-maven-installation>`"
msgstr " `-Dmaven.home=<path-to-your-maven-installation>` "

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1473
#, fuzzy
msgid "Use this JRE definition as your Quarkus project targeted runtime and the workaround will be applied to any \"Run as JUnit\" configuration."
msgstr "使用这个JRE定义作为你的Quarkus项目的目标运行时，工作方法将被应用于任何 \"作为JUnit运行 \"的配置。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:1474
#, fuzzy, no-wrap
msgid "VSCode \"run with\" configuration"
msgstr "VSCode \"运行 \"配置"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1477
#, fuzzy
msgid "The `settings.json` placed in the root of your project directory or in the workspace will need the following workaround in your test configuration:"
msgstr "放在你的项目目录根部或工作区的 `settings.json` ，在你的测试配置中需要以下工作方法。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1487
#, no-wrap
msgid ""
"\"java.test.config\": [\n"
"    {\n"
"        \"name\": \"quarkusConfiguration\",\n"
"        \"vmargs\": [ \"-Djava.util.logging.manager=org.jboss.logmanager.LogManager -Dmaven.home=<path-to-your-maven-installation> ...\" ],\n"
"        ...\n"
"    },\n"
"  ...\n"
"]\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:1489
#, fuzzy, no-wrap
msgid "IntelliJ IDEA JUnit template"
msgstr "IntelliJ JUnit模板"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1492
#, fuzzy
msgid "Nothing needed in IntelliJ IDEA because the IDE will pick the `systemPropertyVariables` from the surefire plugin configuration in `pom.xml`."
msgstr "在IntelliJ中不需要，因为IDE会从 `pom.xml` 中的surefire插件配置中挑选 `systemPropertyVariables` 。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:1493
#, fuzzy, no-wrap
msgid "Testing Dev Services"
msgstr "测试开发服务"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1497
#, fuzzy
msgid "By default, tests should just work with xref:dev-services.adoc[Dev Services], however from some use cases you may need access to the automatically configured properties in your tests."
msgstr "默认情况下，测试应该只是与 link:dev-services.html[开发服务] 一起工作，然而从一些用例来看，你可能需要访问你的测试中自动配置的属性。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1502
#, fuzzy
msgid "You can do this with `io.quarkus.test.common.DevServicesContext`, which can be injected directly into any `@QuarkusTest` or `@QuarkusIntegrationTest`. All you need to do is define a field of type `DevServicesContext` and it will be automatically injected. Using this you can retrieve any properties that have been set. Generally this is used to directly connect to a resource from the test itself, e.g. to connect to kafka to send messages to the application under test."
msgstr "你可以用 `io.quarkus.test.common.DevServicesContext` ，它可以直接注入到任何 `@QuarkusTest` 或 `@QuarkusIntegrationTest` 。你所需要做的就是定义一个类型为 `DevServicesContext` 的字段，它将被自动注入。使用这个，你可以检索任何已经设置的属性。一般来说，这被用来直接连接到测试本身的资源，例如，连接到kafka来发送消息到被测试的应用程序。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1507
#, fuzzy
msgid "Injection is also supported into objects that implement `io.quarkus.test.common.DevServicesContext.ContextAware`. If you have a field that implements `io.quarkus.test.common.DevServicesContext.ContextAware` Quarkus will call the `setIntegrationTestContext` method to pass the context into this object. This allows client logic to be encapsulated in a utility class."
msgstr "注入也被支持到实现 `io.quarkus.test.common.DevServicesContext.ContextAware` 的对象中。如果你有一个实现了 `io.quarkus.test.common.DevServicesContext.ContextAware` 的字段，Quarkus将调用 `setIntegrationTestContext` 方法，将上下文传入这个对象。这使得客户端逻辑可以被封装在一个实用类中。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1510
#, fuzzy
msgid "`QuarkusTestResourceLifecycleManager` implementations can also implement `ContextAware` to get access to these properties, which allows you to set up the resource before Quarkus starts (e.g. configure a KeyCloak instance, add data to a database etc)."
msgstr " `QuarkusTestResourceLifecycleManager` 实现也可以实现 ，以获得对这些属性的访问，这允许你在Quarkus启动之前设置资源（例如，配置一个KeyCloak实例，向数据库添加数据等）。 `ContextAware` "

#. type: delimited block =
#: upstream/_guides/getting-started-testing.adoc:1516
#, fuzzy
msgid "For `@QuarkusIntegrationTest` tests that result in launcher the application as a container, `io.quarkus.test.common.DevServicesContext` also provides access to the id of the container network on which the application container was launched (via the `containerNetworkId` method).  This can be used by `QuarkusTestResourceLifecycleManager` that need to launch additional containers that the application will communicate with."
msgstr "对于 `@QuarkusIntegrationTest` 测试，结果是将应用程序作为一个容器启动， `io.quarkus.test.common.DevServicesContext` 也提供了对容器网络ID的访问，应用程序容器是在这个网络上启动的（通过 `containerNetworkId` 方法）。这可以被需要启动应用程序将与之通信的其他容器的 `QuarkusTestResourceLifecycleManager` 所使用。"

#. type: Title ==
#: upstream/_guides/getting-started-testing.adoc:1518
#, fuzzy, no-wrap
msgid "Testing Components"
msgstr "测试组件"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1521
#, fuzzy
msgid "This feature is experimental and the API may change in the future."
msgstr "这个功能被认为是实验性的，在未来的Quarkus版本中可能会发生变化。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1525
#, fuzzy
msgid "In Quarkus, the component model is built on top CDI.  Therefore, Quarkus provides the `QuarkusComponentTestExtension`, a JUnit extension to ease the testing of components and mocking of their dependencies.  This extension is available in the `quarkus-junit5-component` dependency."
msgstr "在Quarkus中，组件模型是建立在CDI之上的。因此，Quarkus提供了 `QuarkusComponentTestExtension` ，一个JUnit扩展来简化组件的测试和对其依赖关系的嘲弄。这个扩展可以在 `quarkus-junit5-component` 依赖关系中找到。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1527
#, fuzzy
msgid "Let's have a component `Foo`:"
msgstr "让我们有一个组件 `Foo` ："

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1531
#, no-wrap
msgid "package org.acme;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1534
#, no-wrap
msgid ""
"import jakarta.enterprise.context.ApplicationScoped;\n"
"import jakarta.inject.Inject;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1537
#, no-wrap
msgid ""
"@ApplicationScoped <1>\n"
"public class Foo {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1540
#, no-wrap
msgid ""
"    @Inject\n"
"    Charlie charlie; <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1543
#, no-wrap
msgid ""
"    @ConfigProperty(name = \"bar\")\n"
"    boolean bar; <3>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1548
#, no-wrap
msgid ""
"    public String ping() {\n"
"        return bar ? charlie.ping() : \"nok\";\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1550
#, fuzzy
msgid "`Foo` is an `@ApplicationScoped` CDI bean."
msgstr " `Foo` 是一个 CDI豆。 `@ApplicationScoped` "

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1551
#, fuzzy
msgid "`Foo` depends on `Charlie` which declares a method `ping()`."
msgstr " `Foo` 依赖于 ，它声明了一个方法 。 `Charlie` `ping()` "

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1552
#, fuzzy
msgid "`Foo` depends on the config property `bar`."
msgstr " `Foo` 取决于配置属性 。 `bar` "

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1554
#, fuzzy
msgid "Then a component test could look like:"
msgstr "一个例子的用法可能是这样的。"

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1558
#: upstream/_guides/getting-started-testing.adoc:1595
#: upstream/_guides/getting-started-testing.adoc:1661
#: upstream/_guides/getting-started-testing.adoc:1710
#, no-wrap
msgid "import static org.junit.jupiter.api.Assertions.assertEquals;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1565
#, no-wrap
msgid ""
"import jakarta.inject.Inject;\n"
"import io.quarkus.test.InjectMock;\n"
"import io.quarkus.test.component.TestConfigProperty;\n"
"import io.quarkus.test.component.QuarkusComponentTest;\n"
"import org.junit.jupiter.api.Test;\n"
"import org.mockito.Mockito;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1569
#, no-wrap
msgid ""
"@QuarkusComponentTest <1>\n"
"@TestConfigProperty(key = \"bar\", value = \"true\") <2>\n"
"public class FooTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1572
#, no-wrap
msgid ""
"    @Inject\n"
"    Foo foo; <3>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1575
#, no-wrap
msgid ""
"    @InjectMock\n"
"    Charlie charlieMock; <4>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1582
#, no-wrap
msgid ""
"    @Test\n"
"    public void testPing() {\n"
"        Mockito.when(charlieMock.ping()).thenReturn(\"OK\"); <5>\n"
"        assertEquals(\"OK\", foo.ping());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1584
#, fuzzy
msgid "The `QuarkusComponentTest` annotation registers the JUnit extension."
msgstr " `QuarkusComponentTest` 注解注册了JUnit扩展。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1585
#, fuzzy
msgid "Sets a configuration property for the test."
msgstr "为测试设置一个配置属性。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1586
#, fuzzy
msgid "The test injects the component under the test. The types of all fields annotated with `@Inject` are considered the component types under test. You can also specify additional component classes via `@QuarkusComponentTest#value()`. Furthermore, the static nested classes declared on the test class are components too."
msgstr "该测试注入被测试的组件。所有用 `@Inject` 注释的字段的类型都被认为是被测组件的类型。你也可以通过 `@QuarkusComponentTest#value()` ，指定额外的组件类型。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1587
#, fuzzy
msgid "The test also injects `Charlie`, a dependency for which a synthetic `@Singleton` bean is registered automatically. The injected reference is an \"unconfigured\" Mockito mock."
msgstr "该测试还注入了 `Charlie` ，这是一个依赖关系，一个合成的 `@Singleton` bean被自动注册。注入的引用是一个 \"未配置的 \"Mockito模拟。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1588
#, fuzzy
msgid "We can leverage the Mockito API in a test method to configure the behavior."
msgstr "我们可以在一个测试方法中利用Mockito API来配置行为。"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1591
#, fuzzy
msgid "If you need the full control over the `QuarkusComponentTestExtension` configuration then you can use the `@RegisterExtension` annotation and configure the extension programatically.  The test above could be rewritten like:"
msgstr "如果你需要对 `QuarkusComponentTestExtension` 配置的完全控制，那么你可以使用 `@RegisterExtension` 注释并以编程方式配置扩展。上面的测试可以改写成这样："

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1601
#, no-wrap
msgid ""
"import jakarta.inject.Inject;\n"
"import io.quarkus.test.InjectMock;\n"
"import io.quarkus.test.component.QuarkusComponentTestExtension;\n"
"import org.junit.jupiter.api.Test;\n"
"import org.mockito.Mockito;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1603
#, no-wrap
msgid "public class FooTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1606
#, no-wrap
msgid ""
"    @RegisterExtension <1>\n"
"    static final QuarkusComponentTestExtension extension = QuarkusComponentTestExtension.builder().configProperty(\"bar\",\"true\").build();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1609
#: upstream/_guides/getting-started-testing.adoc:1671
#: upstream/_guides/getting-started-testing.adoc:1720
#, no-wrap
msgid ""
"    @Inject\n"
"    Foo foo;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1612
#, no-wrap
msgid ""
"    @InjectMock\n"
"    Charlie charlieMock;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1619
#, no-wrap
msgid ""
"    @Test\n"
"    public void testPing() {\n"
"        Mockito.when(charlieMock.ping()).thenReturn(\"OK\");\n"
"        assertEquals(\"OK\", foo.ping());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1621
#, fuzzy
msgid "The `QuarkusComponentTestExtension` is configured in a static field of the test class."
msgstr " `QuarkusComponentTestExtension` ，配置在一个静态字段中。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:1622
#, fuzzy, no-wrap
msgid "Lifecycle"
msgstr "生命周期"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1630
#, fuzzy
msgid "So what exactly does the `QuarkusComponentTest` do? It starts the CDI container and registers a dedicated xref:config-reference.adoc[configuration object].  If the test instance lifecycle is `Lifecycle#PER_METHOD` (default) then the container is started during the `before each` test phase and stopped during the `after each` test phase.  However, if the test instance lifecycle is `Lifecycle#PER_CLASS` then the container is started during the `before all` test phase and stopped during the `after all` test phase.  The fields annotated with `@Inject` and `@InjectMock` are injected after a test instance is created.  Finally, the CDI request context is activated and terminated per each test method."
msgstr "那么， `QuarkusComponentTest` 到底是做什么的呢？在 `before all` 测试阶段，它启动CDI容器并注册一个专用的 link:config-reference.html[配置对象] 。在 `after all` 测试阶段，容器被停止，配置被释放。用 `@Inject` 和 `@InjectMock` 注解的字段在测试实例创建后被注入，并在测试实例销毁前取消设置。最后，CDI请求上下文在每个测试方法中被激活和终止。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:1631
#, fuzzy, no-wrap
msgid "Auto Mocking Unsatisfied Dependencies"
msgstr "自动嘲弄不满足的依赖关系"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1638
#, fuzzy
msgid "Unlike in regular CDI environments the test does not fail if a component injects an unsatisfied dependency.  Instead, a synthetic bean is registered automatically for each combination of required type and qualifiers of an injection point that resolves to an unsatisfied dependency.  The bean has the `@Singleton` scope so it's shared across all injection points with the same required type and qualifiers.  The injected reference is an _unconfigured_ Mockito mock.  You can inject the mock in your test and leverage the Mockito API to configure the behavior."
msgstr "与常规的CDI环境不同，如果一个组件注入了一个不满足的依赖关系，测试就不会失败。相反，一个合成的Bean会被自动注册，以满足注入点的每一个所需类型和限定条件的组合，并解析为一个不满足的依赖关系。这个Bean有 `@Singleton` 范围，所以它在所有具有相同要求类型和限定符的注入点中共享。注入的引用是一个 _未配置的_ Mockito mock。你可以在你的测试中注入这个模拟，并利用Mockito的API来配置行为。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:1639
#, fuzzy, no-wrap
msgid "Custom Mocks For Unsatisfied Dependencies"
msgstr "为不满足的依赖关系定制Mocks"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1643
#, fuzzy
msgid "Sometimes you need the full control over the bean attributes and maybe even configure the default mock behavior.  You can use the mock configurator API via the `QuarkusComponentTestExtensionBuilder#mock()` method."
msgstr "有时你需要完全控制bean的属性，甚至需要配置默认的mock行为。你可以通过 `QuarkusComponentTestExtension#mock()` 方法使用模拟配置器的API。"

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:1644
#, fuzzy, no-wrap
msgid "Configuration"
msgstr "配置"

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1648
msgid "You can set the configuration properties for a test with the `@io.quarkus.test.component.TestConfigProperty` annotation or with the `QuarkusComponentTestExtensionBuilder#configProperty(String, String)` method.  If you only need to use the default values for missing config properties, then the `@QuarkusComponentTest#useDefaultConfigProperties()` or `QuarkusComponentTestExtensionBuilder#useDefaultConfigProperties()` might come in useful."
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1651
msgid "It is also possible to set configuration properties for a test method with the `@io.quarkus.test.component.TestConfigProperty` annotation.  However, if the test instance lifecycle is `Lifecycle#_PER_CLASS` this annotation can only be used on the test class and is ignored on test methods."
msgstr ""

#. type: Title ===
#: upstream/_guides/getting-started-testing.adoc:1652
#, no-wrap
msgid "Mocking CDI Interceptors"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1657
msgid "If a tested component class declares an interceptor binding then you might need to mock the interception too.  There are two ways to accomplish this task.  First, you can define an interceptor class as a static nested class of the test class."
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1665
#: upstream/_guides/getting-started-testing.adoc:1714
#, no-wrap
msgid ""
"import jakarta.inject.Inject;\n"
"import io.quarkus.test.component.QuarkusComponentTest;\n"
"import org.junit.jupiter.api.Test;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1668
#: upstream/_guides/getting-started-testing.adoc:1717
#, no-wrap
msgid ""
"@QuarkusComponentTest\n"
"public class FooTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1676
#: upstream/_guides/getting-started-testing.adoc:1725
#, no-wrap
msgid ""
"    @Test\n"
"    public void testPing() {\n"
"        assertEquals(\"OK\", foo.ping());\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1679
#: upstream/_guides/getting-started-testing.adoc:1734
#, no-wrap
msgid ""
"    @ApplicationScoped\n"
"    static class Foo {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1684
#: upstream/_guides/getting-started-testing.adoc:1739
#, no-wrap
msgid ""
"       @SimpleBinding <1>\n"
"       String ping() {\n"
"         return \"ok\";\n"
"       }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1690
#, no-wrap
msgid ""
"    @SimpleBinding\n"
"    @Interceptor\n"
"    static class SimpleInterceptor { <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1695
#, no-wrap
msgid ""
"        @AroundInvoke\n"
"        Object aroundInvoke(InvocationContext context) throws Exception {\n"
"            return context.proceed().toString().toUpperCase();\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1698
#: upstream/_guides/getting-started-testing.adoc:1742
#, no-wrap
msgid ""
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1700
msgid "`@SimpleBinding` is an interceptor binding."
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1701
msgid "The interceptor class is automatically considered a tested component."
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1703
msgid "Static nested classed declared on a test class that is annotated with `@QuarkusComponentTest` are excluded from bean discovery when running a `@QuarkusTest` in order to prevent unintentional CDI conflicts."
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1706
msgid "Furthermore, you can also declare a \"test interceptor method\" directly on the test class.  This method is then invoked in the relevant interception phase."
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-testing.adoc:1731
#, no-wrap
msgid ""
"    @SimpleBinding <1>\n"
"    @AroundInvoke <2>\n"
"    Object aroundInvoke(InvocationContext context) throws Exception {\n"
"       return context.proceed().toString().toUpperCase();\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1744
msgid "The interceptor bindings of the resulting interceptor are specified by annotating the method with the interceptor binding types."
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-testing.adoc:1744
msgid "Defines the interception type."
msgstr ""

#, fuzzy
#~ msgid "By default, a new test instance is created for each test method. Therefore, a new CDI container is started for each test method. However, if the test class is annotated with `@org.junit.jupiter.api.TestInstance` and the test instance lifecycle is set to `org.junit.jupiter.api.TestInstance.Lifecycle.PER_CLASS` then the CDI container will be shared across all test method executions of a given test class."
#~ msgstr "默认情况下，每个测试方法都会创建一个新的测试实例。因此，每个测试方法都会启动一个新的CDI容器。然而，如果测试类被注释为 `@org.junit.jupiter.api.TestInstance` ，并且测试实例的生命周期被设置为 `org.junit.jupiter.api.TestInstance.Lifecycle.PER_CLASS` ，那么CDI容器将在给定测试类的所有测试方法执行中被共享。"

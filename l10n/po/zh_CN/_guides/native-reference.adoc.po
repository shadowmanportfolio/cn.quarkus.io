# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-04-26 15:09+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/native-reference.adoc:6
#, fuzzy, no-wrap
msgid "Native Reference Guide"
msgstr "本地参考指南"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:19
#, fuzzy
msgid "This guide is a companion to the xref:building-native-image.adoc[Building a Native Executable], xref:native-and-ssl.adoc[Using SSL With Native Images], and xref:writing-native-applications-tips.adoc[Writing Native Applications], guides.  It explores advanced topics that help users diagnose issues, increase the reliability and improve the runtime performance of native executables.  These are the high level sections to be found in this guide:"
msgstr "本指南是《 link:building-native-image.html[构建本地可执行文件] 》、《 link:native-and-ssl.html[使用本地图像的SSL] 》和《 link:writing-native-applications-tips.html[编写本地应用程序] 》指南的补充。它为调试Quarkus本地可执行文件中可能在开发或生产中出现的问题提供了进一步的细节。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:21
#, fuzzy
msgid "xref:native-memory-management[Native Memory Management]"
msgstr "link:#native-memory-management[本地内存管理]"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:22
#, fuzzy
msgid "xref:inspecting-and-debugging[Inspecting and Debugging Native Executables]"
msgstr "link:#inspecting-and-debugging[检查和调试本地可执行文件]"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:23
#, fuzzy
msgid "xref:native-faq[Frequently Asked Questions]"
msgstr "常见问题"

#. type: Title ==
#: upstream/_guides/native-reference.adoc:25
#, fuzzy, no-wrap
msgid "Native Memory Management"
msgstr "本地内存管理"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:30
#, fuzzy
msgid "Memory management for Quarkus native executables is enabled by GraalVM’s SubstrateVM runtime system.  The memory management component in GraalVM is explained in detail link:https://www.graalvm.org/{graalvm-version}/reference-manual/native-image/optimizations-and-performance/MemoryManagement[here].  This guide complements the information available in the GraalVM website with further observations particularly relevant to Quarkus applications."
msgstr "Quarkus本地可执行文件的内存管理由GraalVM的SubstrateVM运行时系统启用。GraalVM中的内存管理组件在 link:https://www.graalvm.org/{graalvm-version}/reference-manual/native-image/optimizations-and-performance/MemoryManagement[这里] 有详细解释。本指南补充了GraalVM网站上的信息，特别是与Quarkus应用程序相关的进一步观察。"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:31
#, fuzzy, no-wrap
msgid "Garbage Collectors"
msgstr "垃圾收集器"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:33
#, fuzzy
msgid "The garbage collectors available for Quarkus users are currently Serial GC and Epsilon GC."
msgstr "目前Quarkus用户可用的垃圾收集器是Serial GC和Epsilon GC。"

#. type: Title ====
#: upstream/_guides/native-reference.adoc:34
#, fuzzy, no-wrap
msgid "Serial GC"
msgstr "串行GC"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:38
#, fuzzy
msgid "Serial GC, the default option in GraalVM and Quarkus, is a single-threaded non-concurrent GC, just like HotSpot’s Serial GC.  The implementation in GraalVM however is different from the HotSpot one, and there can be significant differences in the runtime behavior."
msgstr "串行GC是GraalVM和Quarkus的默认选项，是一个单线程的非并发GC，就像HotSpot的串行GC。然而，GraalVM中的实现与HotSpot中的实现不同，在运行时的行为上会有很大的差异。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:49
#, fuzzy
msgid "One of the key differences between HotSpot’s Serial GC and GraalVM’s Serial GC is the way they perform full GC cycles.  In HotSpot the algorithm used is mark-sweep-compact whereas in GraalVM it is mark-copy.  Both need to traverse all live objects, but in mark-copy this traversal is also used to copy live objects to a secondary space or semi-space.  As objects are copied from one semi-space to another they’re also compacted.  In mark-sweep-compact, the compacting requires a second pass on the live objects.  This makes full GCs in mark-copy more time efficient (in terms of time spent in each GC cycle) than mark-sweep-compact.  The tradeoff mark-copy makes in order to make individual full GC cycles shorter is space.  The use of semi-spaces means that for an application to maintain the same GC performance that mark-sweep achieves (in terms of allocated MB per second), it requires double the amount of memory."
msgstr "HotSpot的串行GC和GraalVM的串行GC之间的关键区别之一是它们执行完整GC循环的方式。在HotSpot中，使用的算法是mark-sweep-compact，而在GraalVM中是mark-copy。两者都需要遍历所有活着的对象，但在mark-copy中，这种遍历也被用来将活着的对象复制到一个二级空间或半空间。当对象从一个半空间被复制到另一个半空间时，它们也被压缩了。在mark-sweep-compact中，压缩需要对活的对象进行第二次处理。这使得mark-copy中的完全GC比mark-sweep-compact更省时（就每个GC周期花费的时间而言）。为了使单个完整的GC周期更短，mark-copy做出的权衡是空间。半空间的使用意味着，对于一个应用程序来说，要保持mark-sweep所达到的相同的GC性能（以每秒分配的MB计算），它需要双倍的内存量。"

#. type: Title =====
#: upstream/_guides/native-reference.adoc:50
#, fuzzy, no-wrap
msgid "GC Collection Policy"
msgstr "采集政策"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:53
#, fuzzy
msgid "GraalVM's Serial GC implementation offers a choice between two different collection policies, the default is called \"adaptive\" and the alternative is called \"space/time\"."
msgstr "GraalVM的串行GC实现提供了两种不同的收集策略的选择，默认的是 \"自适应\"，另一种是 \"空间/时间\"。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:57
#, fuzzy
msgid "The “adaptive” collection policy is based on HotSpot's ParallelGC adaptive size policy.  The main difference with HotSpot is GraalVM's focus on memory footprint.  This means that GraalVM’s adaptive GC policy tries to aggressively trigger GCs in order to keep memory consumption down."
msgstr "\"自适应 \"收集策略是基于HotSpot的ParallelGC自适应大小策略。与HotSpot的主要区别在于GraalVM对内存占用的关注。这意味着GraalVM的自适应GC策略试图积极地触发GC，以减少内存消耗。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:65
#, fuzzy
msgid "Up to version 2.13, Quarkus used the “space/time” GC collection policy by default, but starting with version 2.14, it switched to using the “adaptive” policy instead.  The reason why Quarkus initially chose to use \"space/time\" is because at that time it had considerable performance improvements over \"adaptive\".  Recent performance experiments, however, indicate that the \"space/time\" policy can result in worse out-of-the-box experience compared to the \"adaptive\" policy, while at the same time the benefits it used to offer have diminished considerably after improvements made to the \"adaptive\" policy.  As a result, the \"adaptive\" policy appears to be the best option for most, if not all, Quarkus applications.  Full details on this switch can be read in link:https://github.com/quarkusio/quarkus/issues/28267[this issue]."
msgstr "到2.13版本为止，Quarkus默认使用 \"空间/时间 \"的GC收集策略。GC收集策略，但从2.14版开始，它转而使用 \"自适应 \"策略。Quarkus最初选择使用 \"space/time \"的原因是在当时它比 \"adaptive \"有相当大的性能改进。然而，最近的性能实验表明，与 \"空间/时间 \"策略相比，\"空间/时间 \"策略可能导致更差的开箱即用体验，同时，在对 \"自适应 \"策略进行改进后，它曾经提供的好处也大大减少了。因此，\"自适应 \"策略似乎是大多数（如果不是全部）Quarkus应用程序的最佳选择。关于这一转换的全部细节可在 link:https://github.com/quarkusio/quarkus/issues/28267[本期] 中阅读。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:68
#, fuzzy
msgid "It is still possible to change the GC collection policy using GraalVM’s `-H:InitialCollectionPolicy` flag.  Switching to the \"space/time\" policy can be done by passing the following via command line:"
msgstr "仍然可以使用GraalVM的 `-H:InitialCollectionPolicy` 标志来改变GC收集策略。切换到 \"空间/时间 \"策略，可以通过命令行传递以下内容来完成。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:72
#, no-wrap
msgid "-Dquarkus.native.additional-build-args=-H:InitialCollectionPolicy=com.oracle.svm.core.genscavenge.CollectionPolicy\\$BySpaceAndTime\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:75
#, fuzzy
msgid "Or adding this to the `application.properties` file:"
msgstr "或将此添加到 `application.properties` 文件中。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:79
#, no-wrap
msgid "quarkus.native.additional-build-args=-H:InitialCollectionPolicy=com.oracle.svm.core.genscavenge.CollectionPolicy$BySpaceAndTime\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:85
#, fuzzy
msgid "Escaping the `$` character is required to configure the \"space/time\" GC collection policy if passing via command line in Bash.  Other command line environments might have similar requirements."
msgstr "如果在Bash中通过命令行传递，在配置 \"空间/时间 \"GC收集策略时需要转义 `$` 字符。其他命令行环境可能有类似的要求。"

#. type: Title ====
#: upstream/_guides/native-reference.adoc:87
#, fuzzy, no-wrap
msgid "Epsilon GC"
msgstr "埃普西隆GC"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:91
#, fuzzy
msgid "Epsilon GC is a no-op garbage collector which does not do any memory reclamation.  From a Quarkus perspective, some of the most relevant use cases for this garbage collector are extremely short-lived jobs, e.g. serverless functions.  To build Quarkus native with epsilon GC, pass the following argument at build time:"
msgstr "Epsilon GC是一个无操作的垃圾收集器，不做任何内存回收。从Quarkus的角度来看，这种垃圾收集器的一些最相关的用例是时间极短的作业，例如无服务器函数。要使用epsilon GC构建Quarkus native，在构建时要传递以下参数。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:95
#, no-wrap
msgid "-Dquarkus.native.additional-build-args=--gc=epsilon\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/native-reference.adoc:97
#, fuzzy, no-wrap
msgid "Memory Management Options"
msgstr "内存管理选项"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:101
#, fuzzy
msgid "Options to control maximum heap size, young space and other typical use cases found in the JVM can be found in https://www.graalvm.org/{graalvm-version}/reference-manual/native-image/optimizations-and-performance/MemoryManagement[the GraalVM memory management guide].  Setting the maximum heap size, either as a percentage or an explicit value, is generally recommended."
msgstr "控制最大堆大小、年轻空间和其他在JVM中发现的典型使用情况的选项可以在 link:https://www.graalvm.org/{graalvm-version}/reference-manual/native-image/optimizations-and-performance/MemoryManagement[GraalVM内存管理指南] 中找到。通常建议将最大堆大小设置为百分比或明确的值。"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:103
#, fuzzy, no-wrap
msgid "GC Logging"
msgstr "GC记录"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:106
#, fuzzy
msgid "Multiple options exist to print information about garbage collection cycles, depending on the level of detail required.  The minimum detail is provided `-XX:+PrintGC`, which prints a message for each GC cycle that occurs:"
msgstr "在打印垃圾收集周期的信息方面存在多种选择，取决于所需的详细程度。最小的细节是提供 `-XX:+PrintGC` ，它为每个发生的GC周期打印一条信息。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:113
#, no-wrap
msgid ""
"$ quarkus-project-0.1-SNAPSHOT-runner -XX:+PrintGC -Xmx64m\n"
"...\n"
"[Incremental GC (CollectOnAllocation) 20480K->11264K, 0.0003223 secs]\n"
"[Full GC (CollectOnAllocation) 19456K->5120K, 0.0031067 secs]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:118
#, fuzzy
msgid "When you combine this option with `-XX:+VerboseGC` you still get a message per GC cycle, but it contains extra information.  Also, adding this option shows the sizing decisions made by the GC algorithm at startup:"
msgstr "当你把这个选项和 `-XX:+VerboseGC` ，你仍然会在每个GC周期得到一条信息，但它包含了额外的信息。另外，加入这个选项可以显示GC算法在启动时做出的大小决定。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:137
#, no-wrap
msgid ""
"$ quarkus-project-0.1-SNAPSHOT-runner -XX:+PrintGC -XX:+VerboseGC -Xmx64m\n"
"[Heap policy parameters:\n"
"YoungGenerationSize: 25165824\n"
"MaximumHeapSize: 67108864\n"
"MinimumHeapSize: 33554432\n"
"AlignedChunkSize: 1048576\n"
"LargeArrayThreshold: 131072]\n"
"...\n"
"[[5378479783321 GC: before  epoch: 8  cause: CollectOnAllocation]\n"
"[Incremental GC (CollectOnAllocation) 16384K->9216K, 0.0003847 secs]\n"
"[5378480179046 GC: after   epoch: 8  cause: CollectOnAllocation  policy: adaptive  type: incremental\n"
"collection time: 384755 nanoSeconds]]\n"
"[[5379294042918 GC: before  epoch: 9  cause: CollectOnAllocation]\n"
"[Full GC (CollectOnAllocation) 17408K->5120K, 0.0030556 secs]\n"
"[5379297109195 GC: after   epoch: 9  cause: CollectOnAllocation  policy: adaptive  type: complete\n"
"collection time: 3055697 nanoSeconds]]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:140
#, fuzzy
msgid "Beyond these two options, `-XX:+PrintHeapShape` and `-XX:+TraceHeapChunks` provide even lower level details about memory chunks on top of which the different memory regions are constructed."
msgstr "在这两个选项之外， `-XX:+PrintHeapShape` 和 `-XX:+TraceHeapChunks` 提供了关于内存块的更低层次的细节，不同的内存区域在此基础上被构建。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:142
#, fuzzy
msgid "The most up-to-date information on GC logging flags can be obtained by printing the list of flags that can be passed to native executables:"
msgstr "关于GC日志标志的最新信息，可以通过打印可传递给本地可执行文件的标志列表来获得。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:155
#, no-wrap
msgid ""
"$ quarkus-project-0.1-SNAPSHOT-runner -XX:PrintFlags=\n"
"...\n"
"  -XX:±PrintGC                                 Print summary GC information after each collection. Default: - (disabled).\n"
"  -XX:±PrintGCSummary                          Print summary GC information after application main method returns. Default: - (disabled).\n"
"  -XX:±PrintGCTimeStamps                       Print a time stamp at each collection, if +PrintGC or +VerboseGC. Default: - (disabled).\n"
"  -XX:±PrintGCTimes                            Print the time for each of the phases of each collection, if +VerboseGC. Default: - (disabled).\n"
"  -XX:±PrintHeapShape                          Print the shape of the heap before and after each collection, if +VerboseGC. Default: - (disabled).\n"
"...\n"
"  -XX:±TraceHeapChunks                         Trace heap chunks during collections, if +VerboseGC and +PrintHeapShape. Default: - (disabled).\n"
"  -XX:±VerboseGC                               Print more information about the heap before and after each collection. Default: - (disabled).\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/native-reference.adoc:158
#, fuzzy, no-wrap
msgid "Resident Set Size (RSS)"
msgstr "驻地集尺寸（RSS）"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:165
#, fuzzy
msgid "As described in the xref:performance-measure.adoc[Measuring Performance guide], the footprint of Quarkus applications is measured using the resident set size (RSS).  This is also applicable to native applications, but the runtime engine that manages the footprint in this case is built in the native executable itself rather than the JVM."
msgstr "正如 link:performance-measure.html[衡量性能指南] 中所描述的，Quarkus应用程序的足迹是用常驻集大小（RSS）来衡量的。这也适用于本地应用程序，但在这种情况下，管理足迹的运行时引擎是建立在本地可执行文件本身而不是JVM中。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:170
#, fuzzy
msgid "The reporting techniques specified in the xref:performance-measure.adoc[Measuring Performance guide] are applicable to native applications too, but what causes the RSS to be higher or lower is specific to how the generated native executables work."
msgstr "link:performance-measure.html[衡量性能指南] 中规定的报告技术也适用于本地应用程序，但导致RSS升高或降低的原因是特定于生成的本地可执行文件的工作方式。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:173
#, fuzzy
msgid "When the RSS is higher in one native version of the application versus another, the following checks should be carried out first:"
msgstr "当RSS在一个本地版本的应用程序与另一个版本的应用程序中更高时，应首先进行以下检查："

#. type: Plain text
#: upstream/_guides/native-reference.adoc:177
#, fuzzy
msgid "Check the xref:native-reports[native build time reports] and see if there are big discrepancies in the number of used packages, used classes or used methods.  A bigger universe will result in bigger memory footprint."
msgstr "检查 link:#native-reports[本地构建时间报告] ，看看在使用的包、使用的类或使用的方法的数量上是否有很大差异。一个更大的宇宙将导致更大的内存占用。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:182
#, fuzzy
msgid "Check the size of the binary for differences.  Using `readelf` you can observe the size of different sections and compare them.  The `.text` section where code lives, and the `.svm_heap` section where heap produced at build time lives, are particularly interesting."
msgstr "检查二进制的大小是否有差异。使用 `readelf` ，你可以观察不同部分的大小并进行比较。代码所在的 `.text` 部分，以及构建时产生的堆所在的 `.svm_heap` 部分，特别有趣。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:183
#, fuzzy
msgid "Generate xref:heap-dumps[heap dumps] and inspect them with tools such as VisualVM or Eclipse MAT."
msgstr "生成 link:#heap-dumps[堆转储] 并使用VisualVM或Eclipse MAT等工具进行检查。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:191
#, fuzzy
msgid "Often profiling, instrumenting or tracing applications is the best way to figure out how things work.  In the case of RSS and native applications, the techniques that Brendan Gregg explains in the https://www.brendangregg.com/FlameGraphs/memoryflamegraphs.html[\"Memory Leak (and Growth) Flame Graphs\"] guide are particularly useful.  This section will apply the information in that article to show how to use `perf` and https://github.com/iovisor/bcc[bcc/eBPF] to understand what causes Quarkus native executables to consume memory on startup."
msgstr "通常情况下，剖析、检测或追踪应用程序是弄清事情如何运作的最好方法。就RSS和本地应用程序而言，Brendan Gregg在 link:https://www.brendangregg.com/FlameGraphs/memoryflamegraphs.html[\"内存泄漏（和增长）火焰图 \"] 指南中解释的技术特别有用。本节将应用那篇文章中的信息来展示如何使用 `perf` 和 link:https://github.com/iovisor/bcc[bcc/eBPF] 来了解是什么导致Quarkus本地可执行文件在启动时消耗内存。"

#. type: Title ====
#: upstream/_guides/native-reference.adoc:193
#, fuzzy, no-wrap
msgid "Perf"
msgstr "灌胶"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:198
#, fuzzy
msgid "`perf` works in older Linux systems, whereas eBPF requires a newer Linux kernel.  The overhead of `perf` is higher than eBPF, but it can understand stack traces generated with DWARF debug symbols, which eBPF can't."
msgstr " `perf` 在旧的Linux系统中工作，而eBPF需要一个较新的Linux内核。 的开销比eBPF高，但它能理解用DWARF调试符号产生的堆栈痕迹，而eBPF不能。 `perf` "

#. type: Plain text
#: upstream/_guides/native-reference.adoc:205
#, fuzzy
msgid "In the context of GraalVM, DWARF stack traces contain more detail and are easier to understand than those generated with frame pointers.  As first step, build a Quarkus native executable with debug info enabled and a couple of extra flags.  One flag to disable optimizations, and another to avoid inlined methods being omitted from the stack traces.  These two flags have been added to obtain stack traces that contain as much information as possible."
msgstr "在GraalVM的背景下，DWARF堆栈跟踪包含更多的细节，比用帧指针生成的堆栈跟踪更容易理解。作为第一步，建立一个Quarkus本地可执行文件，并启用调试信息和一些额外的标志。一个标志是禁用优化，另一个标志是避免堆栈跟踪中省略内联方法。添加这两个标志是为了获得包含尽可能多信息的堆栈跟踪。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:211
#, no-wrap
msgid ""
"$ mvn package -DskipTests -Dnative \\\n"
"  -Dquarkus.native.debug.enabled \\\n"
"  -Dquarkus.native.additional-build-args=-O0,-H:-OmitInlinedMethodDebugLineInfo\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:224
#, fuzzy
msgid "Disabling optimizations makes it easier to learn how to use `perf` and get as detailed stack traces as possible, because it shows more info about what gets called where.  However, doing so might lead to more allocations happening which would not happen if optimizations would have been applied.  In other words, passing in `-O0` will change the allocation pattens for many applications, because it disables optimizations such as escape analysis or dead code elimination.  To properly assess the allocations made by an application deployed in production, run with default optimizations (`-O2`).  With default optimizations the stack traces obtained with `perf` maybe be harder to decipher."
msgstr "禁用优化使我们更容易学习如何使用 `perf` ，并获得尽可能详细的堆栈跟踪，因为它显示了更多关于什么地方被调用的信息。然而，这样做可能会导致更多的分配发生，而如果应用了优化就不会发生。换句话说，传入 `-O0` ，将改变许多应用程序的分配模式，因为它禁用了诸如转义分析或死代码消除的优化。为了正确评估部署在生产中的应用程序所做的分配，请使用默认优化（ `-O2` ）运行。在默认优化下，用 `perf` 获得的堆栈痕迹可能更难解读。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:227
#, fuzzy
msgid "Let's measure how much RSS a Quarkus native executable takes on startup on this particular environment:"
msgstr "让我们测量一下Quarkus本地可执行文件在这个特定环境下启动时需要多少RSS："

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:233
#, no-wrap
msgid ""
"$ ps -o pid,rss,command -p $(pidof code-with-quarkus-1.0.0-SNAPSHOT-runner)\n"
"      PID   RSS COMMAND\n"
"     1915 35472 ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner -Xmx128m\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:252
#, fuzzy
msgid "How come this Quarkus native executable consumes ~35MB RSS on startup? To get an understanding of this number, this section will use `perf` to trace calls to `syscalls:sys_enter_mmap`.  Assuming the default https://www.graalvm.org/{graalvm-version}/reference-manual/native-image/MemoryManagement/#serial-garbage-collector[Serial Garbage Collector] is in use, this system call is particularly interesting for native executables generated by GraalVM's `native-image` because of how it allocates heap.  In native executables generated by GraalVM's `native-image`, the heap is allocated using either aligned or unaligned heap chunks.  All non-array objects get allocated in thread local aligned chunks.  Each of these are 1MB in size by default.  For arrays, if they are bigger than 1/8 of the aligned chunk size, they will be allocated in unaligned heap chunks which have a size dependant on the object itself.  The very first time a thread allocates an object or small array, it will request an aligned heap chunk that it will use exclusively until it has run out of space in that chunk, in which case it will request another aligned heap chunk.  So by tracing these system calls, the code paths that end up requesting new aligned or unaligned heap chunks will be recorded.  Next, run the Quarkus native executable through `perf record` tracing the `mmap` system call:"
msgstr "为什么这个Quarkus本地可执行文件在启动时要消耗~35MB的RSS？为了了解这个数字，本节将使用 `perf` 来追踪对 `syscalls:sys_enter_mmap` 的调用。假设使用的是默认的 link:https://www.graalvm.org/{graalvm-version}/reference-manual/native-image/MemoryManagement/#serial-garbage-collector[串行垃圾收集器] ，这个系统调用对于由GraalVM?的 `native-image` 生成的本地可执行文件特别有趣，因为它是如何分配堆的。在由GraalVM的 `native-image` 生成的本地可执行文件中，堆是使用对齐或未对齐的堆块分配的。所有非数组对象都被分配到线程本地的对齐块中。默认情况下，每个对象的大小为1MB。对于数组，如果它们大于对齐块大小的1/8，它们将被分配到无对齐堆块中，其大小取决于对象本身。当线程第一次分配一个对象或小数组时，它将请求一个对齐的堆块，它将专门使用这个堆块，直到它的空间用完，在这种情况下它将请求另一个对齐的堆块。因此，通过追踪这些系统调用，最终请求新的对齐或无对齐堆块的代码路径将被记录下来。接下来，通过 `perf record` 追踪 `mmap` 系统调用，运行Quarkus本地可执行文件："

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:256
#, no-wrap
msgid "$ sudo perf record -e syscalls:sys_enter_mmap --call-graph dwarf -a -- target/code-with-quarkus-1.0.0-SNAPSHOT-runner -Xmx128m\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:263
#, fuzzy
msgid "The size of the aligned heap chunks can be changed during native build time.  A custom value (in number of bytes) can be passed via the `-H:AlignedHeapChunkSize` flag.  One caveat is that this value needs to be multiple of 4096 (4KB)."
msgstr "对齐的堆块的大小可以在本地构建时改变。可以通过 `-H:AlignedHeapChunkSize` 标志传递一个自定义值（字节数）。有一点需要注意的是，这个值必须是4096（4KB）的倍数。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:266
#, fuzzy
msgid "Once the startup completes, stop the process and generate the stacks:"
msgstr "一旦启动完成，停止进程并生成堆栈："

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:270
#, no-wrap
msgid "$ perf script > out.stacks\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:275
#, fuzzy
msgid "As a final step, generate a https://github.com/brendangregg/FlameGraph[flamegraph] with the generated stacks:"
msgstr "作为最后一步，用生成的堆栈生成一个 link:https://github.com/brendangregg/FlameGraph[火焰图] ："

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:281
#, no-wrap
msgid ""
"$ export FG_HOME=...\n"
"$ ${FG_HOME}/stackcollapse-perf.pl < out.stacks | ${FG_HOME}/flamegraph.pl \\\n"
"    --color=mem --title=\"mmap Flame Graph\" --countname=\"calls\" > out.svg\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:284
#, fuzzy
msgid "The flamegraph should look similar to this:"
msgstr "火焰图应该与此相似："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_guides/native-reference.adoc:285
#, fuzzy, no-wrap
msgid "mmap flamegraph"
msgstr "制作并打开一个火焰图。"

#. type: Target for macro image
#: upstream/_guides/native-reference.adoc:285
#, no-wrap
msgid "mmap.svg"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:288
#, fuzzy
msgid "There are several things of interest to notice there:"
msgstr "那里有几件值得注意的事情："

#. type: Plain text
#: upstream/_guides/native-reference.adoc:293
#, fuzzy
msgid "First, the stack traces that contain method calls to `com.oracle.svm.core.genscavenge.ThreadLocalAllocation` are related to aligned or unaligned heap chunk allocations explained above.  As noted earlier, for the majority of allocations these chunks will be 1MB by default, so they're interesting because each allocated chunk has a considerable effect on the RSS consumption."
msgstr "首先，包含对 `com.oracle.svm.core.genscavenge.ThreadLocalAllocation` 的方法调用的堆栈痕迹与上面解释的对齐或不对齐的堆块分配有关。如前所述，对于大多数分配，这些块默认为1MB，所以它们很有趣，因为每个分配的块对RSS的消耗有相当大的影响。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:301
#, fuzzy
msgid "Second, of the thread allocation stacks, the ones under `start_thread` are particularly revealing.  In this environment, taking into account the `-Xmx` value passed in, Quarkus creates 12 event loop threads.  Aside from those, there are 6 extra threads.  The names of all those 18 threads exceed 16 characters.  This can be observed via the `ps` command:"
msgstr "其次，在线程分配栈中， `start_thread` 下的线程分配栈尤其具有启示意义。在这种环境下，考虑到传入的 `-Xmx` 值，Quarkus创建了12个事件循环线程。除了这些之外，还有6个额外的线程。所有这些18个线程的名称都超过了16个字符。这可以通过 `ps` 命令来观察："

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:323
#, no-wrap
msgid ""
"$ ps -e -T | grep $(pidof code-with-quarkus-1.0.0-SNAPSHOT-runner)\n"
"   2320    2320 pts/0    00:00:00 code-with-quark\n"
"   2320    2321 pts/0    00:00:00 ference Handler\n"
"   2320    2322 pts/0    00:00:00 gnal Dispatcher\n"
"   2320    2324 pts/0    00:00:00 ecutor-thread-0\n"
"   2320    2325 pts/0    00:00:00 -thread-checker\n"
"   2320    2326 pts/0    00:00:00 ntloop-thread-0\n"
"   2320    2327 pts/0    00:00:00 ntloop-thread-1\n"
"   2320    2328 pts/0    00:00:00 ntloop-thread-2\n"
"   2320    2329 pts/0    00:00:00 ntloop-thread-3\n"
"   2320    2330 pts/0    00:00:00 ntloop-thread-4\n"
"   2320    2331 pts/0    00:00:00 ntloop-thread-5\n"
"   2320    2332 pts/0    00:00:00 ntloop-thread-6\n"
"   2320    2333 pts/0    00:00:00 ntloop-thread-7\n"
"   2320    2334 pts/0    00:00:00 ntloop-thread-8\n"
"   2320    2335 pts/0    00:00:00 ntloop-thread-9\n"
"   2320    2336 pts/0    00:00:00 tloop-thread-10\n"
"   2320    2337 pts/0    00:00:00 tloop-thread-11\n"
"   2320    2338 pts/0    00:00:00 ceptor-thread-0\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:332
#, fuzzy
msgid "The very first allocation that all these threads do is taking the thread name and trimming it so that it can fall within the character limit enforced by kernels.  For each of those allocations, there are 2 `mmap` calls, one to reserve the memory and the other to commit it.  When recording `syscalls:sys_enter_mmap` system call, the `perf` implementation tracks calls to `__GI___mmap64`.  But this glibc `__GI___mmap64` implementation makes another call into `__GI___mmap64`:"
msgstr "所有这些线程所做的第一个分配是采取线程名称，并对其进行修剪，使其能够落在内核强制执行的字符限制之内。对于每一个分配，都有2个 `mmap` ，一个用于保留内存，另一个用于提交。在记录 `syscalls:sys_enter_mmap` 系统调用时， `perf` 实现跟踪对 `_GI_ _mmap64` .但这个glibc `_GI_ _mmap64` 的实现则是另一个调用到 `_GI_ _mmap64` :"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:362
#, no-wrap
msgid ""
"(gdb) break __GI___mmap64\n"
"(gdb) set scheduler-locking step\n"
"...\n"
"Thread 2 \"code-with-quark\" hit Breakpoint 1, __GI___mmap64 (offset=0, fd=-1, flags=16418, prot=0, len=2097152, addr=0x0) at ../sysdeps/unix/sysv/linux/mmap64.c:58\n"
"58\t  return (void *) MMAP_CALL (mmap, addr, len, prot, flags, fd, offset);\n"
"(gdb) bt\n"
"#0  __GI___mmap64 (offset=0, fd=-1, flags=16418, prot=0, len=2097152, addr=0x0) at ../sysdeps/unix/sysv/linux/mmap64.c:58\n"
"#1  __GI___mmap64 (addr=0x0, len=2097152, prot=0, flags=16418, fd=-1, offset=0) at ../sysdeps/unix/sysv/linux/mmap64.c:46\n"
"#2  0x00000000004f4033 in com.oracle.svm.core.posix.headers.Mman$NoTransitions::mmap (__0=<optimized out>, __1=<optimized out>, __2=<optimized out>, __3=<optimized out>, __4=<optimized out>, __5=<optimized out>)\n"
"#3  0x00000000004f194e in com.oracle.svm.core.posix.PosixVirtualMemoryProvider::reserve (this=0x7ffff7691220, nbytes=0x100000, alignment=0x100000, executable=false) at com/oracle/svm/core/posix/PosixVirtualMemoryProvider.java:126\n"
"#4  0x00000000004ef3b3 in com.oracle.svm.core.os.AbstractCommittedMemoryProvider::allocate (this=0x7ffff7658cb0, size=0x100000, alignment=0x100000, executable=false) at com/oracle/svm/core/os/AbstractCommittedMemoryProvider.java:124\n"
"#5  0x0000000000482f40 in com.oracle.svm.core.os.AbstractCommittedMemoryProvider::allocateAlignedChunk (this=0x7ffff7658cb0, nbytes=0x100000, alignment=0x100000) at com/oracle/svm/core/os/AbstractCommittedMemoryProvider.java:107\n"
"#6  com.oracle.svm.core.genscavenge.HeapChunkProvider::produceAlignedChunk (this=0x7ffff7444398) at com/oracle/svm/core/genscavenge/HeapChunkProvider.java:112\n"
"#7  0x0000000000489485 in com.oracle.svm.core.genscavenge.ThreadLocalAllocation::slowPathNewArrayLikeObject0 (hub=0x7ffff6ff6110, length=15, size=0x20, podReferenceMap=0x7ffff6700000) at com/oracle/svm/core/genscavenge/ThreadLocalAllocation.java:306\n"
"#8  0x0000000000489165 in com.oracle.svm.core.genscavenge.ThreadLocalAllocation::slowPathNewArrayLikeObject (objectHeader=0x8f6110 <io.smallrye.common.expression.ExpressionNode::toString+160>, length=15, podReferenceMap=0x7ffff6700000) at com/oracle/svm/core/genscavenge/ThreadLocalAllocation.java:279\n"
"#9  0x0000000000489066 in com.oracle.svm.core.genscavenge.ThreadLocalAllocation::slowPathNewArray (objectHeader=0x8f6110 <io.smallrye.common.expression.ExpressionNode::toString+160>, length=15) at com/oracle/svm/core/genscavenge/ThreadLocalAllocation.java:242\n"
"#10 0x0000000000d202a1 in java.util.Arrays::copyOfRange (original=0x7ffff6a33410, from=2, to=17) at java/util/Arrays.java:3819\n"
"#11 0x0000000000acf8e6 in java.lang.StringLatin1::newString (val=0x7ffff6a33410, index=2, len=15) at java/lang/StringLatin1.java:769\n"
"#12 0x0000000000acac59 in java.lang.String::substring (this=0x7ffff6dc0d48, beginIndex=2, endIndex=17) at java/lang/String.java:2712\n"
"#13 0x0000000000acaba2 in java.lang.String::substring (this=0x7ffff6dc0d48, beginIndex=2) at java/lang/String.java:2680\n"
"#14 0x00000000004f96cd in com.oracle.svm.core.posix.thread.PosixPlatformThreads::setNativeName (this=0x7ffff7658d10, thread=0x7ffff723fb30, name=0x7ffff6dc0d48) at com/oracle/svm/core/posix/thread/PosixPlatformThreads.java:163\n"
"#15 0x00000000004f9285 in com.oracle.svm.core.posix.thread.PosixPlatformThreads::beforeThreadRun (this=0x7ffff7658d10, thread=0x7ffff723fb30) at com/oracle/svm/core/posix/thread/PosixPlatformThreads.java:212\n"
"#16 0x00000000005237a2 in com.oracle.svm.core.thread.PlatformThreads::threadStartRoutine (threadHandle=0x1) at com/oracle/svm/core/thread/PlatformThreads.java:760\n"
"#17 0x00000000004f9627 in com.oracle.svm.core.posix.thread.PosixPlatformThreads::pthreadStartRoutine (data=0x2a06e20) at com/oracle/svm/core/posix/thread/PosixPlatformThreads.java:203\n"
"#18 0x0000000000462ab0 in com.oracle.svm.core.code.IsolateEnterStub::PosixPlatformThreads_pthreadStartRoutine_38d96cbc1a188a6051c29be1299afe681d67942e (__0=<optimized out>) at com/oracle/svm/core/code/IsolateEnterStub.java:1\n"
"#19 0x00007ffff7e4714d in start_thread (arg=<optimized out>) at pthread_create.c:442\n"
"#20 0x00007ffff7ec8950 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:368
#, fuzzy
msgid "Setting `set scheduler-locking step` when the Quarkus native executable is running through `gdb` makes it easier to debug multi-threaded applications.  It optimizes for single-stepping by stopping other threads from \"seizing the prompt\" by preempting the current thread is being stepped through."
msgstr "当Quarkus本地可执行文件通过 `gdb` 运行时，设置 `set scheduler-locking step` ，使其更容易调试多线程的应用程序。它通过阻止其他线程抢占当前线程的 \"提示 \"来优化单线程的运行。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:372
#, fuzzy
msgid "This is how the above flamegraph shows a total of 72 calls to `__GI___mmap64` for the thread name abbreviation stack trace, given that Quarkus native executable runs 18 threads."
msgstr "这就是上面的火焰图如何显示出总共有72次对 `_GI_ _mmap64` 为线程名称缩写的堆栈跟踪，考虑到Quarkus本地可执行程序运行18个线程。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:382
#, fuzzy
msgid "A third, and final observation, is that if you capture the `syscalls:sys_enter_munmmap` event, you might observe that some allocations also result in calls to `munmap`.  When calculating the size to reserve, the requested size to allocate can be rounded up to the page size.  The maintain alignment, 1MB in case of aligned chunks or 1 byte for unaligned chunks, some of the reserved memory might be unreserved.  That is where these `munmap` calls would come from."
msgstr "第三个，也是最后一个观察，如果你捕捉到 `syscalls:sys_enter_munmmap` 事件，你可能会观察到一些分配也会导致对 `munmap` 的调用。当计算保留的大小时，要求分配的大小可以四舍五入到页的大小上。保持对齐，如果是对齐的块，则为1MB，如果是不对齐的块，则为1字节，一些保留的内存可能是未保留的。这就是这些 `munmap` 调用的来源。"

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:391
#, fuzzy
msgid "Just by looking at the flamegraph and counting the number of `mmap` calls that originate in thread local allocations, an approximate estimation can be made on the RSS a Quarkus native executable uses on startup.  This estimation can't be fully precise because for unaligned heap chunks, the stack trace doesn't record the size of the chunk.  Also, if the additional build args are removed, inlining optimizations might obscure the type of array allocation chunk requested, so it might not be possible to decipher if the allocation is for an aligned or unaligned chunk."
msgstr "仅仅通过查看flamegraph和计算源自线程本地分配的 `mmap` 调用的数量，就可以对Quarkus本地可执行文件在启动时使用的RSS进行大致的估计。这种估计并不完全精确，因为对于未对齐的堆块，堆栈跟踪并不记录该堆块的大小。另外，如果删除了额外的构建参数，内联优化可能会掩盖请求的数组分配块的类型，所以可能无法破解分配是用于对齐的还是无对齐的块。"

#. type: Title ====
#: upstream/_guides/native-reference.adoc:394
#, fuzzy, no-wrap
msgid "bcc/eBPF"
msgstr "bcc/eBPF"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:404
#, fuzzy
msgid "A version of https://github.com/iovisor/bcc[bcc]/ https://ebpf.io/[eBPF] that can do stack traces is only available from Linux kernel 4.8 onwards.  It can do in-kernel summaries, which makes it more efficient and has lower overhead.  Unfortunately it doesn't understand DWARF debug symbols, so the information obtained might be harder to read and contain less detail."
msgstr "可以做堆栈跟踪的 link:https://github.com/iovisor/bcc[bcc/] link:https://ebpf.io/[eBPF] 版本只在Linux内核4.8以后可用。它可以做内核内的总结，这使得它更有效，开销更低。不幸的是，它不理解DWARF调试符号，所以得到的信息可能更难读，包含的细节更少。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:413
#, fuzzy
msgid "bcc/eBPF is very extensible so it's easier to tailor make scripts to track specific metrics.  The `bcc` project contains a `stackcount` program that can be used to count stack traces in similar way to what `perf` did in the previous section.  But in some cases, it might be more useful to have other metrics other than number of calls to a system call.  `malloc` is one such example.  The number of `malloc` calls is not so important, but rather the size of the allocations.  So rather than having a flamegraph showing sample counts, a flamegraph can be generated that shows bytes allocated."
msgstr "bcc/eBPF具有很强的扩展性，所以更容易定制脚本来跟踪特定的指标。 `bcc` 项目包含一个 `stackcount` 程序，可以用来计算堆栈痕迹，其方式与上一节中的 `perf` 类似。但是在某些情况下，除了对系统调用的次数之外，其他的指标可能更有用。 `malloc` 就是这样一个例子。 `malloc` 调用的数量并不那么重要，重要的是分配的大小。因此，与其让火焰图显示样本数，不如生成一个显示分配字节数的火焰图。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:417
#, fuzzy
msgid "Aside from `mmap`, `malloc` system calls are also present in native executables generated by GraalVM.  Let's put bcc/eBPF in action to generate a flamegraph of bytes allocated using `malloc`."
msgstr "除了 `mmap` ， `malloc` ，系统调用也出现在GraalVM生成的本地可执行文件中。让我们把bcc/eBPF付诸行动，生成一个使用 `malloc` 分配的字节的火焰图。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:422
#, fuzzy
msgid "To do this, first re-generate a Quarkus native executable removing debug info, which bcc/eBPF does not understand, and instead use frame pointer with local symbols to get the stack traces:"
msgstr "要做到这一点，首先重新生成一个Quarkus本地可执行文件，去掉bcc/eBPF不理解的调试信息，而使用带有本地符号的帧指针来获得堆栈痕迹："

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:427
#, no-wrap
msgid ""
"$ mvn package -DskipTests -Dnative \\\n"
"  -Dquarkus.native.additional-build-args=-H:-DeleteLocalSymbols,-H:+PreserveFramePointer\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:437
#, fuzzy
msgid "The link:mallocstacks.py[mallocstacks.py] bcc/eBPF script will be used to capture the `malloc` stacktraces with their allocated size.  This script, and other typical bcc/eBPF scripts (e.g. `stackcount`), need to be given a process ID (PID).  This makes a bit tricky when you want to trace startup, but you can use `gdb` (even if you haven't enabled debug info)  to get around this obstacle because it allows you to stop the application at the first instruction.  Let's start by running the native executable via `gdb`:"
msgstr "link:mallocstacks.py[mallocstacks.py] bcc/eBPF脚本将被用来捕获 `malloc` 堆栈轨迹及其分配的大小。这个脚本，以及其他典型的bcc/eBPF脚本（例如： `stackcount` ），需要被赋予一个进程ID（PID）。当你想追踪启动时，这就有点麻烦了，但是你可以使用 `gdb` （即使你没有启用调试信息）来绕过这个障碍，因为它允许你在第一条指令时停止应用程序。让我们先通过 `gdb` 来运行本地可执行程序："

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:443
#, no-wrap
msgid ""
"$ gdb --args ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner -Xmx128m\n"
"...\n"
"(No debugging symbols found in ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner)\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:446
#, fuzzy
msgid "`starti` is a `gdb` command that sets a temporary breakpoint at the very first instruction of the program's execution."
msgstr " `starti` 是一条 ，在程序执行的第一条指令上设置一个临时断点。 `gdb` "

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:453
#, no-wrap
msgid ""
"(gdb) starti\n"
"Starting program: <..>/code-with-quarkus/target/code-with-quarkus-1.0.0-SNAPSHOT-runner -Xmx128m\n"
"Program stopped.\n"
"0x00007ffff7fe4790 in _start () from /lib64/ld-linux-x86-64.so.2\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:458
#, fuzzy
msgid "Next invoke the bcc/eBPF script giving it the PID of the Quarkus process, so that it can track the `malloc` calls, capture stack traces and dump them to a file for post-processing:"
msgstr "接下来调用bcc/eBPF脚本，给它提供Quarkus进程的PID，这样它就可以跟踪 `malloc` ，捕捉堆栈痕迹，并将其转储到一个文件中进行后处理："

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:462
#, no-wrap
msgid "$ sudo ./mallocstacks.py -p $(pidof code-with-quarkus-1.0.0-SNAPSHOT-runner) -f > out.stacks\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:465
#, fuzzy
msgid "Then go back to the `gdb` shell and instruct it to continue the startup procedure after hitting the first instruction:"
msgstr "然后回到 `gdb` shell，指示它在点击第一个指令后继续启动程序："

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:482
#, no-wrap
msgid ""
"(gdb) continue\n"
"Continuing.\n"
"[Thread debugging using libthread_db enabled]\n"
"Using host libthread_db library \"/lib64/libthread_db.so.1\".\n"
"[New Thread 0x7ffff65ff6c0 (LWP 3342)]\n"
"...\n"
"[New Thread 0x7fffc6ffd6c0 (LWP 3359)]\n"
"__  ____  __  _____   ___  __ ____  ______\n"
" --/ __ \\/ / / / _ | / _ \\/ //_/ / / / __/\n"
" -/ /_/ / /_/ / __ |/ , _/ ,< / /_/ /\\ \\\n"
"--\\___\\_\\____/_/ |_/_/|_/_/|_|\\____/___/\n"
"2023-02-09 18:02:32,794 INFO  [io.quarkus] (main) code-with-quarkus 1.0.0-SNAPSHOT native (powered by Quarkus 2.16.1.Final) started in 0.011s. Listening on: http://0.0.0.0:8080\n"
"2023-02-09 18:02:32,794 INFO  [io.quarkus] (main) Profile prod activated.\n"
"2023-02-09 18:02:32,794 INFO  [io.quarkus] (main) Installed features: [cdi, resteasy-reactive, smallrye-context-propagation, vertx]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:486
#, fuzzy
msgid "Once the startup has complete, press `Ctrl-C` on the `stackcount` shell."
msgstr "一旦启动完成，在 `stackcount` shell上按 `Ctrl-C` 。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:490
#, fuzzy
msgid "Then process the stacks file as a flamegraph.  Note that the stacks generated by this script are already collapsed, so the flamegraph can be generated just like this:"
msgstr "然后将堆栈文件作为火焰图来处理。注意，这个脚本生成的堆栈已经被折叠了，所以火焰图可以像这样生成："

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:494
#, no-wrap
msgid "$ cat out.stacks | ${FG_HOME}/flamegraph.pl --color=mem --title=\"malloc bytes Flame Graph\" --countname=\"bytes\" > out.svg\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:497
#, fuzzy
msgid "The flamegraph produced should look something like this:"
msgstr "产生的火焰图应该看起来像这样："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_guides/native-reference.adoc:498
#, fuzzy, no-wrap
msgid "malloc bytes flamegraph"
msgstr "malloc bytes flamegraph"

#. type: Target for macro image
#: upstream/_guides/native-reference.adoc:498
#, no-wrap
msgid "malloc-bytes.svg"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:505
#, fuzzy
msgid "This shows that most of the memory requested using `malloc` comes from epoll in Java NIO, but the overall amount allocated via `malloc` is barely 268KB.  This amount of 274,269 bytes can be observed by hoovering on top of `all` at the bottom of flamegraph (you might need to ask the browser to open the flamegraph in a different tab or window to observe this).  This is very small compared with the amount allocated for the heap with `mmap`."
msgstr "这表明，使用 `malloc` 申请的大部分内存来自Java NIO中的epoll，但通过 `malloc` 分配的总体数量几乎没有268KB。这个274,269字节的数量可以通过在flamegraph底部的 `all` 上面观察到（你可能需要要求浏览器在不同的标签或窗口中打开flamegraph来观察这个）。这与用 `mmap` 分配给堆的数量相比是非常小的。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:508
#, fuzzy
msgid "Finally, just a brief mention about other bcc/eBPF commands, and how to transform them into flamegraphs."
msgstr "最后，只是简单提一下其他bcc/eBPF命令，以及如何将它们转化为火焰图。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:513
#, no-wrap
msgid ""
"$ sudo /usr/share/bcc/tools/stackcount -P -p $(pidof code-with-quarkus-1.0.0-SNAPSHOT-runner) \\\n"
"  -U \"t:syscalls:sys_enter_m*\" # count stacks for mmap and munmap\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:516
#, no-wrap
msgid ""
"$ sudo /usr/share/bcc/tools/stackcount -P -p $(pidof code-with-quarkus-1.0.0-SNAPSHOT-runner) \\\n"
"  -U \"c:*alloc\" # count stacks for malloc, calloc and realloc\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:519
#, no-wrap
msgid ""
"$ sudo /usr/share/bcc/tools/stackcount -P -p $(pidof code-with-quarkus-1.0.0-SNAPSHOT-runner) \\\n"
"  -U \"c:free\" # count stacks for free\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:522
#, no-wrap
msgid ""
"$ sudo /usr/share/bcc/tools/stackcount -P -p $(pidof code-with-quarkus-1.0.0-SNAPSHOT-runner) \\\n"
"  -U \"t:exceptions:page_fault_*\" # count stacks for page faults\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:526
#, fuzzy
msgid "Stacks produced by `stackcount` need to be collapsed before they can be transformed into flamegraphs.  For example:"
msgstr "由 `stackcount` 产生的堆栈在转化为火焰图之前需要进行折叠。比如说："

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:531
#, no-wrap
msgid ""
"${FG_HOME}/stackcollapse.pl < out.stacks | ${FG_HOME}/flamegraph.pl \\\n"
"  --color=mem --title=\"mmap munmap Flame Graph\" --countname=\"calls\" > out.svg\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/native-reference.adoc:534
#, fuzzy, no-wrap
msgid "Inspecting and Debugging Native Executables"
msgstr "检查本地可执行文件"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:536
#, fuzzy
msgid "This debugging guide provides further details on debugging issues in Quarkus native executables that might arise during development or production."
msgstr "本调试指南提供了关于调试Quarkus本地可执行文件中可能在开发或生产中出现的问题的进一步细节。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:539
#, fuzzy
msgid "It takes as input the application developed in the xref:getting-started.adoc[Getting Started Guide].  You can find instructions on how to quickly set up this application in this guide."
msgstr "本参考指南将《 link:getting-started.html[入门指南》] 中开发的应用程序作为输入。你可以在本指南中找到关于如何快速设置该应用程序的说明。"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:540
#, fuzzy, no-wrap
msgid "Requirements and Assumptions"
msgstr "要求和假设"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:543
#, fuzzy
msgid "This debugging guide has the following requirements:"
msgstr "本指南有以下要求。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:545
#, fuzzy
msgid "JDK 11 installed with `JAVA_HOME` configured appropriately"
msgstr "安装了JDK 11，并适当配置了 `JAVA_HOME` "

#. type: Plain text
#: upstream/_guides/native-reference.adoc:546
#, fuzzy
msgid "Apache Maven {maven-version}"
msgstr "Apache Maven {maven-version}"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:547
#, fuzzy
msgid "A working container runtime (Docker, podman)"
msgstr "一个工作的容器运行时间（Docker，podman）。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:552
#, fuzzy
msgid "This guide builds and executes Quarkus native executables within a Linux environment.  To offer a homogeneous experience across all environments, the guide relies on a container runtime environment to build and run the native executables.  The instructions below use Docker as example, but very similar commands should work on alternative container runtimes, e.g. podman."
msgstr "本指南在Linux环境下构建和执行Quarkus本地可执行文件。为了在所有环境中提供同质化的体验，本指南依靠容器运行环境来构建和运行本地可执行文件。下面的说明以Docker为例，但非常类似的命令在其他容器运行时（如podman）上也可以使用。"

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:558
#, fuzzy
msgid "Building native executables is an expensive process, so make sure the container runtime has enough CPU and memory to do this.  A minimum of 4 CPUs and 4GB of memory is required."
msgstr "构建本地可执行文件是一个昂贵的过程，所以要确保容器运行时有足够的CPU和内存来完成这项工作。至少需要4个CPU和4GB的内存。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:562
#, fuzzy
msgid "Finally, this guide assumes the use of the link:https://github.com/graalvm/mandrel[Mandrel distribution] of GraalVM for building native executables, and these are built within a container so there is no need for installing Mandrel on the host."
msgstr "最后，本指南假设使用GraalVM的 link:https://github.com/graalvm/mandrel[Mandrel发行版] 来构建本地可执行文件，这些文件是在容器中构建的，因此不需要在主机上安装Mandrel。"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:563
#, fuzzy, no-wrap
msgid "Bootstrapping the project"
msgstr "引导项目"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:567
#, fuzzy
msgid "Start by creating a new Quarkus project.  Open a terminal and run the following command:"
msgstr "首先创建一个新的Quarkus项目。打开一个终端，运行以下命令。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:569
#, fuzzy
msgid "For Linux & MacOS users"
msgstr "针对Linux和MacOS用户"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:576
#, fuzzy
msgid "For Windows users"
msgstr "对于Windows用户"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:578
#, fuzzy
msgid "If using cmd , (don't use backward slash `\\` and put everything on the same line)"
msgstr "如果使用cmd ，（不要使用反斜线 `\\` ，并将所有内容放在同一行）"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:579
#, fuzzy
msgid "If using Powershell , wrap `-D` parameters in double quotes e.g. `\"-DprojectArtifactId=debugging-native\"`"
msgstr "如果使用Powershell，用双引号包住 `-D` 参数，例如： `\"-DprojectArtifactId=debugging-native\"` "

#. type: Title ===
#: upstream/_guides/native-reference.adoc:580
#, fuzzy, no-wrap
msgid "Configure Quarkus properties"
msgstr "配置Quarkus属性"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:586
#, fuzzy
msgid "Some Quarkus configuration options will be used constantly throughout this debugging guide, so to help declutter command line invocations, it's recommended to add these options to the `application.properties` file.  So, go ahead and add the following options to that file:"
msgstr "一些Quarkus配置选项将在本指南中不断被使用，所以为了帮助简化命令行的调用，建议将这些选项添加到 `application.properties` 文件中。因此，请继续将下列选项添加到该文件中。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:593
#, no-wrap
msgid ""
"quarkus.native.container-build=true\n"
"quarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel-builder-image:{mandrel-flavor}\n"
"quarkus.container-image.build=true\n"
"quarkus.container-image.group=test\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:600
#, fuzzy
msgid "Starting with 22.3, Mandrel does not provide a `-java11` version anymore.  Note, however, that this doesn't mean that you may no longer produce native executables with Mandrel for Java 11 projects.  You can still compile your Java 11 projects using OpenJDK 11 and produce native executables from the resulting Java 11 bytecode using the `-java17` Mandrel builder images."
msgstr "从22.3开始，Mandrel不再提供 `-java11` 版本了。但是，请注意，这并不意味着你不能再使用Mandrel为Java 11项目制作本地可执行文件。你仍然可以使用OpenJDK 11编译你的Java 11项目，并使用 `-java17` Mandrel builder images从生成的Java 11字节码中生成本地可执行文件。"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:602
#, fuzzy, no-wrap
msgid "First Debugging Steps"
msgstr "第一个调试步骤"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:605
#, fuzzy
msgid "As a first step, change to the project directory and build the native executable for the application:"
msgstr "作为第一步，改变到项目目录，建立应用程序的本地可执行文件。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:609
#: upstream/_guides/native-reference.adoc:1074
#, no-wrap
msgid "./mvnw package -DskipTests -Dnative\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:612
#, fuzzy
msgid "Run the application to verify it works as expected. In one terminal:"
msgstr "运行该应用程序，以验证它是否按预期工作。在一个终端中"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:616
#: upstream/_guides/native-reference.adoc:1082
#, no-wrap
msgid "docker run -i --rm -p 8080:8080 test/debugging-native:1.0.0-SNAPSHOT\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:619
#, fuzzy
msgid "In another:"
msgstr "在另一个。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:623
#, no-wrap
msgid "curl -w '\\n' http://localhost:8080/hello\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:628
#, fuzzy
msgid "The rest of this section explores ways to build the native executable with extra information, but first, stop the running application.  We can obtain this information while building the native executable by adding additional native-image build options using `-Dquarkus.native.additional-build-args`, e.g."
msgstr "本节的其余部分探讨了用额外信息构建本地可执行文件的方法，但首先要停止运行中的应用程序。我们可以在构建本地可执行文件时，通过使用 `-Dquarkus.native.additional-build-args` 添加额外的本地图像构建选项来获得这些信息，例如："

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:633
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.additional-build-args=--native-image-info\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:636
#, fuzzy
msgid "Executing that will produce additional output lines like this:"
msgstr "执行这句话将产生额外的输出行，像这样。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:643
#, no-wrap
msgid ""
"...\n"
"# Printing compilation-target information to: /project/reports/target_info_20220223_100915.txt\n"
"…\n"
"# Printing native-library information to: /project/reports/native_library_info_20220223_100925.txt\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:651
#, fuzzy
msgid "Note that `/project` is a folder within the container that is building the native executable.  So, this is not a folder that you will find in the host environment.  `/project` folder is mapped to `target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar`, so you will find the files under the `reports` folder in that directory."
msgstr "请注意， `/project` 是正在构建本地可执行文件的容器中的一个文件夹。所以，这不是你在主机环境中找到的文件夹。 `/project` 文件夹被映射到 `target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar` ，所以你会在该目录下找到 `reports` 文件夹下的文件。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:656
#, fuzzy
msgid "The target info file contains information such as the target platform, the toolchain used to compile the executable, and the C library in use:"
msgstr "目标信息文件包含诸如目标平台、用于编译可执行文件的工具链和使用中的C库等信息。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:668
#, no-wrap
msgid ""
"$ cat target/*/reports/target_info_*.txt\n"
"Building image for target platform: org.graalvm.nativeimage.Platform$LINUX_AMD64\n"
"Using native toolchain:\n"
"   Name: GNU project C and C++ compiler (gcc)\n"
"   Vendor: redhat\n"
"   Version: 8.5.0\n"
"   Target architecture: x86_64\n"
"   Path: /usr/bin/gcc\n"
"Using CLibrary: com.oracle.svm.core.posix.linux.libc.GLib\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:671
#, fuzzy
msgid "The native library info file contains information on the static libraries added to the binary and the other libraries dynamically linked to the executable:"
msgstr "本地库信息文件包含添加到二进制文件的静态库和动态链接到可执行文件的其他库的信息。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:686
#, no-wrap
msgid ""
"$ cat target/*/reports/native_library_info_*.txt\n"
"Static libraries:\n"
"   ../opt/mandrel/lib/svm/clibraries/linux-amd64/liblibchelper.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libnet.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libextnet.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libnio.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libjava.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libfdlibm.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libsunec.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libzip.a\n"
"   ../opt/mandrel/lib/svm/clibraries/linux-amd64/libjvm.a\n"
"Other libraries: stdc++,pthread,dl,z,rt\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:691
#, fuzzy
msgid "Even more detail can be obtained by passing in `--verbose` as an additional native-image build argument.  This option can be very useful in detecting whether the options that you pass at a high level via Quarkus are being passed down to the native executable production, or whether some third party jar has some native-image configuration embedded in it that is reaching the native-image invocation:"
msgstr "更多的细节可以通过传递 `--verbose` 作为额外的本地图像构建参数来获得。这个选项对于检测你通过Quarkus在高层传递的选项是否被传递到本地可执行程序的生产中，或者第三方jar是否有一些本地图像配置被嵌入到本地图像调用中，非常有用。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:696
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.additional-build-args=--verbose\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:699
#, fuzzy
msgid "Running with `--verbose` demonstrates how the native-image building process is two sequential java processes:"
msgstr "用 `--verbose` ，展示了本地图像构建过程是两个连续的java过程。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:702
#, fuzzy
msgid "The first is a very short Java process that does some basic validation and builds the arguments for the second process (in a stock GraalVM distribution, this is executed as native code)."
msgstr "第一个是一个非常短的Java进程，它做一些基本的验证，并为第二个进程建立参数（在GraalVM的股票发行中，它是作为本地代码执行的）。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:705
#, fuzzy
msgid "The second Java process is where the main part of the native executable production happens.  The `--verbose` option shows the actual Java process executed.  You could take the output and run it yourself."
msgstr "第二个Java进程是本地可执行程序生产的主要部分发生的地方。 `--verbose` 选项显示实际执行的Java进程。你可以采取输出并自己运行它。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:707
#, fuzzy
msgid "One may also combine multiple native build options by separating with a comma, e.g.:"
msgstr "我们也可以通过用逗号分隔来组合多个本地构建选项，例如：。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:712
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.additional-build-args=--native-image-info,--verbose\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:718
#, fuzzy
msgid "Remember that if an argument for `-Dquarkus.native.additional-build-args` includes the `,` symbol, it needs to be escaped to be processed correctly, e.g. `\\\\,`."
msgstr "请记住，如果 `-Dquarkus.native.additional-build-args` 的参数包括 `,` 符号，则需要转义以进行正确的处理，例如 `\\\\,` 。"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:720
#, fuzzy, no-wrap
msgid "Inspecting Native Executables"
msgstr "检查本地可执行文件"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:726
#, fuzzy
msgid "Given a native executable, various Linux tools can be used to inspect it.  To allow supporting a variety of environments, inspections will be done from within a Linux container.  Let's create a Linux container image with all the tools required for this guide:"
msgstr "给定一个本地可执行文件，可以使用各种Linux工具来检查它。为了支持各种环境，检查将在Linux容器中进行。让我们创建一个带有本指南所需所有工具的Linux容器镜像。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:730
#, no-wrap
msgid "FROM fedora:35\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:737
#, no-wrap
msgid ""
"RUN dnf install -y \\\n"
"binutils \\\n"
"gdb \\\n"
"git \\\n"
"perf \\\n"
"perl-open\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:739
#, no-wrap
msgid "ENV FG_HOME /opt/FlameGraph\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:741
#, no-wrap
msgid "RUN git clone https://github.com/brendangregg/FlameGraph $FG_HOME\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:743
#, no-wrap
msgid "WORKDIR /data\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:745
#, no-wrap
msgid "ENTRYPOINT /bin/bash\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:748
#, fuzzy
msgid "Using docker in the non-Linux environment, you can create an image using this Dockerfile via:"
msgstr "在非Linux环境中使用docker，你可以通过这个Dockerfile创建一个镜像。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:752
#, no-wrap
msgid "docker build -t fedora-tools:v1 .\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:755
#, fuzzy
msgid "Then, go to the root of the project and run the Docker container we have just created as:"
msgstr "然后，进入项目的根目录，运行我们刚刚创建的Docker容器。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:759
#, no-wrap
msgid "docker run -t -i --rm -v ${PWD}:/data -p 8080:8080 fedora-tools:v1\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:762
#, fuzzy
msgid "`ldd` shows the shared library dependencies of an executable:"
msgstr " `ldd` 显示一个可执行文件的共享库依赖性。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:766
#, no-wrap
msgid "ldd ./target/debugging-native-1.0.0-SNAPSHOT-runner\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:769
#, fuzzy
msgid "`strings` can be used to look for text messages inside the binary:"
msgstr " `strings` 可以用来寻找二进制文件中的文本信息。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:773
#, no-wrap
msgid "strings ./target/debugging-native-1.0.0-SNAPSHOT-runner | grep Hello\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:776
#, fuzzy
msgid "Using `strings` you can also get Mandrel information given the binary:"
msgstr "使用 `strings` ，你也可以得到二进制的心轴信息。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:780
#, no-wrap
msgid "strings ./target/debugging-native-1.0.0-SNAPSHOT-runner | grep core.VM\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:784
#, fuzzy
msgid "Finally, using `readelf` we can inspect different sections of the binary.  For example, we can see how the heap and text sections take most of the binary:"
msgstr "最后，使用 `readelf` ，我们可以检查二进制的不同部分。例如，我们可以看到堆和文本部分如何占用二进制的大部分。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:788
#, no-wrap
msgid "readelf -SW ./target/debugging-native-1.0.0-SNAPSHOT-runner\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:795
#, fuzzy
msgid "Runtime containers produced by Quarkus to run native executables will not include the tools mentioned above.  To explore a native executable within a runtime container, it's best to run the container itself and then `docker cp` the executable locally, e.g.:"
msgstr "由Quarkus生产的运行本地可执行文件的运行时容器将不包括上述的工具。要在运行时容器中探索一个本地可执行文件，最好先运行容器本身，然后在本地 `docker cp` 可执行文件，例如。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:800
#, no-wrap
msgid ""
"docker run -i --rm --name=mytest -p 8080:8080 test/debugging-native:1.0.0-SNAPSHOT\n"
"docker cp mytest:/work/application path/on/host/\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:803
#, fuzzy
msgid "From there, you can either inspect the executable directly or use a tools container like above."
msgstr "从那里，你可以直接检查可执行文件，或者像上面那样使用一个工具容器。"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:806
#, fuzzy, no-wrap
msgid "Native Reports"
msgstr "本地报告"

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:809
#, fuzzy
msgid "Optionally, the native build process can generate reports that show what goes into the binary:"
msgstr "作为选择，本地构建过程可以生成报告，显示二进制文件中的内容。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:814
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.enable-reports\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:818
#, fuzzy
msgid "The reports will be created under `target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar/reports/`.  These reports are some of the most useful resources when encountering issues with missing methods/classes, or encountering forbidden methods by Mandrel."
msgstr "这些报告将在 `target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar/reports/` 下创建。当遇到缺少方法/类的问题，或者遇到被Mandrel禁止的方法时，这些报告是一些最有用的资源。"

#. type: Title ====
#: upstream/_guides/native-reference.adoc:819
#, fuzzy, no-wrap
msgid "Call Tree Reports"
msgstr "呼叫树报告"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:825
#, fuzzy
msgid "`call_tree` csv file reports are some of the default reports generated when the `-Dquarkus.native.enable-reports` option is passed in.  These csv files can be imported into a graph database, such as Neo4j, to inspect them more easily and run queries against the call tree.  This is useful for getting an approximation on why a method/class is included in the binary."
msgstr " `call_tree` 文本文件报告是当 选项被传入时产生的默认报告之一。这对于获得一个方法/类被包含在二进制文件中的近似值很有用。然而，文本格式使得它很难阅读，而且会占用大量的空间。 `-Dquarkus.native.enable-reports` "

#. type: Plain text
#: upstream/_guides/native-reference.adoc:827
#, fuzzy
msgid "Let’s see this in action."
msgstr "让我们看看这个行动。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:829
#, fuzzy
msgid "First, start a Neo4j instance:"
msgstr "首先，启动一个Neo4j实例。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:840
#, no-wrap
msgid ""
"export NEO_PASS=...\n"
"docker run \\\n"
"    --detach \\\n"
"    --rm \\\n"
"    --name testneo4j \\\n"
"    -p7474:7474 -p7687:7687 \\\n"
"    --env NEO4J_AUTH=neo4j/${NEO_PASS} \\\n"
"    neo4j:latest\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:845
#, fuzzy
msgid "Once the container is running, you can access the link:http://localhost:7474[Neo4j browser].  Use `neo4j` as the username and the value of `NEO_PASS` as the password to log in."
msgstr "一旦容器运行，你就可以访问 link:http://localhost:7474[Neo4j浏览器] 。用 `neo4j` 作为用户名，用 `NEO_PASS` 的值作为密码来登录。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:848
#, fuzzy
msgid "To import the CSV files, we need the following cypher script which will import the data within the CSV files and create graph database nodes and edges:"
msgstr "为了导入CSV文件，我们需要以下Cypher脚本，它将导入CSV文件内的数据，并创建图数据库节点和边。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:853
#, no-wrap
msgid ""
"CREATE CONSTRAINT unique_vm_id ON (v:VM) ASSERT v.vmId IS UNIQUE;\n"
"CREATE CONSTRAINT unique_method_id ON (m:Method) ASSERT m.methodId IS UNIQUE;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:857
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/call_tree_vm.csv' AS row\n"
"MERGE (v:VM {vmId: row.Id, name: row.Name})\n"
"RETURN count(v);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:861
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/call_tree_methods.csv' AS row\n"
"MERGE (m:Method {methodId: row.Id, name: row.Name, type: row.Type, parameters: row.Parameters, return: row.Return, display: row.Display})\n"
"RETURN count(m);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:865
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/call_tree_virtual_methods.csv' AS row\n"
"MERGE (m:Method {methodId: row.Id, name: row.Name, type: row.Type, parameters: row.Parameters, return: row.Return, display: row.Display})\n"
"RETURN count(m);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:871
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/call_tree_entry_points.csv' AS row\n"
"MATCH (m:Method {methodId: row.Id})\n"
"MATCH (v:VM {vmId: '0'})\n"
"MERGE (v)-[:ENTRY]->(m)\n"
"RETURN count(*);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:877
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/call_tree_direct_edges.csv' AS row\n"
"MATCH (m1:Method {methodId: row.StartId})\n"
"MATCH (m2:Method {methodId: row.EndId})\n"
"MERGE (m1)-[:DIRECT {bci: row.BytecodeIndexes}]->(m2)\n"
"RETURN count(*);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:883
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/call_tree_override_by_edges.csv' AS row\n"
"MATCH (m1:Method {methodId: row.StartId})\n"
"MATCH (m2:Method {methodId: row.EndId})\n"
"MERGE (m1)-[:OVERRIDEN_BY]->(m2)\n"
"RETURN count(*);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:889
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/call_tree_virtual_edges.csv' AS row\n"
"MATCH (m1:Method {methodId: row.StartId})\n"
"MATCH (m2:Method {methodId: row.EndId})\n"
"MERGE (m1)-[:VIRTUAL {bci: row.BytecodeIndexes}]->(m2)\n"
"RETURN count(*);\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:892
#, fuzzy
msgid "Copy and paste the contents of the script into a file called `import.cypher`."
msgstr "复制并粘贴脚本的内容到一个名为 `import.cypher` 的文件中。"

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:898
#, fuzzy
msgid "Mandrel 22.0.0 contains a bug where the symbolic links used by the import cypher file are not correctly set when generating reports within a container (for more details see link:https://github.com/oracle/graal/issues/4355[here]).  This can be worked around by copying the following script into a file and executing it:"
msgstr "Mandrel 22.0.0包含一个错误，当在一个容器内生成报告时，导入cypher文件使用的符号链接没有正确设置（更多细节见 link:https://github.com/oracle/graal/issues/4355[这里] ）。这可以通过复制以下脚本到一个文件中并执行它来解决。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:902
#, no-wrap
msgid "set -e\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:904
#, no-wrap
msgid "project=\"debugging-native\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:906
#, no-wrap
msgid "pushd target/*-native-image-source-jar/reports\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:909
#, no-wrap
msgid ""
"rm -f call_tree_vm.csv\n"
"ln -s call_tree_vm_${project}-* call_tree_vm.csv\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:912
#, no-wrap
msgid ""
"rm -f call_tree_direct_edges.csv\n"
"ln -s call_tree_direct_edges_${project}-* call_tree_direct_edges.csv\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:915
#, no-wrap
msgid ""
"rm -f call_tree_entry_points.csv\n"
"ln -s call_tree_entry_points_${project}-* call_tree_entry_points.csv\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:918
#, no-wrap
msgid ""
"rm -f call_tree_methods.csv\n"
"ln -s call_tree_methods_${project}-* call_tree_methods.csv\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:921
#, no-wrap
msgid ""
"rm -f call_tree_virtual_edges.csv\n"
"ln -s call_tree_virtual_edges_${project}-* call_tree_virtual_edges.csv\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:924
#, no-wrap
msgid ""
"rm -f call_tree_virtual_methods.csv\n"
"ln -s call_tree_virtual_methods_${project}-* call_tree_virtual_methods.csv\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:927
#, no-wrap
msgid ""
"rm -f call_tree_override_by_edges.csv\n"
"ln -s call_tree_override_by_edges_${project}-* call_tree_override_by_edges.csv\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:929
#, no-wrap
msgid "popd\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:933
#, fuzzy
msgid "Next, copy the import cypher script and CSV files into Neo4j's import folder:"
msgstr "接下来，将导入的cypher脚本和CSV文件复制到Neo4j的导入文件夹。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:939
#, no-wrap
msgid ""
"docker cp \\\n"
"    target/*-native-image-source-jar/reports \\\n"
"    testneo4j:/var/lib/neo4j/import\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:941
#, no-wrap
msgid "docker cp import.cypher testneo4j:/var/lib/neo4j\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:944
#, fuzzy
msgid "After copying all the files, invoke the import script:"
msgstr "拷贝完所有文件后，调用导入脚本。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:948
#, no-wrap
msgid "docker exec testneo4j bin/cypher-shell -u neo4j -p ${NEO_PASS} -f import.cypher\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:952
#, fuzzy
msgid "Once the import completes (shouldn't take more than a couple of minutes), go to the link:http://localhost:7474[Neo4j browser], and you'll be able to observe a small summary of the data in the graph:"
msgstr "一旦导入完成（应该不会超过几分钟），进入 link:http://localhost:7474[Neo4j浏览器] ，你就能观察到图表中的数据小结。"

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_guides/native-reference.adoc:953
#, fuzzy, no-wrap
msgid "Neo4j database information after import"
msgstr "导入后的Neo4j数据库信息"

#. type: Target for macro image
#: upstream/_guides/native-reference.adoc:953
#, no-wrap
msgid "native-reference-neo4j-db-info.png"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:958
#, fuzzy
msgid "The data above shows that there are ~60000 methods, and just over ~200000 edges between them.  The Quarkus application demonstrated here is very basic, so there’s not a lot we can explore, but here are some example queries you can run to explore the graph in more detail.  Typically, you’d start by looking for a given method:"
msgstr "上面的数据显示，有~60000个方法，它们之间的边刚超过~200000条。这里展示的Quarkus应用是非常基本的，所以我们可以探索的东西不多，但是这里有一些查询的例子，你可以运行这些查询来更详细地探索图。通常情况下，你会从寻找一个特定的方法开始。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:962
#, no-wrap
msgid "match (m:Method) where m.name = \"hello\" return *\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:965
#, fuzzy
msgid "From there, you can narrow down to a given method on a specific type:"
msgstr "从那里，你可以缩小到特定类型上的特定方法。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:969
#, no-wrap
msgid "match (m:Method) where m.name = \"hello\" and m.type =~ \".*GreetingResource\" return *\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:976
#, fuzzy
msgid "Once you’ve located the node for the specific method you’re after, a typical question you’d want to get an answer for is: why does this method get included in the call tree? To do that, start from the method and look for incoming connections at a given depth, starting from the end method.  For example, methods that directly call a method can be located via:"
msgstr "一旦你找到了你要找的特定方法的节点，你想得到答案的一个典型问题是：为什么这个方法会被包含在调用树中？要做到这一点，从方法开始，在一定的深度上寻找传入的连接，从终端方法开始。例如，直接调用一个方法的方法可以通过以下方式定位。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:980
#, no-wrap
msgid "match (m:Method) <- [*1..1] - (o) where m.name = \"hello\" and m.type =~ \".*GreetingResource\" return *\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:984
#, fuzzy
msgid "Then you can look for direct calls at depth of 2, so you’d search for methods that call methods that call into the target method:"
msgstr "然后你可以在深度为2的地方寻找直接调用，所以你会搜索那些调用目标方法的方法。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:988
#, no-wrap
msgid "match (m:Method) <- [*1..2] - (o) where m.name = \"hello\" and m.type =~ \".*GreetingResource\" return *\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:994
#, fuzzy
msgid "You can continue going up layers, but unfortunately if you reach a depth with too many nodes, the Neo4j browser will be unable to visualize them all.  When that happens, you can alternatively run the queries directly against the cypher shell:"
msgstr "你可以继续往上走，但不幸的是，如果你达到的深度有太多的节点，Neo4j浏览器将无法将它们全部可视化。当这种情况发生时，你可以选择直接针对cypher shell运行查询。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:999
#, no-wrap
msgid ""
"docker exec testneo4j bin/cypher-shell -u neo4j -p ${NEO_PASS} \\\n"
"  \"match (m:Method) <- [*1..10] - (o) where m.name = 'hello' and m.type =~ '.*GreetingResource' return *\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1004
#, fuzzy
msgid "For further information, check out this link:https://quarkus.io/blog/quarkus-native-neo4j-call-tree[blog post] that explores the Quarkus Hibernate ORM quickstart using the techniques explained above."
msgstr "更多信息，请查看这篇 link:https://quarkus.io/blog/quarkus-native-neo4j-call-tree[博文] ，它探讨了Quarkus Hibernate ORM的快速入门，使用了上面解释的技术。"

#. type: Title ====
#: upstream/_guides/native-reference.adoc:1005
#, fuzzy, no-wrap
msgid "Used Packages/Classes/Methods Reports"
msgstr "使用的包/类/方法报告"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1009
#, fuzzy
msgid "`used_packages`, `used_classes` and `used_methods` text file reports come in handy when comparing different versions of the application, e.g. why does the image take longer to build? Or why is the image bigger now?"
msgstr " `used_packages` , `used_classes` 和 `used_methods` 文本文件报告在比较不同版本的应用程序时非常有用，例如，为什么图像的构建时间更长？或者为什么现在的图像更大了？"

#. type: Title ====
#: upstream/_guides/native-reference.adoc:1010
#, fuzzy, no-wrap
msgid "Further Reports"
msgstr "进一步的报告"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1014
#, fuzzy
msgid "Mandrel can produce further reports beyond the ones that are enabled with the `-Dquarkus.native.enable-reports` option.  These are called expert options and you can learn more about them by running:"
msgstr "除了通过 `-Dquarkus.native.enable-reports` 选项启用的报告之外，Mandrel还可以产生更多的报告。这些被称为专家选项，你可以通过运行来了解更多关于它们。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1018
#, no-wrap
msgid "docker run quay.io/quarkus/ubi-quarkus-mandrel-builder-image:{mandrel-flavor} --expert-options-all\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:1024
#, fuzzy
msgid "These expert options are not considered part of the GraalVM native image API, so they might change anytime."
msgstr "这些专家选项不被认为是GraalVM本地图像API的一部分，所以它们可能随时会发生变化。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1027
#, fuzzy
msgid "To use these expert options, add them comma separated to the `-Dquarkus.native.additional-build-args` parameter."
msgstr "要使用这些专家选项，请将它们以逗号分隔添加到 `-Dquarkus.native.additional-build-args` 参数中。"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:1028
#, fuzzy, no-wrap
msgid "Build-time vs Run-time Initialization"
msgstr "构建时与运行时的初始化"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1035
#, fuzzy
msgid "Quarkus instructs Mandrel to initialize as much as possible at build time, so that runtime startup can be as fast as possible.  This is important in containerized environments where the startup speed has a big impact on how quickly an application is ready to do work.  Build time initialization also minimizes the risk of runtime failures due to unsupported features becoming reachable through runtime initialization, thus making Quarkus more reliable."
msgstr "Quarkus指示Mandrel在构建时尽可能多地初始化，以便运行时的启动速度尽可能快。这在容器环境中很重要，因为启动速度对应用程序准备工作的速度有很大影响。构建时初始化还可以最大限度地减少由于不支持的功能通过运行时初始化而导致的运行时失败的风险，从而使Quarkus更加可靠。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1039
#, fuzzy
msgid "The most common examples of build-time initialized code are static variables and blocks.  Although Mandrel executes those at run-time by default, Quarkus instructs Mandrel to run them at build-time for the reasons given."
msgstr "最常见的构建时初始化代码的例子是静态变量和块。尽管Mandrel默认在运行时执行这些代码，但由于所给出的原因，Quarkus指示Mandrel在构建时运行它们。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1043
#, fuzzy
msgid "This means that any static variables initialized inline, or initialized in a static block, will keep the same value even if the application is restarted.  This is a different behaviour compared to what would happen if executed as Java."
msgstr "这意味着任何内联初始化的静态变量，或在静态块中初始化的静态变量，即使应用程序被重新启动，也会保持相同的值。这与以Java方式执行的情况不同，是一种行为。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1046
#, fuzzy
msgid "To see this in action with a very basic example, add a new `TimestampResource` to the application that looks like this:"
msgstr "通过一个非常基本的例子来看看这个操作，在应用程序中添加一个新的 `TimestampResource` ，看起来像这样。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1050
#: upstream/_guides/native-reference.adoc:1102
#: upstream/_guides/native-reference.adoc:1248
#: upstream/_guides/native-reference.adoc:1440
#: upstream/_guides/native-reference.adoc:1577
#, no-wrap
msgid "package org.acme;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1055
#: upstream/_guides/native-reference.adoc:1253
#, no-wrap
msgid ""
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.Produces;\n"
"import jakarta.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1058
#, no-wrap
msgid ""
"@Path(\"/timestamp\")\n"
"public class TimestampResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1060
#, no-wrap
msgid "    static long firstAccess = System.currentTimeMillis();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1067
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String timestamp() {\n"
"        return \"First access \" + firstAccess;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1070
#, fuzzy
msgid "Rebuild the binary using:"
msgstr "用以下方法重建二进制文件。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1078
#, fuzzy
msgid "Run the application in one terminal (make sure you stop any other native executable container runs before executing this):"
msgstr "在一个终端中运行该应用程序（确保在执行此操作之前停止任何其他本地可执行容器的运行）。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1085
#, fuzzy
msgid "Send a `GET` request multiple times from another terminal:"
msgstr "从另一个终端多次发送一个 `GET` 的请求。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1089
#, no-wrap
msgid "curl -w '\\n' http://localhost:8080/timestamp # run this multiple times\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1094
#, fuzzy
msgid "to see how the current time has been baked into the binary.  This time was calculated when the binary was being built, hence application restarts have no effect."
msgstr "来查看当前时间是如何被植入二进制文件的。这个时间是在构建二进制文件时计算的，因此应用程序的重新启动没有影响。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1098
#, fuzzy
msgid "In some situations, built time initializations can lead to errors when building native executables.  One example is when a value gets computed at build time which is forbidden to reside in the heap of the JVM that gets baked into the binary.  To see this in action, add this REST resource:"
msgstr "在某些情况下，构建时的初始化会导致在构建本地可执行文件时出现错误。其中一个例子是，当一个值在构建时被计算出来，而这个值被禁止存在于JVM的堆中，被烘烤成二进制文件。要看到这个动作，请添加这个REST资源。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1111
#, no-wrap
msgid ""
"import javax.crypto.Cipher;\n"
"import javax.crypto.NoSuchPaddingException;\n"
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import java.nio.charset.StandardCharsets;\n"
"import java.security.KeyPair;\n"
"import java.security.KeyPairGenerator;\n"
"import java.security.NoSuchAlgorithmException;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1114
#, no-wrap
msgid ""
"@Path(\"/encrypt-decrypt\")\n"
"public class EncryptDecryptResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1117
#, no-wrap
msgid ""
"    static final KeyPairGenerator KEY_PAIR_GEN;\n"
"    static final Cipher CIPHER;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1122
#, no-wrap
msgid ""
"    static {\n"
"        try {\n"
"            KEY_PAIR_GEN = KeyPairGenerator.getInstance(\"RSA\");\n"
"            KEY_PAIR_GEN.initialize(1024);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1128
#, no-wrap
msgid ""
"            CIPHER = Cipher.getInstance(\"RSA\");\n"
"        } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {\n"
"            throw new RuntimeException(e);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1133
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/{message}\")\n"
"    public String encryptDecrypt(String message) throws Exception {\n"
"        KeyPair keyPair = KEY_PAIR_GEN.generateKeyPair();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1135
#, no-wrap
msgid "        byte[] text = message.getBytes(StandardCharsets.UTF_8);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1139
#, no-wrap
msgid ""
"        // Encrypt with private key\n"
"        CIPHER.init(Cipher.ENCRYPT_MODE, keyPair.getPrivate());\n"
"        byte[] encrypted = CIPHER.doFinal(text);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1143
#, no-wrap
msgid ""
"        // Decrypt with public key\n"
"        CIPHER.init(Cipher.DECRYPT_MODE, keyPair.getPublic());\n"
"        byte[] unencrypted = CIPHER.doFinal(encrypted);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1147
#, no-wrap
msgid ""
"        return new String(unencrypted, StandardCharsets.UTF_8);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1150
#, fuzzy
msgid "When trying to rebuild the application, you’ll encounter an error:"
msgstr "当试图重建该应用程序时，你会遇到一个错误。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1169
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative\n"
"...\n"
"Error: Unsupported features in 2 methods\n"
"Detailed message:\n"
"Error: Detected an instance of Random/SplittableRandom class in the image heap. Instances created during image generation have cached seed values and don't behave as expected.  To see how this object got instantiated use --trace-object-instantiation=java.security.SecureRandom. The object was probably created by a class initializer and is reachable from a static field. You can request class initialization at image runtime by using the option --initialize-at-run-time=<class-name>. Or you can write your own initialization methods and call them explicitly from your main entry point.\n"
"Trace: Object was reached by\n"
"\treading field java.security.KeyPairGenerator$Delegate.initRandom of\n"
"\t\tconstant java.security.KeyPairGenerator$Delegate@58b0fe1b reached by\n"
"\treading field org.acme.EncryptDecryptResource.KEY_PAIR_GEN\n"
"Error: Detected an instance of Random/SplittableRandom class in the image heap. Instances created during image generation have cached seed values and don't behave as expected.  To see how this object got instantiated use --trace-object-instantiation=java.security.SecureRandom. The object was probably created by a class initializer and is reachable from a static field. You can request class initialization at image runtime by using the option --initialize-at-run-time=<class-name>. Or you can write your own initialization methods and call them explicitly from your main entry point.\n"
"Trace: Object was reached by\n"
"\treading field sun.security.rsa.RSAKeyPairGenerator.random of\n"
"\t\tconstant sun.security.rsa.RSAKeyPairGenerator$Legacy@3248a092 reached by\n"
"\treading field java.security.KeyPairGenerator$Delegate.spi of\n"
"\t\tconstant java.security.KeyPairGenerator$Delegate@58b0fe1b reached by\n"
"\treading field org.acme.EncryptDecryptResource.KEY_PAIR_GEN\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1177
#, fuzzy
msgid "So, what the message above is telling us is that our application caches a value that is supposed to be random as a constant.  This is not desirable because something that's supposed to be random is no longer so, because the seed is baked in the image.  The message above makes it quite clear what is causing this, but in other situations the cause might be more obfuscated.  As a next step, we'll add some extra flags to the native executable generation to get more information."
msgstr "所以，上面的信息告诉我们的是，我们的应用程序将一个应该是随机的值作为常数进行缓存。这是不可取的，因为应该是随机的东西不再是随机的了，因为种子已经在图像中被烤熟了。上面的信息很清楚地说明了造成这种情况的原因，但在其他情况下，原因可能会更加模糊不清。作为下一步，我们将在本地可执行文件的生成中添加一些额外的标志，以获得更多的信息。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1179
#, fuzzy
msgid "As suggested by the message, let's start by adding an option to track object instantiation:"
msgstr "正如消息中所建议的，让我们首先添加一个选项来跟踪对象的实例化。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1209
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.additional-build-args=\"--trace-object-instantiation=java.security.SecureRandom\"\n"
"...\n"
"Error: Unsupported features in 2 methods\n"
"Detailed message:\n"
"Error: Detected an instance of Random/SplittableRandom class in the image heap. Instances created during image generation have cached seed values and don't behave as expected.  Object has been initialized by the com.sun.jndi.dns.DnsClient class initializer with a trace:\n"
" \tat java.security.SecureRandom.<init>(SecureRandom.java:218)\n"
"\tat sun.security.jca.JCAUtil$CachedSecureRandomHolder.<clinit>(JCAUtil.java:59)\n"
"\tat sun.security.jca.JCAUtil.getSecureRandom(JCAUtil.java:69)\n"
"\tat com.sun.jndi.dns.DnsClient.<clinit>(DnsClient.java:82)\n"
". Try avoiding to initialize the class that caused initialization of the object. The object was probably created by a class initializer and is reachable from a static field. You can request class initialization at image runtime by using the option --initialize-at-run-time=<class-name>. Or you can write your own initialization methods and call them explicitly from your main entry point.\n"
"Trace: Object was reached by\n"
"\treading field java.security.KeyPairGenerator$Delegate.initRandom of\n"
"\t\tconstant java.security.KeyPairGenerator$Delegate@4a5058f9 reached by\n"
"\treading field org.acme.EncryptDecryptResource.KEY_PAIR_GEN\n"
"Error: Detected an instance of Random/SplittableRandom class in the image heap. Instances created during image generation have cached seed values and don't behave as expected.  Object has been initialized by the com.sun.jndi.dns.DnsClient class initializer with a trace:\n"
" \tat java.security.SecureRandom.<init>(SecureRandom.java:218)\n"
"\tat sun.security.jca.JCAUtil$CachedSecureRandomHolder.<clinit>(JCAUtil.java:59)\n"
"\tat sun.security.jca.JCAUtil.getSecureRandom(JCAUtil.java:69)\n"
"\tat com.sun.jndi.dns.DnsClient.<clinit>(DnsClient.java:82)\n"
". Try avoiding to initialize the class that caused initialization of the object. The object was probably created by a class initializer and is reachable from a static field. You can request class initialization at image runtime by using the option --initialize-at-run-time=<class-name>. Or you can write your own initialization methods and call them explicitly from your main entry point.\n"
"Trace: Object was reached by\n"
"\treading field sun.security.rsa.RSAKeyPairGenerator.random of\n"
"\t\tconstant sun.security.rsa.RSAKeyPairGenerator$Legacy@71880cf1 reached by\n"
"\treading field java.security.KeyPairGenerator$Delegate.spi of\n"
"\t\tconstant java.security.KeyPairGenerator$Delegate@4a5058f9 reached by\n"
"\treading field org.acme.EncryptDecryptResource.KEY_PAIR_GEN\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1218
#, fuzzy
msgid "The error messages point to the code in the example, but it can be surprising that a reference to `DnsClient` appears.  Why is that? The key is in what happens inside `KeyPairGenerator.initialize()` method call.  It uses `JCAUtil.getSecureRandom()` which is why this is problematic, but sometimes the tracing options can show some stack traces that do not represent what happens in reality.  The best option is to dig through the source code and use tracing output for guidance but not as full truth."
msgstr "错误信息指向例子中的代码，但出现对 `DnsClient` 的引用会让人感到惊讶。这是为什么呢？关键是在 `KeyPairGenerator.initialize()` 方法调用中发生的事情。它使用了 `JCAUtil.getSecureRandom()` ，这就是为什么会出现问题的原因，但有时追踪选项会显示一些堆栈痕迹，但并不代表实际发生的情况。最好的选择是挖掘源代码，使用跟踪输出作为指导，但不作为完全的真相。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1221
#, fuzzy
msgid "Moving the `KEY_PAIR_GEN.initialize(1024);` call to the run-time executed method `encryptDecrypt` is enough to solve this particular issue.  Rebuild the application and verify that encrypt/decrypt endpoint works as expected by sending any message and check if the reply is the same as the incoming message:"
msgstr "将 `KEY_PAIR_GEN.initialize(1024);` 调用到运行时执行的方法 `encryptDecrypt` ，就足以解决这个特殊问题。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1230
#, no-wrap
msgid ""
"$ ./mvnw package -DskipTests -Dnative\n"
"...\n"
"$ docker run -i --rm -p 8080:8080 test/debugging-native:1.0.0-SNAPSHOT\n"
"...\n"
"$ curl -w '\\n' http://localhost:8080/encrypt-decrypt/hellomandrel\n"
"hellomandrel\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1233
#, fuzzy
msgid "Additional information on which classes are initialized and why can be obtained by passing in the `-H:+PrintClassInitialization` flag via `-Dquarkus.native.additional-build-args`."
msgstr "关于哪些类被初始化以及为什么被初始化的其他信息，可以通过 `-Dquarkus.native.additional-build-args` ，传入 `-H:+PrintClassInitialization` 标志获得。"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:1235
#, fuzzy, no-wrap
msgid "Profile Runtime Behaviour"
msgstr "配置文件运行时的行为"

#. type: Title ====
#: upstream/_guides/native-reference.adoc:1237
#, fuzzy, no-wrap
msgid "Single Thread"
msgstr "单线程"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1241
#, fuzzy
msgid "In this exercise, we profile the runtime behaviour of some Quarkus application that was compiled to a native executable to determine where the bottleneck is.  Assume that you’re in a scenario where profiling the pure Java version is not possible, maybe because the issue only occurs with the native version of the application."
msgstr "在这个练习中，我们对一些被编译为本地可执行文件的Quarkus应用程序的运行时行为进行分析，以确定瓶颈所在。假设你处在这样一个场景中，对纯Java版本进行剖析是不可能的，也许是因为这个问题只发生在应用程序的本地版本中。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1244
#, fuzzy
msgid "Add a REST resource with the following code (example courtesy of link:https://github.com/apangin/java-profiling-presentation/blob/master/src/demo1/StringBuilderTest.java[Andrei Pangin's Java Profiling presentation]):"
msgstr "用以下代码添加一个REST资源（例子由 link:https://github.com/apangin/java-profiling-presentation/blob/master/src/demo1/StringBuilderTest.java[Andrei Pangin的Java剖析报告] 提供）。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1256
#, no-wrap
msgid ""
"@Path(\"/string-builder\")\n"
"public class StringBuilderResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1262
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String appendDelete() {\n"
"        StringBuilder sb = new StringBuilder();\n"
"        sb.append(new char[1_000_000]);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1268
#, no-wrap
msgid ""
"        do\n"
"        {\n"
"            sb.append(12345);\n"
"            sb.delete(0, 5);\n"
"        } while (Thread.currentThread().isAlive());\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1272
#, no-wrap
msgid ""
"        return \"Never happens\";\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1275
#, fuzzy
msgid "Recompile the application, rebuild the binary and run it. Attempting a simple curl will never complete, as expected:"
msgstr "重新编译应用程序，重建二进制文件并运行它。试图进行简单的curl操作将永远无法完成，正如预期的那样。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1283
#, no-wrap
msgid ""
"$ ./mvnw package -DskipTests -Dnative\n"
"...\n"
"$ docker run -i --rm -p 8080:8080 test/debugging-native:1.0.0-SNAPSHOT\n"
"...\n"
"$ curl http://localhost:8080/string-builder # this will never complete\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1288
#, fuzzy
msgid "However, the question we’re trying to answer here is: what would be the bottleneck of such code? Is it appending the characters? Is it deleting it? Is it checking whether the thread is alive?"
msgstr "然而，我们在这里试图回答的问题是：这种代码的瓶颈是什么？是追加字符吗？是删除它吗？是检查线程是否活着吗？"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1293
#, fuzzy
msgid "Since we're dealing with a linux native executable, we can use tools like `perf` directly.  To use `perf`, go to the root of the project and start the tools container created earlier as a privileged user:"
msgstr "由于我们处理的是一个linux本地可执行文件，我们可以直接使用像 `perf` 。要使用 `perf` ，请到项目的根目录下，以特权用户的身份启动先前创建的工具容器。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1297
#, no-wrap
msgid "docker run --privileged -t -i --rm -v ${PWD}:/data -p 8080:8080 fedora-tools:v1\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:1304
#, fuzzy
msgid "Note that in order to use `perf` to profile the native executables in the guide, the container needs to run as privileged, or with `--cap-add sys_admin`.  Please note that privileged containers are **NOT** recommended in production, so use this flag with caution!"
msgstr "请注意，为了使用 `perf` 来对指南中的本地可执行文件进行剖析，容器需要以特权身份运行，或者使用 `--cap-add sys_admin` 。请注意， *不* 建议在生产中使用特权容器，所以要谨慎使用这个标志"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1307
#, fuzzy
msgid "Once the container is running, you need to ensure that the kernel is ready for the profiling exercises:"
msgstr "一旦容器运行，你需要确保内核为剖析练习做好准备。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1312
#, no-wrap
msgid ""
"echo -1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n"
"echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:1319
#, fuzzy
msgid "The kernel modifications above also apply to Linux virtual machines.  If running on a bare metal Linux machine, tweaking only `perf_event_paranoid` is enough."
msgstr "上面的内核修改也适用于Linux虚拟机。如果在裸机上运行，只需调整 `perf_event_paranoid` 即可。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1322
#, fuzzy
msgid "Then, from inside the tools container we execute:"
msgstr "然后，我们从工具容器内执行。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1326
#: upstream/_guides/native-reference.adoc:2072
#, no-wrap
msgid "perf record -F 1009 -g -a ./target/debugging-native-1.0.0-SNAPSHOT-runner\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:1337
#, fuzzy
msgid "The `perf record` command above takes `1009` samples per second.  Increasing this value means more samples are gathered, which can end up affecting the runtime performance.  This also increases the amount of data generated.  The more data generated, the longer it takes to process it, but the more precision you get on what the application is doing.  So, finding the right value is a balancing act."
msgstr "上面的 `perf record` 命令每秒采集 `1009` 个样本。增加这个值意味着要收集更多的样本，这最终会影响到运行时的性能。这也会增加生成的数据量。产生的数据越多，处理的时间就越长，但你对应用程序正在做的事情得到的精度就越高。所以，找到正确的值是一个平衡的行为。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1340
#, fuzzy
msgid "While `perf record` is running, open another window and access the endpoint:"
msgstr "当 `perf record` 正在运行时，打开另一个窗口并访问端点。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1344
#, no-wrap
msgid "curl http://localhost:8080/string-builder # this will never complete\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1353
#, fuzzy
msgid "After a few seconds, halt the `perf record` process.  This will generate a `perf.data` file.  We could use `perf report` to inspect the perf data, but you can often get a better picture showing that data as a flame graph.  To generate flame graphs, we will use https://github.com/brendangregg/FlameGraph[FlameGraph GitHub repository], which has already been installed inside the tools container."
msgstr "几秒钟后，停止 `perf record` 进程。这将产生一个 `perf.data` 文件。我们可以使用 `perf report` 来检查perf数据，但你通常可以得到一个更好的图片，将这些数据显示为火焰图。为了生成火焰图，我们将使用 link:https://github.com/brendangregg/FlameGraph[FlameGraph GitHub] 仓库，它已经被安装在工具容器内。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1355
#, fuzzy
msgid "Next, generate a flame graph using the data captured via `perf record`:"
msgstr "接下来，使用通过 `perf record` 捕获的数据生成一个火焰图。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1359
#: upstream/_guides/native-reference.adoc:1423
#: upstream/_guides/native-reference.adoc:1530
#, no-wrap
msgid "perf script -i perf.data | ${FG_HOME}/stackcollapse-perf.pl | ${FG_HOME}/flamegraph.pl > flamegraph.svg\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1363
#, fuzzy
msgid "The flame graph is a svg file that a web browser, such as Firefox, can easily display.  After the above two commands complete one can open `flamegraph.svg` in their browser:"
msgstr "火焰图是一个svg文件，网络浏览器，如火狐，可以轻松显示。上述两个命令完成后，人们可以在浏览器中打开 `flamegraph.svg` 。"

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_guides/native-reference.adoc:1364
#, fuzzy, no-wrap
msgid "Perf flamegraph without symbols"
msgstr "不含符号的香水火焰图"

#. type: Target for macro image
#: upstream/_guides/native-reference.adoc:1364
#, no-wrap
msgid "native-reference-perf-flamegraph-no-symbols.svg"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1373
#, fuzzy
msgid "We see a big majority of time spent in what is supposed to be our main, but we see no trace of the `StringBuilderResource` class, nor the `StringBuilder` class we're calling.  We should look at the symbol table of the binary: can we find symbols for our class and `StringBuilder`? We need those in order to get meaningful data.  From within the tools container, query the symbol table:"
msgstr "我们看到大部分时间都花在了应该是我们的main上，但是我们没有看到 `StringBuilderResource` 类的痕迹，也没有看到我们正在调用的 `StringBuilder` 类。我们应该看一下二进制的符号表：我们能不能找到我们的类和 `StringBuilder` 的符号？我们需要这些符号，以便获得有意义的数据。从工具容器中，查询符号表。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1378
#, no-wrap
msgid ""
"objdump -t ./target/debugging-native-1.0.0-SNAPSHOT-runner | grep StringBuilder\n"
"[no output]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1384
#, fuzzy
msgid "No output appears when querying the symbol table.  This is why we don't see any call graphs in the flame graphs.  This is a deliberate decision that native-image makes.  By default, it removes symbols from the binary."
msgstr "在查询符号表的时候，没有输出出现。这就是为什么我们在火焰图中没有看到任何调用图。这是native-image故意做出的决定。默认情况下，它将符号从二进制文件中删除。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1388
#, fuzzy
msgid "To regain the symbols, we need to rebuild the binary instructing GraalVM not to delete the symbols.  On top of that, enable DWARF debug info so that the stack traces can be populated with that information.  From outside the tools container, execute:"
msgstr "为了重新获得这些符号，我们需要重建二进制文件，指示GraalVM不要删除这些符号。在此基础上，启用DWARF调试信息，以便用这些信息来填充堆栈跟踪。在工具容器之外，执行。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1394
#: upstream/_guides/native-reference.adoc:1509
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.debug.enabled \\\n"
"    -Dquarkus.native.additional-build-args=-H:-DeleteLocalSymbols\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1399
#, fuzzy
msgid "Next, re-enter the tools container if you exited, and inspect the native executable with `objdump`, and see how the symbols are now present:"
msgstr "接下来，如果你退出了，重新进入工具容器，用 `objdump` ，检查本地可执行文件，看看符号现在是如何出现的。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1406
#, no-wrap
msgid ""
"$ objdump -t ./target/debugging-native-1.0.0-SNAPSHOT-runner | grep StringBuilder\n"
"000000000050a940 l     F .text\t0000000000000091              .hidden ReflectionAccessorHolder_StringBuilderResource_appendDelete_9e06d4817d0208a0cce97ebcc0952534cac45a19_e22addf7d3eaa3ad14013ce01941dc25beba7621\n"
"000000000050a9e0 l     F .text\t00000000000000bb              .hidden ReflectionAccessorHolder_StringBuilderResource_constructor_0f8140ea801718b80c05b979a515d8a67b8f3208_12baae06bcd6a1ef9432189004ae4e4e176dd5a4\n"
"...\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1409
#, fuzzy
msgid "You should see a long list of symbols that match that pattern."
msgstr "你应该看到一长串符合该模式的符号。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1412
#, fuzzy
msgid "Then, run the executable through perf, *indicating that the call graph is dwarf*:"
msgstr "然后，通过perf运行该可执行文件， *表明调用图是侏儒* 的。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1416
#: upstream/_guides/native-reference.adoc:1516
#, no-wrap
msgid "perf record -F 1009 --call-graph dwarf -a ./target/debugging-native-1.0.0-SNAPSHOT-runner\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1419
#, fuzzy
msgid "Run the curl command once again, stop the binary, generate the flamegraphs and open it:"
msgstr "再次运行curl命令，停止二进制，生成flamegraphs并打开它。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1428
#, fuzzy
msgid "The flamegraph now shows where the bottleneck is.  It's when `StringBuilder.delete()` is called which calls `System.arraycopy()`.  The issue is that 1 million characters need to be shifted in very small increments:"
msgstr "现在的火焰图显示了瓶颈所在。这是在调用 `StringBuilder.delete()` ，而后调用 `System.arraycopy()` 。问题是，100万个字符需要以非常小的增量进行移位。"

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_guides/native-reference.adoc:1429
#, fuzzy, no-wrap
msgid "Perf flamegraph with symbols"
msgstr "带符号的火焰图（Perf flamegraph"

#. type: Target for macro image
#: upstream/_guides/native-reference.adoc:1429
#, no-wrap
msgid "native-reference-perf-flamegraph-symbols.svg"
msgstr ""

#. type: Title ====
#: upstream/_guides/native-reference.adoc:1431
#, fuzzy, no-wrap
msgid "Multi-Thread"
msgstr "多线程"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1436
#, fuzzy
msgid "Multithreaded programs might require special attention when trying to understand their runtime behaviour.  To demonstrate this, add this `MulticastResource` code to your project (example courtesy of link:https://github.com/apangin/java-profiling-presentation/blob/master/src/demo6/DatagramTest.java[Andrei Pangin's Java Profiling presentation]):"
msgstr "多线程程序在试图理解其运行时行为时可能需要特别注意。为了证明这一点，请在你的项目中添加这段 `MulticastResource` 代码（例子由 link:https://github.com/apangin/java-profiling-presentation/blob/master/src/demo6/DatagramTest.java[Andrei Pangin的Java分析报告] 提供）。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1452
#, no-wrap
msgid ""
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.Produces;\n"
"import jakarta.ws.rs.core.MediaType;\n"
"import java.net.InetSocketAddress;\n"
"import java.nio.ByteBuffer;\n"
"import java.nio.channels.DatagramChannel;\n"
"import java.util.concurrent.ExecutorService;\n"
"import java.util.concurrent.Executors;\n"
"import java.util.concurrent.ThreadFactory;\n"
"import java.util.concurrent.atomic.AtomicInteger;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1462
#, no-wrap
msgid ""
"@Path(\"/multicast\")\n"
"public class MulticastResource\n"
"{\n"
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String send() throws Exception {\n"
"        sendMulticasts();\n"
"        return \"Multicast packets sent\";\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1467
#, no-wrap
msgid ""
"    static void sendMulticasts() throws Exception {\n"
"        DatagramChannel ch = DatagramChannel.open();\n"
"        ch.bind(new InetSocketAddress(5555));\n"
"        ch.configureBlocking(false);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1475
#, no-wrap
msgid ""
"        ExecutorService pool =\n"
"            Executors.newCachedThreadPool(new ShortNameThreadFactory());\n"
"        for (int i = 0; i < 10; i++) {\n"
"            pool.submit(() -> {\n"
"                final ByteBuffer buf = ByteBuffer.allocateDirect(1000);\n"
"                final InetSocketAddress remoteAddr =\n"
"                    new InetSocketAddress(\"127.0.0.1\", 5556);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1482
#, no-wrap
msgid ""
"                while (true) {\n"
"                    buf.clear();\n"
"                    ch.send(buf, remoteAddr);\n"
"                }\n"
"            });\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1485
#, no-wrap
msgid ""
"        System.out.println(\"Warming up...\");\n"
"        Thread.sleep(3000);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1489
#, no-wrap
msgid ""
"        System.out.println(\"Benchmarking...\");\n"
"        Thread.sleep(5000);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1491
#, no-wrap
msgid "    private static final class ShortNameThreadFactory implements ThreadFactory {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1494
#, no-wrap
msgid ""
"        private final AtomicInteger threadNumber = new AtomicInteger(1);\n"
"        private final String namePrefix = \"thread-\";\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1500
#, no-wrap
msgid ""
"        public Thread newThread(Runnable r) {\n"
"            return new Thread(r, namePrefix + threadNumber.getAndIncrement());\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1503
#, fuzzy
msgid "Build the native executable with debug info:"
msgstr "构建带有调试信息的本地可执行文件。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1512
#, fuzzy
msgid "From inside the tools container (as privileged user) run the native executable through `perf`:"
msgstr "在工具容器内（作为特权用户）通过 `perf` ，运行本地可执行文件。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1519
#, fuzzy
msgid "Invoke the endpoint to send the multicast packets:"
msgstr "调用端点来发送组播数据包。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1523
#, no-wrap
msgid "curl -w '\\n' http://localhost:8080/multicast\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1526
#, fuzzy
msgid "Make and open a flamegraph:"
msgstr "制作并打开一个火焰图。"

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_guides/native-reference.adoc:1532
#, fuzzy, no-wrap
msgid "Muti-thread perf flamegraph with separate threads"
msgstr "有独立线程的多线程perf flamegraph"

#. type: Target for macro image
#: upstream/_guides/native-reference.adoc:1532
#, no-wrap
msgid "native-reference-multi-flamegraph-separate-threads.svg"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1536
#, fuzzy
msgid "The flamegraph produced looks odd. Each thread is treated independently even though they all do the same work.  This makes it difficult to have a clear picture of the bottlenecks in the program."
msgstr "产生的火焰图看起来很奇怪。每个线程都被独立处理，尽管它们都做同样的工作。这使得我们很难对程序中的瓶颈有一个清晰的认识。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1539
#, fuzzy
msgid "This is happening because from a `perf` perspective, each thread is a different command.  We can see that if we inspect `perf report`:"
msgstr "发生这种情况是因为从 `perf` 的角度来看，每个线程都是一个不同的命令。我们可以看到，如果我们检查 `perf report` 。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1550
#, no-wrap
msgid ""
"perf report --stdio\n"
"# Children      Self  Command          Shared Object       Symbol\n"
"# ........  ........  ...............  ......................................  ......................................................................................\n"
"...\n"
"     6.95%     0.03%  thread-2         debugging-native-1.0.0-SNAPSHOT-runner  [.] MulticastResource_lambda$sendMulticasts$0_cb1f7b5dcaed7dd4e3f90d18bad517d67eae4d88\n"
"...\n"
"     4.60%     0.02%  thread-10        debugging-native-1.0.0-SNAPSHOT-runner  [.] MulticastResource_lambda$sendMulticasts$0_cb1f7b5dcaed7dd4e3f90d18bad517d67eae4d88\n"
"...\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1554
#, fuzzy
msgid "This can be worked around by applying some modifications to the perf output, in order to make all threads have the same name. E.g."
msgstr "这可以通过对perf输出进行一些修改来解决，以使所有线程具有相同的名称。例如"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1558
#, no-wrap
msgid "perf script | sed -E \"s/thread-[0-9]*/thread/\" | ${FG_HOME}/stackcollapse-perf.pl | ${FG_HOME}/flamegraph.pl > flamegraph.svg\n"
msgstr ""

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_guides/native-reference.adoc:1560
#, fuzzy, no-wrap
msgid "Muti-thread perf flamegraph with joined threads"
msgstr "带有连接线程的多线程香水火焰图"

#. type: Target for macro image
#: upstream/_guides/native-reference.adoc:1560
#, no-wrap
msgid "native-reference-multi-flamegraph-joined-threads.svg"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1564
#, fuzzy
msgid "When you open the flamegraph, you will see all threads' work collapsed into a single area.  Then, you can clearly see that there's some locking that could affect performance."
msgstr "当你打开flamegraph时，你会看到所有线程的工作都被折叠成一个区域。然后，你可以清楚地看到，有一些锁可能会影响性能。"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:1566
#, fuzzy, no-wrap
msgid "Debugging Native Crashes"
msgstr "调试本地崩溃"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1573
#, fuzzy
msgid "One of the drawbacks of using native executables is that they cannot be debugged using the standard Java debuggers, instead we need to debug them using `gdb`, the GNU Project debugger.  To demonstrate how to do this, we are going to generate a native Quarkus application that crashes due to a Segmentation Fault when accessing http://localhost:8080/crash.  To achieve this, add the following REST resource to the project:"
msgstr "使用本地可执行文件的一个缺点是不能用标准的Java调试器进行调试，相反，我们需要用 `gdb` ，即GNU项目调试器进行调试。为了演示如何做到这一点，我们将生成一个本地Quarkus应用程序，该程序在访问 http://localhost:8080/crash ，由于分段故障而崩溃 http://localhost:8080/crash 为了达到这个目的，请在项目中添加以下REST资源。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1579
#, no-wrap
msgid "import sun.misc.Unsafe;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1585
#, no-wrap
msgid ""
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.Produces;\n"
"import jakarta.ws.rs.core.MediaType;\n"
"import java.lang.reflect.Field;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1588
#, no-wrap
msgid ""
"@Path(\"/crash\")\n"
"public class CrashResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1604
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        Field theUnsafe = null;\n"
"        try {\n"
"            theUnsafe = Unsafe.class.getDeclaredField(\"theUnsafe\");\n"
"            theUnsafe.setAccessible(true);\n"
"            Unsafe unsafe = (Unsafe) theUnsafe.get(null);\n"
"            unsafe.copyMemory(0, 128, 256);\n"
"        } catch (NoSuchFieldException | IllegalAccessException e) {\n"
"            e.printStackTrace();\n"
"        }\n"
"        return \"Never happens\";\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1608
#, fuzzy
msgid "This code will try to copy 256 bytes from address `0x0` to `0x80` resulting in a Segmentation Fault.  To verify this, compile and run the example application:"
msgstr "这段代码将尝试从地址 `0x0` 复制256字节到 `0x80` ，导致分段故障。为了验证这一点，编译并运行示例程序。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1616
#, no-wrap
msgid ""
"$ ./mvnw package -DskipTests -Dnative\n"
"...\n"
"$ docker run -i --rm -p 8080:8080 test/debugging-native:1.0.0-SNAPSHOT\n"
"...\n"
"$ curl http://localhost:8080/crash\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1619
#, fuzzy
msgid "This will result in the following output:"
msgstr "这将导致以下输出。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1626
#, no-wrap
msgid ""
"$ docker run -i --rm -p 8080:8080 test/debugging-native:1.0.0-SNAPSHOT\n"
"...\n"
"Segfault detected, aborting process. Use runtime option -R:-InstallSegfaultHandler if you don't want to use SubstrateSegfaultHandler.\n"
"...\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1632
#, fuzzy
msgid "The omitted output above contains clues to what caused the issue, but in this exercise we are going to assume that no information was provided.  Let’s try to debug the segmentation fault using `gdb`.  To do that, go to the root of the project and enter the tools container:"
msgstr "上面省略的输出包含了导致该问题的线索，但在这个练习中，我们将假设没有提供任何信息。让我们试着用 `gdb` 来调试分段故障。要做到这一点，请到项目的根部，进入工具容器。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1636
#, no-wrap
msgid "docker run -t -i --rm -v ${PWD}:/data -p 8080:8080 fedora-tools:v1 /bin/bash\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1639
#, fuzzy
msgid "Then start the application in `gdb` and execute `run`."
msgstr "然后在 `gdb` 中启动应用程序并执行 `run` 。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1648
#, no-wrap
msgid ""
"gdb ./target/debugging-native-1.0.0-SNAPSHOT-runner\n"
"...\n"
"Reading symbols from ./target/debugging-native-1.0.0-SNAPSHOT-runner...\n"
"(No debugging symbols found in ./target/debugging-ntaive-1.0.0-SNAPSHOT-runner)\n"
"(gdb) run\n"
"Starting program: /data/target/debugging-native-1.0.0-SNAPSHOT-runner\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1651
#, fuzzy
msgid "Next, try to access http://localhost:8080/crash:"
msgstr "接下来，尝试访问 http://localhost:8080/crash "

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1654
#, no-wrap
msgid "curl http://localhost:8080/crash\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1657
#: upstream/_guides/native-reference.adoc:1701
#, fuzzy
msgid "This will result in the following message in `gdb`:"
msgstr "这将导致 `gdb` 中出现以下信息。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1663
#, no-wrap
msgid ""
"Thread 4 \"ecutor-thread-0\" received signal SIGSEGV, Segmentation fault.\n"
"[Switching to Thread 0x7fe103dff640 (LWP 190)]\n"
"0x0000000000461f6e in ?? ()\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1666
#, fuzzy
msgid "If we try to get more info about the backtrace that led to this crash we will see that there is not enough information available."
msgstr "如果我们试图获得更多关于导致这次崩溃的回溯信息，我们会发现没有足够的信息可用。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1677
#, no-wrap
msgid ""
"(gdb) bt\n"
"#0  0x0000000000418b5e in ?? ()\n"
"#1  0x00007ffff6f2d328 in ?? ()\n"
"#2  0x0000000000418a04 in ?? ()\n"
"#3  0x00007ffff44062a0 in ?? ()\n"
"#4  0x00000000010c3dd3 in ?? ()\n"
"#5  0x0000000000000100 in ?? ()\n"
"#6  0x0000000000000000 in ?? ()\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1682
#, fuzzy
msgid "This is because we didn’t compile the Quarkus application with `-Dquarkus.native.debug.enabled`, so `gdb` cannot find debugging symbols for our native executable, as indicated by the \"_No debugging symbols found in ./target/debugging-native-1.0.0-SNAPSHOT-runner_\" message in the beginning of `gdb`."
msgstr "这是因为我们没有用 `-Dquarkus.native.debug.enabled` 编译 Quarkus 应用程序，所以 `gdb` 不能为我们的本地可执行文件找到调试符号，正如 `gdb` 开头的 _\"在 ./target/debugging-native-1.0.0-SNAPSHOT-runner 中没有找到调试符号_ \"信息所示。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1685
#, fuzzy
msgid "Recompiling the Quarkus application with `-Dquarkus.native.debug.enabled` and rerunning it through `gdb` we are now able to get a backtrace making clear what caused the crash.  On top of that, add `-H:-OmitInlinedMethodDebugLineInfo` option to avoid inlined methods being omitted from the backtrace:"
msgstr "用 `-Dquarkus.native.debug.enabled` 重新编译Quarkus应用程序，并通过 `gdb` 重新运行，我们现在能够得到一个回溯，清楚地知道是什么原因导致了崩溃。在此基础上，添加 `-H:-OmitInlinedMethodDebugLineInfo` 选项，以避免内联方法被从回溯中省略。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1698
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.debug.enabled \\\n"
"    -Dquarkus.native.additional-build-args=-H:-OmitInlinedMethodDebugLineInfo\n"
"...\n"
"$ gdb ./target/debugging-native-1.0.0-SNAPSHOT-runner\n"
"Reading symbols from ./target/debugging-native-1.0.0-SNAPSHOT-runner...\n"
"(gdb) run\n"
"Starting program: /data/target/debugging-native-1.0.0-SNAPSHOT-runner\n"
"...\n"
"$ curl http://localhost:8080/crash\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1709
#, no-wrap
msgid ""
"Thread 4 \"ecutor-thread-0\" received signal SIGSEGV, Segmentation fault.\n"
"[Switching to Thread 0x7fffeffff640 (LWP 362984)]\n"
"com.oracle.svm.core.UnmanagedMemoryUtil::copyLongsBackward(org.graalvm.word.Pointer *, org.graalvm.word.Pointer *, org.graalvm.word.UnsignedWord *) ()\n"
"\tat com/oracle/svm/core/UnmanagedMemoryUtil.java:169\n"
"169    com/oracle/svm/core/UnmanagedMemoryUtil.java: No such file or directory.\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1713
#, fuzzy
msgid "We already see that `gdb` is able to tell us which method caused the crash and where it’s located in the source code.  We can also get a backtrace of the call graph that led us to this state:"
msgstr "我们已经看到， `gdb` ，能够告诉我们哪个方法导致了崩溃，以及它在源代码中的位置。我们还可以得到导致我们进入这种状态的调用图的回溯。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1726
#, no-wrap
msgid ""
"(gdb) bt\n"
"#0  com.oracle.svm.core.UnmanagedMemoryUtil::copyLongsBackward(org.graalvm.word.Pointer *, org.graalvm.word.Pointer *, org.graalvm.word.UnsignedWord *) () at com/oracle/svm/core/UnmanagedMemoryUtil.java:169\n"
"#1  0x0000000000461e14 in com.oracle.svm.core.UnmanagedMemoryUtil::copyBackward(org.graalvm.word.Pointer *, org.graalvm.word.Pointer *, org.graalvm.word.UnsignedWord *) () at com/oracle/svm/core/UnmanagedMemoryUtil.java:110\n"
"#2  0x0000000000461dc8 in com.oracle.svm.core.UnmanagedMemoryUtil::copy(org.graalvm.word.Pointer *, org.graalvm.word.Pointer *, org.graalvm.word.UnsignedWord *) () at com/oracle/svm/core/UnmanagedMemoryUtil.java:67\n"
"#3  0x000000000045d3c0 in com.oracle.svm.core.JavaMemoryUtil::unsafeCopyMemory(java.lang.Object *, long, java.lang.Object *, long, long) () at com/oracle/svm/core/JavaMemoryUtil.java:276\n"
"#4  0x00000000013277de in jdk.internal.misc.Unsafe::copyMemory0 () at com/oracle/svm/core/jdk/SunMiscSubstitutions.java:125\n"
"#5  jdk.internal.misc.Unsafe::copyMemory(java.lang.Object *, long, java.lang.Object *, long, long) () at jdk/internal/misc/Unsafe.java:788\n"
"#6  0x00000000013b1a3f in jdk.internal.misc.Unsafe::copyMemory () at jdk/internal/misc/Unsafe.java:799\n"
"#7  sun.misc.Unsafe::copyMemory () at sun/misc/Unsafe.java:585\n"
"#8  org.acme.CrashResource::hello(void) () at org/acme/CrashResource.java:22\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1729
#, fuzzy
msgid "Similarly, we can get a backtrace of the call graph of other threads."
msgstr "同样地，我们可以得到其他线程的调用图的回溯。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1731
#, fuzzy
msgid "First, we can list the available threads with:"
msgstr "首先，我们可以用以下方法列出可用的线程。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1742
#, no-wrap
msgid ""
"(gdb) info threads\n"
"  Id   Target Id                                             Frame\n"
"  1    Thread 0x7fcc62a07d00 (LWP 322) \"debugging-nativ\" 0x00007fcc62b8b77a in __futex_abstimed_wait_common () from /lib64/libc.so.6\n"
"  2    Thread 0x7fcc60eff640 (LWP 326) \"gnal Dispatcher\" 0x00007fcc62b8b77a in __futex_abstimed_wait_common () from /lib64/libc.so.6\n"
"* 4    Thread 0x7fcc5b7fe640 (LWP 328) \"ecutor-thread-0\" com.oracle.svm.core.UnmanagedMemoryUtil::copyLongsBackward(org.graalvm.word.Pointer *, org.graalvm.word.Pointer *, org.graalvm.word.UnsignedWord *) () at com/oracle/svm/core/UnmanagedMemoryUtil.java:169\n"
"  5    Thread 0x7fcc5abff640 (LWP 329) \"-thread-checker\" 0x00007fcc62b8b77a in __futex_abstimed_wait_common () from /lib64/libc.so.6\n"
"  6    Thread 0x7fcc59dff640 (LWP 330) \"ntloop-thread-0\" 0x00007fcc62c12c9e in epoll_wait () from /lib64/libc.so.6\n"
"...\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1745
#, fuzzy
msgid "select the thread we want to inspect, e.g. thread 1:"
msgstr "选择我们要检查的线程，例如线程1。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1752
#, no-wrap
msgid ""
"(gdb) thread 1\n"
"[Switching to thread 1 (Thread 0x7ffff7a58d00 (LWP 1028851))]\n"
"#0  __futex_abstimed_wait_common64 (private=0, cancel=true, abstime=0x0, op=393, expected=0, futex_word=0x2cd7adc) at futex-internal.c:57\n"
"57\t    return INTERNAL_SYSCALL_CANCEL (futex_time64, futex_word, op, expected,\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1755
#, fuzzy
msgid "and, finally, print the stack trace:"
msgstr "最后，打印堆栈跟踪。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1783
#, no-wrap
msgid ""
"(gdb) bt\n"
"#0  __futex_abstimed_wait_common64 (private=0, cancel=true, abstime=0x0, op=393, expected=0, futex_word=0x2cd7adc) at futex-internal.c:57\n"
"#1  __futex_abstimed_wait_common (futex_word=futex_word@entry=0x2cd7adc, expected=expected@entry=0, clockid=clockid@entry=0, abstime=abstime@entry=0x0, private=private@entry=0,\n"
"    cancel=cancel@entry=true) at futex-internal.c:87\n"
"#2  0x00007ffff7bdd79f in __GI___futex_abstimed_wait_cancelable64 (futex_word=futex_word@entry=0x2cd7adc, expected=expected@entry=0, clockid=clockid@entry=0, abstime=abstime@entry=0x0,\n"
"    private=private@entry=0) at futex-internal.c:139\n"
"#3  0x00007ffff7bdfeb0 in __pthread_cond_wait_common (abstime=0x0, clockid=0, mutex=0x2ca07b0, cond=0x2cd7ab0) at pthread_cond_wait.c:504\n"
"#4  ___pthread_cond_wait (cond=0x2cd7ab0, mutex=0x2ca07b0) at pthread_cond_wait.c:619\n"
"#5  0x00000000004e2014 in com.oracle.svm.core.posix.headers.Pthread::pthread_cond_wait () at com/oracle/svm/core/posix/thread/PosixJavaThreads.java:252\n"
"#6  com.oracle.svm.core.posix.thread.PosixParkEvent::condWait(void) () at com/oracle/svm/core/posix/thread/PosixJavaThreads.java:252\n"
"#7  0x0000000000547070 in com.oracle.svm.core.thread.JavaThreads::park(void) () at com/oracle/svm/core/thread/JavaThreads.java:764\n"
"#8  0x0000000000fc5f44 in jdk.internal.misc.Unsafe::park(boolean, long) () at com/oracle/svm/core/thread/Target_jdk_internal_misc_Unsafe_JavaThreads.java:49\n"
"#9  0x0000000000eac1ad in java.util.concurrent.locks.LockSupport::park(java.lang.Object *) () at java/util/concurrent/locks/LockSupport.java:194\n"
"#10 0x0000000000ea5d68 in java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject::awaitUninterruptibly(void) ()\n"
"    at java/util/concurrent/locks/AbstractQueuedSynchronizer.java:2018\n"
"#11 0x00000000008b6b30 in io.quarkus.runtime.ApplicationLifecycleManager::run(io.quarkus.runtime.Application *, java.lang.Class *, java.util.function.BiConsumer *, java.lang.String[] *) ()\n"
"    at io/quarkus/runtime/ApplicationLifecycleManager.java:144\n"
"#12 0x00000000008bc055 in io.quarkus.runtime.Quarkus::run(java.lang.Class *, java.util.function.BiConsumer *, java.lang.String[] *) () at io/quarkus/runtime/Quarkus.java:67\n"
"#13 0x000000000045c88b in io.quarkus.runtime.Quarkus::run () at io/quarkus/runtime/Quarkus.java:41\n"
"#14 io.quarkus.runtime.Quarkus::run () at io/quarkus/runtime/Quarkus.java:120\n"
"#15 0x000000000045c88b in io.quarkus.runner.GeneratedMain::main ()\n"
"#16 com.oracle.svm.core.JavaMainWrapper::runCore () at com/oracle/svm/core/JavaMainWrapper.java:150\n"
"#17 com.oracle.svm.core.JavaMainWrapper::run(int, org.graalvm.nativeimage.c.type.CCharPointerPointer *) () at com/oracle/svm/core/JavaMainWrapper.java:186\n"
"#18 0x000000000048084d in com.oracle.svm.core.code.IsolateEnterStub::JavaMainWrapper_run_5087f5482cc9a6abc971913ece43acb471d2631b(int, org.graalvm.nativeimage.c.type.CCharPointerPointer *)\n"
"    () at com/oracle/svm/core/JavaMainWrapper.java:280\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1786
#, fuzzy
msgid "Alternatively, we can list the backtraces of all threads with a single command:"
msgstr "另外，我们也可以用一条命令列出所有线程的回溯记录。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1790
#, no-wrap
msgid "(gdb) thread apply all backtrace\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1810
#, no-wrap
msgid ""
"Thread 22 (Thread 0x7fffc8dff640 (LWP 1028872) \"tloop-thread-15\"):\n"
"#0  0x00007ffff7c64c2e in epoll_wait (epfd=8, events=0x2ca3880, maxevents=1024, timeout=-1) at ../sysdeps/unix/sysv/linux/epoll_wait.c:30\n"
"#1  0x000000000166e01c in Java_sun_nio_ch_EPoll_wait ()\n"
"#2  0x00000000011bfece in sun.nio.ch.EPoll::wait(int, long, int, int) () at com/oracle/svm/core/stack/JavaFrameAnchors.java:42\n"
"#3  0x00000000011c08d2 in sun.nio.ch.EPollSelectorImpl::doSelect(java.util.function.Consumer *, long) () at sun/nio/ch/EPollSelectorImpl.java:120\n"
"#4  0x00000000011d8977 in sun.nio.ch.SelectorImpl::lockAndDoSelect(java.util.function.Consumer *, long) () at sun/nio/ch/SelectorImpl.java:124\n"
"#5  0x0000000000705720 in sun.nio.ch.SelectorImpl::select () at sun/nio/ch/SelectorImpl.java:141\n"
"#6  io.netty.channel.nio.SelectedSelectionKeySetSelector::select(void) () at io/netty/channel/nio/SelectedSelectionKeySetSelector.java:68\n"
"#7  0x0000000000703c2e in io.netty.channel.nio.NioEventLoop::select(long) () at io/netty/channel/nio/NioEventLoop.java:813\n"
"#8  0x0000000000701a5f in io.netty.channel.nio.NioEventLoop::run(void) () at io/netty/channel/nio/NioEventLoop.java:460\n"
"#9  0x00000000008496df in io.netty.util.concurrent.SingleThreadEventExecutor$4::run(void) () at io/netty/util/concurrent/SingleThreadEventExecutor.java:986\n"
"#10 0x0000000000860762 in io.netty.util.internal.ThreadExecutorMap$2::run(void) () at io/netty/util/internal/ThreadExecutorMap.java:74\n"
"#11 0x0000000000840da4 in io.netty.util.concurrent.FastThreadLocalRunnable::run(void) () at io/netty/util/concurrent/FastThreadLocalRunnable.java:30\n"
"#12 0x0000000000b7dd04 in java.lang.Thread::run(void) () at java/lang/Thread.java:829\n"
"#13 0x0000000000547dcc in com.oracle.svm.core.thread.JavaThreads::threadStartRoutine(org.graalvm.nativeimage.ObjectHandle *) () at com/oracle/svm/core/thread/JavaThreads.java:597\n"
"#14 0x00000000004e15b1 in com.oracle.svm.core.posix.thread.PosixJavaThreads::pthreadStartRoutine(com.oracle.svm.core.thread.JavaThreads$ThreadStartData *) () at com/oracle/svm/core/posix/thread/PosixJavaThreads.java:194\n"
"#15 0x0000000000480984 in com.oracle.svm.core.code.IsolateEnterStub::PosixJavaThreads_pthreadStartRoutine_e1f4a8c0039f8337338252cd8734f63a79b5e3df(com.oracle.svm.core.thread.JavaThreads$ThreadStartData *) () at com/oracle/svm/core/posix/thread/PosixJavaThreads.java:182\n"
"#16 0x00007ffff7be0b1a in start_thread (arg=<optimized out>) at pthread_create.c:443\n"
"#17 0x00007ffff7c65650 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1830
#, no-wrap
msgid ""
"Thread 21 (Thread 0x7fffc97fa640 (LWP 1028871) \"tloop-thread-14\"):\n"
"#0  0x00007ffff7c64c2e in epoll_wait (epfd=53, events=0x2cd0970, maxevents=1024, timeout=-1) at ../sysdeps/unix/sysv/linux/epoll_wait.c:30\n"
"#1  0x000000000166e01c in Java_sun_nio_ch_EPoll_wait ()\n"
"#2  0x00000000011bfece in sun.nio.ch.EPoll::wait(int, long, int, int) () at com/oracle/svm/core/stack/JavaFrameAnchors.java:42\n"
"#3  0x00000000011c08d2 in sun.nio.ch.EPollSelectorImpl::doSelect(java.util.function.Consumer *, long) () at sun/nio/ch/EPollSelectorImpl.java:120\n"
"#4  0x00000000011d8977 in sun.nio.ch.SelectorImpl::lockAndDoSelect(java.util.function.Consumer *, long) () at sun/nio/ch/SelectorImpl.java:124\n"
"#5  0x0000000000705720 in sun.nio.ch.SelectorImpl::select () at sun/nio/ch/SelectorImpl.java:141\n"
"#6  io.netty.channel.nio.SelectedSelectionKeySetSelector::select(void) () at io/netty/channel/nio/SelectedSelectionKeySetSelector.java:68\n"
"#7  0x0000000000703c2e in io.netty.channel.nio.NioEventLoop::select(long) () at io/netty/channel/nio/NioEventLoop.java:813\n"
"#8  0x0000000000701a5f in io.netty.channel.nio.NioEventLoop::run(void) () at io/netty/channel/nio/NioEventLoop.java:460\n"
"#9  0x00000000008496df in io.netty.util.concurrent.SingleThreadEventExecutor$4::run(void) () at io/netty/util/concurrent/SingleThreadEventExecutor.java:986\n"
"#10 0x0000000000860762 in io.netty.util.internal.ThreadExecutorMap$2::run(void) () at io/netty/util/internal/ThreadExecutorMap.java:74\n"
"#11 0x0000000000840da4 in io.netty.util.concurrent.FastThreadLocalRunnable::run(void) () at io/netty/util/concurrent/FastThreadLocalRunnable.java:30\n"
"#12 0x0000000000b7dd04 in java.lang.Thread::run(void) () at java/lang/Thread.java:829\n"
"#13 0x0000000000547dcc in com.oracle.svm.core.thread.JavaThreads::threadStartRoutine(org.graalvm.nativeimage.ObjectHandle *) () at com/oracle/svm/core/thread/JavaThreads.java:597\n"
"#14 0x00000000004e15b1 in com.oracle.svm.core.posix.thread.PosixJavaThreads::pthreadStartRoutine(com.oracle.svm.core.thread.JavaThreads$ThreadStartData *) () at com/oracle/svm/core/posix/thread/PosixJavaThreads.java:194\n"
"#15 0x0000000000480984 in com.oracle.svm.core.code.IsolateEnterStub::PosixJavaThreads_pthreadStartRoutine_e1f4a8c0039f8337338252cd8734f63a79b5e3df(com.oracle.svm.core.thread.JavaThreads$ThreadStartData *) () at com/oracle/svm/core/posix/thread/PosixJavaThreads.java:182\n"
"#16 0x00007ffff7be0b1a in start_thread (arg=<optimized out>) at pthread_create.c:443\n"
"#17 0x00007ffff7c65650 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1833
#, no-wrap
msgid ""
"Thread 20 (Thread 0x7fffc9ffb640 (LWP 1028870) \"tloop-thread-13\"):\n"
"...\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1836
#, fuzzy
msgid "Note, however, that despite being able to get a backtrace we can still not list the source code at point with the `list` command."
msgstr "然而，请注意，尽管能够得到一个回溯，我们仍然不能用 `list` 命令列出点的源代码。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1841
#, no-wrap
msgid ""
"(gdb) list\n"
"164    in com/oracle/svm/core/UnmanagedMemoryUtil.java\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1847
#, fuzzy
msgid "This is because `gdb` is not aware of the location of the source files.  We are running the executable outside the target directory.  To fix this we can either rerun `gdb` from the target directory or, run `directory target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar/sources` e.g.:"
msgstr "这是因为 `gdb` ，不知道源文件的位置。我们在目标目录之外运行可执行文件。为了解决这个问题，我们可以从目标目录中重新运行 `gdb` ，或者，运行 `directory target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar/sources` ，例如。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1863
#, no-wrap
msgid ""
"(gdb) directory target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar/sources\n"
"Source directories searched: /data/target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar/sources:$cdir:$cwd\n"
"(gdb) list\n"
"164        \tUnsignedWord offset = size;\n"
"165        \twhile (offset.aboveOrEqual(32)) {\n"
"166            \toffset = offset.subtract(32);\n"
"167            \tPointer src = from.add(offset);\n"
"168            \tPointer dst = to.add(offset);\n"
"169            \tlong l24 = src.readLong(24);\n"
"170            \tlong l16 = src.readLong(16);\n"
"171            \tlong l8 = src.readLong(8);\n"
"172            \tlong l0 = src.readLong(0);\n"
"173            \tdst.writeLong(24, l24);\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1870
#, fuzzy
msgid "We can now examine line `169` and get a first hint of what might be wrong (in this case we see that it fails at the first read from src which contains the address `0x0000`), or walk up the stack using `gdb`’s `up` command to see what part of our code led to this situation.  To learn more about using gdb to debug native executables see https://www.graalvm.org/{graalvm-version}/reference-manual/native-image/debugging-and-diagnostics/DebugInfo/[here]."
msgstr "我们现在可以检查第 `169` 行，并得到可能出错的第一个提示（在这种情况下，我们看到它在第一次从包含地址 `0x0000` 的 src 读取时失败了），或者使用 `gdb` 's `up` 命令在堆栈上行走，看看我们代码的哪一部分导致了这种情况。要了解更多关于使用gdb来调试本地可执行文件的信息，请看 link:https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/DebugInfo.md[这里] 。"

#. type: Title ==
#: upstream/_guides/native-reference.adoc:1872
#, fuzzy, no-wrap
msgid "Frequently Asked Questions"
msgstr "常见问题"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:1874
#, fuzzy, no-wrap
msgid "Why is the process of generating a native executable slow?"
msgstr "为什么生成本地可执行文件的过程很慢？"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1878
#, fuzzy
msgid "Native executable generation is a multi-step process.  The analysis and compile steps are the most expensive of all and hence the ones that dominate the time spent generating the native executable."
msgstr "本地可执行文件的生成是一个多步骤的过程。分析和编译步骤是所有步骤中最昂贵的，因此在生成本地可执行文件的时间中占主导地位。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1884
#, fuzzy
msgid "In the analysis phase, a static points-to analysis starts from the main method of the program to find out what is reachable.  As new classes are discovered, some of them will be initialized during this process depending on the configuration.  In the next step, the heap is snapshotted and checks are made to see which types need to be available at runtime.  The initialization and heap snapshotting can cause new types to be discovered, in which case the process is repeated.  The process stops when a fixed point is reached, that is when the reachable program grows no more."
msgstr "在分析阶段，静态的点对点分析从程序的主方法开始，找出可达到的东西。随着新类的发现，其中一些将在这个过程中被初始化，这取决于配置。在下一步，堆被快照，并检查哪些类型需要在运行时可用。初始化和堆快照可能会导致新的类型被发现，在这种情况下，这个过程会被重复。当达到一个固定点时，这个过程就会停止，也就是当可达到的程序不再增长时。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1886
#, fuzzy
msgid "The compilation step is pretty straightforward, it simply compiles all the reachable code."
msgstr "编译步骤非常直接，它只是简单地编译所有可到达的代码。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1893
#, fuzzy
msgid "The time spent in analysis and compilation phases depends on how big the application is.  The bigger the application, the longer it takes to compile it.  However, there are certain features that can have an exponential effect.  For example, when registering types and methods for reflection access, the analysis can’t easily see what’s behind those types or methods, so it has to do more work to complete the analysis step."
msgstr "在分析和编译阶段所花费的时间取决于应用程序有多大。应用程序越大，编译的时间就越长。然而，有一些特性会产生指数级的影响。例如，当注册类型和方法进行反射访问时，分析不容易看到这些类型或方法背后的东西，所以它必须做更多的工作来完成分析步骤。"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:1894
#, fuzzy, no-wrap
msgid "I get a `AnalysisError\\$ParsingError` when building a native executable due to an `UnresolvedElementException`, what can I do?"
msgstr "我在构建本地可执行文件时得到一个 `OutOfMemoryError` (OOME)，我可以做什么？"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1899
#, fuzzy
msgid "When building a native executable Quarkus requires all classes being referenced by the code, no matter if they are build-time or run-time initialized, to be present in the classpath.  This way it ensures that there will be no crashes at runtime due to potential `NoClassDefFoundError` exceptions.  To achieve this it makes use of GraalVM's `--link-at-build-time` parameter:"
msgstr "当构建本地可执行文件时，Quarkus要求所有被代码引用的类，无论它们是构建时还是运行时初始化的，都必须存在于classpath中。这样，它就能确保在运行时不会因为潜在的 `NoClassDefFoundError` 异常而崩溃。为了实现这一点，它利用了GraalVM的 `--link-at-build-time` 参数。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1905
#, no-wrap
msgid ""
"--link-at-build-time  require types to be fully defined at image build-time. If used\n"
"                      without args, all classes in scope of the option are required to\n"
"                      be fully defined.\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1909
#, fuzzy
msgid "This, however, may result in an `AnalysisError\\$ParsingError` due to an `UnresolvedElementException` at build time.  This is often caused because the application references a class from an https://maven.apache.org/guides/introduction/introduction-to-optional-and-excludes-dependencies.html#optional-dependencies[optional dependency]."
msgstr "然而，这可能会导致 `AnalysisError\\$ParsingError` ，原因是在构建时出现了 `UnresolvedElementException` 。这通常是因为应用程序引用了一个来自 link:https://maven.apache.org/guides/introduction/introduction-to-optional-and-excludes-dependencies.html#optional-dependencies[可选依赖关系的] 类。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1911
#, fuzzy
msgid "If you have access to the source code responsible for the reference to the missing dependency and can alter it, you should consider one of the following:"
msgstr "如果你可以访问负责引用缺失依赖关系的源代码，并且可以改变它，你应该考虑以下方法之一。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1913
#, fuzzy
msgid "Remove the reference if it's not actually necessary."
msgstr "如果实际上没有必要，就把参考文献删除。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1914
#, fuzzy
msgid "Move the affected code in a sub-module and make the dependency non-optional (as is the best practice)."
msgstr "将受影响的代码移到一个子模块中，并使依赖性成为非选择性的（这是最佳做法）。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1915
#, fuzzy
msgid "Make the dependency non-optional."
msgstr "使依赖性成为非选择性的。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1917
#, fuzzy
msgid "In the unfortunate case where the reference causing the issue is made by a 3rd party library, that you cannot modify, you should consider one of the following:"
msgstr "在不幸的情况下，如果导致该问题的引用是由第三方库提供的，而你又不能修改，你应该考虑以下情况之一。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1919
#, fuzzy
msgid "Use a class/method substitution to remove the said reference."
msgstr "使用类/方法替换来删除上述引用。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1920
#, fuzzy
msgid "Add the optional dependency as a non-optional dependency of your project."
msgstr "将可选的依赖关系作为你的项目的非可选依赖关系。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1924
#, fuzzy
msgid "Note that although option (1) is the best choice performance wise, as it minimizes the applications footprint,it might not be trivial to implement.  To make matters worse, it's also not easy to maintain as it is tightly coupled to the 3rd party library implementation.  Option (2) is a straight forward alternative to work around the issue, but comes at the cost of including possibly never invoked code in the resulting native executable."
msgstr "请注意，尽管选项（1）在性能上是最好的选择，因为它最大限度地减少了应用程序的占用空间，但它可能不容易实现。更糟糕的是，它也不容易维护，因为它与第三方库的实现紧密相连。选项（2）是解决这个问题的一个直接的选择，但代价是在产生的本地可执行文件中包括可能从未调用过的代码。"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:1925
#, fuzzy, no-wrap
msgid "I get an `OutOfMemoryError` (OOME) building native executables, what can I do?"
msgstr "我在构建本地可执行文件时得到一个 `OutOfMemoryError` (OOME)，我可以做什么？"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1937
#, fuzzy
msgid "Building native executables is not only time consuming, but it also takes a fair amount of memory.  For example, building a sample native Quarkus Jakarta Persistence application such as the Hibernate ORM quickstart, may use 6GB to 8GB resident set size in memory.  A big chunk of this memory is Java heap, but extra memory is required for other aspects of the JVM that runs the native building process.  It is still possible to build such applications in environments that have total memory close to the limits, but to do that it is necessary to shrink the maximum heap size of the GraalVM native image process.  To do that, set a maximum heap size using the `quarkus.native.native-image-xmx` property.  For example, we can instruct GraalVM to use 5GB of maximum heap size by passing in `-Dquarkus.native.native-image-xmx=5g` in the command line."
msgstr "构建本地可执行文件不仅耗费时间，而且还需要相当多的内存。例如，构建一个本地Quarkus JPA应用样本，如Hibernate快速启动，可能会在内存中使用6GB到8GB的常驻集大小。这些内存的一大块是Java堆，但运行本地构建过程的JVM的其他方面也需要额外的内存。在总内存接近极限的环境中，仍然有可能构建这样的应用程序，但要做到这一点，就必须缩小GraalVM本地镜像进程的最大堆大小。要做到这一点，请使用 `quarkus.native.native-image-xmx` 属性设置一个最大堆大小。例如，我们可以通过在命令行中传递 `-Dquarkus.native.native-image-xmx=5g` ，指示GraalVM使用5GB的最大堆大小。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1940
#, fuzzy
msgid "Building native executables this way might have the side effect of requiring more time to complete.  This is due to garbage collection having to work harder for native image generation to have free space to do its job."
msgstr "以这种方式构建本地可执行文件可能会产生需要更多时间来完成的副作用。这是由于垃圾收集必须更努力地工作，以使本地图像生成有自由空间来完成其工作。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1943
#, fuzzy
msgid "Note that typical applications are likely bigger than quickstarts, so the memory requirements will also likely be higher."
msgstr "请注意，典型的应用程序可能比快速启动大，所以内存要求也可能更高。"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:1944
#, fuzzy, no-wrap
msgid "Why is runtime performance of a native executable inferior compared to JVM mode?"
msgstr "为什么本地可执行文件的运行时性能比JVM模式要差？"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1949
#, fuzzy
msgid "As with most things in life there are some trade-offs involved when choosing native compilation over JVM mode.  So depending on the application the runtime performance of a native application might be slower compared to JVM mode, though that’s not always the case."
msgstr "与生活中的大多数事情一样，在选择本地编译而不是JVM模式时，也会涉及一些交易。因此，根据不同的应用程序，本地应用程序的运行时性能可能会比JVM模式慢，尽管这并不总是如此。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1955
#, fuzzy
msgid "JVM execution of an application includes runtime optimization of the code that profits from profile information built up during execution.  That includes the opportunities to inline a lot more of the code, locate hot code on direct paths (i.e. ensure better instruction cache locality)  and cut out a lot of the code on cold paths (on the JVM a lot of code does not get compiled until something tries to execute it -- it is replaced with a trap that causes deoptimization and recompilation).  Removal of cold paths provides many more optimization opportunities than are available for ahead of time compilation because it significantly reduces the branch complexity and combinatorial logic of the smaller amount of hot code that is compiled."
msgstr "应用程序的JVM执行包括代码的运行时优化，这些代码从执行过程中建立的配置文件信息中获益。这包括有机会内联更多的代码，在直接路径上定位热代码（即确保更好的指令缓存定位），并在冷路径上切出大量的代码（在JVM上，很多代码不会被编译，直到有东西试图执行它，它被替换成一个陷阱，导致去优化和重新编译）。去除冷路径提供了比提前编译更多的优化机会，因为它大大降低了被编译的少量热代码的分支复杂性和组合逻辑。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1958
#, fuzzy
msgid "By contrast, native executable compilation has to cater for all possible execution paths when it compiles code offline since it does not know which are the hot or cold paths and cannot use the trick of planting a trap and recompiling if it is hit. For the same reason it cannot load the dice to ensure that code cache conflicts are minimized by co-locating hot paths adjacent.  Native executable generation is able to remove some code because of the closed world hypothesis but that is often not enough to make up for all the benefits that profiling and runtime deopt & recompile provides to the JVM JIT compiler."
msgstr "相比之下，本地可执行编译在离线编译代码时必须照顾到所有可能的执行路径，因为它不知道哪些是热路径，哪些是冷路径，也不能使用埋下陷阱并在被击中时重新编译的技巧。出于同样的原因，它不能加载骰子，以确保通过将热路径相邻的共同定位，将代码缓存冲突降到最低。由于封闭世界的假设，本地可执行文件的生成能够删除一些代码，但这往往不足以弥补剖析和运行时deopt & recompile给JVM JIT编译器带来的所有好处。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1960
#, fuzzy
msgid "Note, however, that there is a price you pay for that potentially higher JVM speed, and that price is in increased resource usage (both CPU and memory) and startup time because:"
msgstr "然而，请注意，你要为这种潜在的更高的JVM速度付出代价，这种代价就是增加资源的使用（包括CPU和内存）和启动时间，因为。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1962
#, fuzzy
msgid "it takes some time before the JIT kicks in and fully optimizes the code."
msgstr "在JIT启动并完全优化代码之前，需要一些时间。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1963
#, fuzzy
msgid "the JIT compiler consumes resources that could be utilized by the application."
msgstr "JIT编译器消耗了本可由应用程序使用的资源。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1964
#, fuzzy
msgid "the JVM has to retain a lot more metadata and compiler/profiler data to support the better optimizations that it can offer."
msgstr "JVM必须保留更多的元数据和编译器/profiler数据，以支持它所能提供的更好的优化。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1966
#, fuzzy
msgid "The reason for 1) is that code needs to be run interpreted for some time and, possibly, to be compiled several times before all potential optimizations are realized to ensure that:"
msgstr "1）的原因是，代码需要被解释运行一段时间，而且可能在所有潜在的优化实现之前，需要被编译几次，以确保。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1968
#, fuzzy
msgid "it’s worth compiling that code path, i.e. it’s being executed enough times, and that"
msgstr "值得对该代码路径进行编译，即它被执行了足够多的次数，并且"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1969
#, fuzzy
msgid "we have enough profiling data to perform meaningful optimizations."
msgstr "我们有足够的分析数据来进行有意义的优化。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1972
#, fuzzy
msgid "An implication of 1) is that for small, short-lived applications a native executable may well be a better bet.  Although the compiled code is not as well optimized it is available straight away."
msgstr "1）的含义是，对于小型、短期的应用程序，本地可执行文件可能是一个更好的选择。尽管编译后的代码没有得到很好的优化，但可以直接使用。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1975
#, fuzzy
msgid "The reason for 2) is that the JVM is essentially running the compiler at runtime in parallel with the application itself.  In the case of native executables the compiler is run ahead of time removing the need to run the compiler in parallel with the application."
msgstr "2）的原因是，JVM本质上是在运行时与应用程序本身并行地运行编译器。在本地可执行文件的情况下，编译器是提前运行的，不需要与应用程序并行运行编译器。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1984
#, fuzzy
msgid "There are several reasons for 3). The JVM does not have a closed world assumption.  So, it has to be able to recompile code if loading of new classes implies that it needs to revise optimistic assumptions made at compile time.  For example, if an interface has only one implementation it can make a call jump directly to that code.  However, in the case where a second implementation class is loaded the call site needs to be patched to test the type of the receiver instance and jump to the code that belongs to its class.  Supporting optimizations like this one requires keeping track of a lot more details of the class base than a native executable, including recording the full class and interface hierarchy, details of which methods override other methods, all method bytecode etc.  In a native executable most of the details of class structure and bytecode can be ignored at run time."
msgstr "3）有几个原因。JVM没有一个封闭的世界假设。因此，如果加载新的类意味着它需要修改在编译时的乐观假设，它必须能够重新编译代码。例如，如果一个接口只有一个实现，它可以使调用直接跳到该代码。然而，在第二个实现类被加载的情况下，需要对调用站点进行修补，以测试接收器实例的类型，并跳转到属于其类的代码。支持像这样的优化需要跟踪比本地可执行文件更多的类基细节，包括记录完整的类和接口层次结构，哪些方法覆盖其他方法的细节，所有方法的字节码等。在本地可执行文件中，类结构和字节码的大部分细节在运行时可以被忽略。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1989
#, fuzzy
msgid "The JVM also has to cope with changes to the class base or execution profiles that result in a thread going down a previously cold path.  At that point the JVM has to jump out of the compiled code into the interpreter and recompile the code to cater for a new execution profile that includes the previously cold path.  That requires keeping runtime info that allow a compiled stack frame to be replaced with one or more interpreter frames.  It also requires runtime extensible profile counters to be allocated and updated to track what has or has not been executed."
msgstr "JVM还必须应对类库或执行配置文件的变化，这些变化会导致线程走到以前的冷门路径。在这一点上，JVM必须从编译的代码中跳出，进入解释器，重新编译代码，以满足新的执行配置文件，包括以前的冷门路径。这就需要保留运行时信息，允许用一个或多个解释器框架来替换已编译的堆栈框架。它还需要分配和更新运行时可扩展配置文件计数器，以跟踪已经或尚未执行的内容。"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:1990
#, fuzzy, no-wrap
msgid "Why are native executables “big”?"
msgstr "为什么本地可执行文件是 \"大 \"的？"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1993
#, fuzzy
msgid "This can be attributed to a number of different reasons:"
msgstr "这可以归因于一些不同的原因。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1999
#, fuzzy
msgid "Native executables include not only the application code but also, library code, and JDK code.  As a result a more fair comparison would be to compare the native executable’s size with the size of the application, plus the size of the libraries it uses, plus the size of the JDK.  Especially the JDK part is not negligible even in simple applications like HelloWorld.  To get a glance on what is being pulled in the image one can use `-H:+PrintUniverse` when building the native executable."
msgstr "本地可执行文件不仅包括应用程序代码，还包括库代码和JDK代码。因此，更公平的比较是将本地可执行文件的大小与应用程序的大小，加上它使用的库的大小，再加上JDK的大小进行比较。特别是JDK的部分，即使在HelloWorld这样简单的应用程序中也是不可忽视的。为了了解图像中的内容，可以在构建本地可执行文件时使用 `-H:+PrintUniverse` 。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2005
#, fuzzy
msgid "Some features are always included in a native executable even though they might never be actually used at run time.  An example of such a feature is garbage collection.  At compile time we can’t be sure whether an application will need to run garbage collection at run time, so garbage collection is always included in native executables increasing their size even if not necessary.  Native executable generation relies on static code analysis to identify which code paths are reachable, and static code analysis can be imprecise leading to more code getting into the image than what’s actually needed."
msgstr "有些功能总是包含在本地可执行文件中，尽管它们在运行时可能从未被实际使用。这种特性的一个例子是垃圾收集。在编译时，我们无法确定一个应用程序在运行时是否需要运行垃圾收集，所以垃圾收集总是包含在本地可执行文件中，即使没有必要，也会增加其大小。本地可执行文件的生成依赖于静态代码分析，以确定哪些代码路径是可以到达的，而静态代码分析可能不精确，导致更多的代码进入图像，而不是实际需要的。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2008
#, fuzzy
msgid "There is a https://github.com/oracle/graal/issues/287[GraalVM upstream issue] with some interesting discussions about that topic."
msgstr "有一个 link:https://github.com/oracle/graal/issues/287[GraalVM的上游问题] ，其中有一些关于该主题的有趣讨论。"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:2009
#, fuzzy, no-wrap
msgid "What version of Mandrel was used to generate a binary?"
msgstr "使用哪个版本的Mandrel来生成二进制文件？"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2012
#, fuzzy
msgid "One can see which Mandrel version was used to generate a binary by inspecting the binary as follows:"
msgstr "人们可以通过检查二进制文件来了解哪个Mandrel版本被用来生成二进制文件，如下所示。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2017
#, no-wrap
msgid ""
"$ strings target/debugging-native-1.0.0-SNAPSHOT-runner | grep GraalVM\n"
"com.oracle.svm.core.VM=GraalVM 22.0.0.2-Final Java 11 Mandrel Distribution\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/native-reference.adoc:2019
#, fuzzy, no-wrap
msgid "How do I enable GC logging in native executables?"
msgstr "如何在本地可执行文件中启用GC日志？"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2022
#, fuzzy
msgid "See xref:gc-logging[Native Memory Management GC Logging section] for details."
msgstr "详见 link:#gc-logging[Native Memory Management GC Logging部分] 。"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:2024
#, fuzzy, no-wrap
msgid "Can I get a heap dump of a native executable? e.g. if it runs out of memory"
msgstr "我可以得到一个本地可执行程序的堆转储吗？ 例如，如果它的内存用完了"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2029
#, fuzzy
msgid "Starting with GraalVM 22.2.0 it is possible to create heap dumps upon request, e.g. `kill -SIGUSR1 <pid>`.  Support for dumping the heap dump upon an out of memory error will follow up."
msgstr "从GraalVM 22.2.0开始，将可以根据要求进行堆转储，例如 `kill -SIGUSR1 <pid>` 。后续将支持在发生内存不足错误时转储堆数据。"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:2030
#, fuzzy, no-wrap
msgid "Can I build and run this examples outside a container in Linux?"
msgstr "我可以在Linux的容器外构建和运行这个例子吗？"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2036
#, fuzzy
msgid "Yes you can.  In fact, debugging native executables on a Linux bare metal box offers the best possible experience.  In this kind of environments, root access is not needed except to install packages required to run some debug steps, or to enable `perf` to gather events at the kernel."
msgstr "是的，你可以。事实上，在Linux裸机上调试本地可执行文件提供了最好的体验。在这种环境下，除了安装运行一些调试步骤所需的软件包，或者启用 `perf` ，以收集内核的事件，不需要root权限。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2038
#, fuzzy
msgid "These are the packages you'll need on your Linux environment to run through the different debugging sections:"
msgstr "这些是你在Linux环境下运行不同调试部分所需的软件包。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2045
#, no-wrap
msgid ""
"# dnf (rpm-based)\n"
"sudo dnf install binutils gdb perf perl-open\n"
"# Debian-based distributions:\n"
"sudo apt install binutils gdb perf\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/native-reference.adoc:2047
#, fuzzy, no-wrap
msgid "Generating flame graphs is slow, or produces errors, what can I do?"
msgstr "生成火焰图的速度很慢，或者产生错误，我可以做什么？"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2051
#, fuzzy
msgid "There are multiple ways in which a native executable produced by Mandrel can be profiled.  All the methods require you to pass in the `-H:-DeleteLocalSymbols` option."
msgstr "有多种方法可以对由Mandrel产生的本地可执行文件进行分析。所有的方法都需要你传入 `-H:-DeleteLocalSymbols` 选项。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2055
#, fuzzy
msgid "The method shown in this reference guide generates a binary with DWARF debug information, runs it via `perf record` and then uses `perf script` and flame graph tooling to generate the flamegraphs.  However, the `perf script` post-processing step done on this binary can appear to be slow or can show some DWARF errors."
msgstr "本参考指南中显示的方法是生成一个带有DWARF调试信息的二进制文件，通过 `perf record` ，然后使用 `perf script` 和火焰图工具来生成火焰图。然而，在这个二进制文件上做的 `perf script` 后处理步骤可能会显得很慢，或者会显示一些DWARF错误。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2060
#, fuzzy
msgid "An alternative method to generate flame graphs is to pass in `-H:+PreserveFramePointer` when generating the native executable instead of generating the DWARF debug information.  It instructs the binary to use an extra register for the frame pointer.  This enables `perf` to do stack walking to profile the runtime behaviour.  To generate the native executable using these flags, do the following:"
msgstr "另一种生成火焰图的方法是在生成本地可执行文件时传入 `-H:+PreserveFramePointer` ，而不是生成DWARF调试信息。它指示二进制文件使用一个额外的寄存器作为框架指针。这使得 `perf` 做堆栈行走，以剖析运行时的行为。要使用这些标志生成本地可执行文件，请执行以下操作。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2065
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative\n"
"    -Dquarkus.native.additional-build-args=-H:+PreserveFramePointer,-H:-DeleteLocalSymbols\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2068
#, fuzzy
msgid "To get runtime profiling information out of the native executable, simply do:"
msgstr "要从本地可执行文件中获得运行时剖析信息，只需做以下工作。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2076
#, fuzzy
msgid "The recommended method for generating runtime profiling information is using the debug information rather than generating a binary that preserves the frame pointer.  This is because adding debug information to the native executable build process has no negative runtime performance whereas preserving the frame pointer does."
msgstr "生成运行时剖析信息的推荐方法是使用调试信息，而不是生成一个保留帧指针的二进制文件。这是因为在本地可执行文件的构建过程中添加调试信息不会对运行时性能产生负面影响，而保留帧指针则会。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2082
#, fuzzy
msgid "DWARF debug info is generated in a separate file and can even be omitted in the default deployment and only be transferred and used on demand, for profiling or debugging purposes.  Furthermore, the presence of debug info enables `perf` to show us the relevant source code lines as well, hence it does not bloat the native executable itself.  To do that, simply call `perf report` with an extra parameter to show source code lines:"
msgstr "DWARF调试信息在一个单独的文件中生成，甚至可以在默认部署中省略，只在需要时传输和使用，用于分析或调试目的。此外，调试信息的存在使 `perf` ，也能向我们展示相关的源代码行，因此它不会使本地可执行文件本身臃肿。要做到这一点，只需调用 `perf report` ，并增加一个参数来显示源代码行。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2092
#, no-wrap
msgid ""
"perf report --stdio -F+srcline\n"
"...\n"
"83.69%     0.00%  GreetingResource.java:20 ...\n"
"...\n"
"83.69%     0.00%  AbstractStringBuilder.java:1025 ...\n"
"...\n"
"83.69%     0.00%  ArraycopySnippets.java:95 ...\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2098
#, fuzzy
msgid "The performance penalty of preserving the frame pointer is due to using the extra register for stack walking, particularly in `x86_64` compared to `aarch64` where there are fewer registers available.  Using this extra register reduces the number of registers that are available for other work, which can lead to performance penalties."
msgstr "保留帧指针的性能惩罚是由于使用额外的寄存器进行堆栈行走，特别是在 `x86_64` ，相比之下 `aarch64` ，可用的寄存器较少。使用这个额外的寄存器减少了可用于其他工作的寄存器的数量，这可能导致性能上的损失。"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:2099
#, fuzzy, no-wrap
msgid "I think I’ve found a bug in native-image, how can I debug it with the IDE?"
msgstr "我想我在native-image中发现了一个bug，我怎样才能用IDE来调试它？"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2103
#, fuzzy
msgid "Although it is possible to remote debug processes within containers, it might be easier to step-by-step debug native-image by installing Mandrel locally and adding it to the path of the shell process."
msgstr "虽然可以在容器内远程调试进程，但通过在本地安装Mandrel并将其添加到shell进程的路径中，逐步调试native-image可能更容易。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2108
#, fuzzy
msgid "Native executable generation is the result of two Java processes that are executed sequentially.  The first process is very short and its main job is to set things up for the second process.  The second process is the one that takes care of most of the work.  The steps to debug one process or the other vary slightly."
msgstr "本地可执行文件的生成是两个Java进程依次执行的结果。第一个进程非常短，其主要工作是为第二个进程做准备。第二个过程是负责大部分工作的过程。调试一个进程或另一个进程的步骤略有不同。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2113
#, fuzzy
msgid "Let’s discuss first how to debug the second process, which is the one you most likely to want to debug.  The starting point for the second process is the `com.oracle.svm.hosted.NativeImageGeneratorRunner` class.  To debug this process, simply add `--debug-attach=*:8000` as an additional build time argument:"
msgstr "我们先讨论如何调试第二个过程，这是你最有可能想调试的过程。第二个过程的起点是 `com.oracle.svm.hosted.NativeImageGeneratorRunner` 类。要调试这个过程，只需添加 `--debug-attach=*:8000` 作为额外的构建时间参数。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2118
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.additional-build-args=--debug-attach=*:8000\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2124
#, fuzzy
msgid "The starting point for the first process is the `com.oracle.svm.driver.NativeImages` class.  In GraalVM CE distributions, this first process is a binary, so debugging it in the traditional way with a Java IDE is not possible.  However, Mandrel distributions (or locally built GraalVM CE instances) keep this as a normal Java process, so you can remote debug this process by adding the `--vm.agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=*:8000` as an additional build argument, e.g."
msgstr "第一个进程的起点是 `com.oracle.svm.driver.NativeImages` 类。在GraalVM CE发行版中，这个第一进程是一个二进制文件，所以不可能用Java IDE的传统方式来调试它。然而，Mandrel发行版（或本地构建的GraalVM CE实例）将其作为一个正常的Java进程，所以你可以通过添加 `--vm.agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=*:8000` 作为额外的构建参数来远程调试这个进程，例如："

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2129
#, no-wrap
msgid ""
"$ ./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.additional-build-args=--vm.agentlib:jdwp=transport=dt_socket\\\\,server=y\\\\,suspend=y\\\\,address=*:8000\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/native-reference.adoc:2131
#, fuzzy, no-wrap
msgid "Can I use JFR/JMC to debug or profile native binaries?"
msgstr "我可以使用JFR/JMC来调试或剖析本地二进制文件吗？"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2139
#, fuzzy
msgid "https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/about.htm#JFRUH170[Java Flight Recorder (JFR)] and https://www.oracle.com/java/technologies/jdk-mission-control.html[JDK Mission Control (JMC)] can be used to profile native binaries since GraalVM CE 21.2.0.  However, JFR in GraalVM is currently significantly limited in capabilities compared to HotSpot.  The custom event API is fully supported, but many VM level features are unavailable.  They will be added in future releases. Current limitations are:"
msgstr "自GraalVM CE 21.2.0以来， link:https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/about.htm#JFRUH170[Java Flight Recorder（JFR] ）和 link:https://www.oracle.com/java/technologies/jdk-mission-control.html[JDK Mission Control（JMC）] 可以用来对本地二进制文件进行剖析。 然而，与HotSpot相比，GraalVM中的JFR目前在能力上受到很大限制。自定义事件API被完全支持，但许多虚拟机级别的功能是不可用的。它们将在未来的版本中被添加。目前的限制是。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2141
#, fuzzy
msgid "Minimal VM level events"
msgstr "最小的虚拟机级别事件"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2142
#, fuzzy
msgid "No old object sampling"
msgstr "没有旧对象取样"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2143
#, fuzzy
msgid "No stacktrace tracing"
msgstr "没有堆栈痕迹跟踪"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2144
#, fuzzy
msgid "No Streaming API for JDK 17"
msgstr "没有JDK 17的流媒体API"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2147
#, fuzzy
msgid "To use JFR add the application property: `-Dquarkus.native.enable-vm-inspection=true`.  E.g."
msgstr "为了使用JFR，添加应用程序属性： `-Dquarkus.native.enable-vm-inspection=true` 。例如"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2153
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative -Dquarkus.native.container-build=true \\\n"
"    -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel-builder-image:{mandrel-flavor} \\\n"
"    -Dquarkus.native.enable-vm-inspection=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2156
#, fuzzy
msgid "Once the image is compiled, enable and start JFR via runtime flags: `-XX:+FlightRecorder` and `-XX:StartFlightRecording`. For example:"
msgstr "一旦图像被编译，通过运行时标志启用和启动JFR： `-XX:+FlightRecorder` 和 `-XX:StartFlightRecording` 。比如说。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2162
#, no-wrap
msgid ""
"./target/debugging-native-1.0.0-SNAPSHOT-runner \\\n"
"    -XX:+FlightRecorder \\\n"
"    -XX:StartFlightRecording=\"filename=recording.jfr\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2165
#, fuzzy
msgid "For more details on using JFR, see https://www.graalvm.org/{graalvm-version}/reference-manual/native-image/debugging-and-diagnostics/JFR/[here]."
msgstr "关于使用JFR的更多细节，请看 link:https://www.graalvm.org/reference-manual/native-image/JFR[这里] 。"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:2166
#, fuzzy, no-wrap
msgid "How can we troubleshoot performance problems only reproducible in production?"
msgstr "我们怎样才能排除只有在生产中才能重现的性能问题？"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2176
#, fuzzy
msgid "In this situation, switching to JVM mode would be the best thing to try first.  If the performance issues continue after switching to JVM mode, you can use more established and mature tooling to figure out the root cause.  If the performance issue is limited to native mode only, you might not be able to use `perf`, so JFR is the only way to gather any information in this situation.  As JFR support for native expands, the ability to detect root causes of performance issues directly in production will improve."
msgstr "在这种情况下，切换到JVM模式将是首先尝试的最好办法。如果切换到JVM模式后性能问题仍然存在，你可以使用更成熟的工具来找出根本原因。如果性能问题只限于本地模式，你可能无法使用 `perf` ，所以JFR是这种情况下收集任何信息的唯一途径。随着JFR对本地支持的扩大，在生产中直接检测性能问题的根源的能力将得到提高。"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:2177
#, fuzzy, no-wrap
msgid "What information helps most debug issues that happen either at build-time or run-time?"
msgstr "哪些信息最有助于调试在构建时或运行时发生的问题？"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2181
#, fuzzy
msgid "To fix classpath, class initialization or forbidden API errors at build time it's best to use xref:native-reports[build time reports] to understand the closed world universe.  A complete picture of the universe, along with the relationships between the different classes and methods will help uncover and fix most of the issues."
msgstr "要在构建时修复classpath、类初始化或禁止的API错误，最好是使用 link:#native-reports[构建时报告] 来了解封闭世界的宇宙。对宇宙的完整描述，以及不同的类和方法之间的关系，将有助于发现和解决大多数问题。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2187
msgid "To fix runtime native specific errors, it's best to have xref:debug-info[debug info builds] of the native executables around, so that `gdb` can be hooked up quickly to debug the issue.  If you also add local symbols to the debug info builds, you will obtain precise xref:profiling[profiling information] as well."
msgstr ""

#. type: Title ===
#: upstream/_guides/native-reference.adoc:2188
#, no-wrap
msgid "Build stalled for minutes, barely using any CPU"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2191
msgid "It might so happen that the build gets stalled and even ends up with:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2195
#, no-wrap
msgid "Image generator watchdog detected no activity.\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2198
msgid "One of the possible explanations could be a lack of entropy, e.g. on an entropy constrained VM, if such a source is needed as it is the case with Bouncycastle at build time."
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2200
msgid "One can check the available entropy on a Linux system with:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2204
#, no-wrap
msgid "$ cat /proc/sys/kernel/random/entropy_avail\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2206
msgid "If the amount is not in hundreds, it could be a problem. A possible workaround is to compromise, acceptable for testing, and set:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2209
#, no-wrap
msgid "export JAVA_OPTS=-Djava.security.egd=/dev/urandom\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2210
msgid "The proper solution is to increase the entropy available for the system. That is specific for each OS vendor and virtualization solution though."
msgstr ""

#, fuzzy
#~ msgid "Executing the native executable with `-XX:PrintFlags=` prints a list of flags that can be passed to native executables.  For various levels of GC logging one may use:"
#~ msgstr "用 `-XX:PrintFlags=` 执行本地可执行文件，会打印出一个可以传递给本地可执行文件的标志列表。对于各种级别的GC日志，可以使用。"

#, fuzzy
#~ msgid "Since Mandrel 21.3.0.0, the call tree is also reported as a group of CSV files.  The CSV output can be enabled by adding `-H:PrintAnalysisCallTreeType=CSV` to the additional native arguments. E.g."
#~ msgstr "从Mandrel 21.3.0.0开始，调用树也被报告为一组CSV文件。CSV输出可以通过在额外的本地参数中添加 `-H:PrintAnalysisCallTreeType=CSV` 来启用。例如"

#, fuzzy
#~ msgid "These can in turn be imported into a graph database, such as Neo4j, to inspect them more easily and run queries against the call tree.  Let’s see this in action."
#~ msgstr "这些信息又可以被导入图数据库，如Neo4j，以便更容易地检查它们，并对调用树运行查询。让我们来看看这个动作。"

#, fuzzy
#~ msgid "Unfortunately generating heap dumps in hprof format, which can be opened by tools such as VisualVM or Eclipse MAT, can only be achieved with https://www.graalvm.org/reference-manual/native-image/NativeImageHeapdump[GraalVM Enterprise Edition].  Mandrel, which is based on the GraalVM Community Edition, does not have this capability."
#~ msgstr "不幸的是，生成hprof格式的堆转储，可以被VisualVM或Eclipse MAT等工具打开，这只能通过 link:https://www.graalvm.org/reference-manual/native-image/NativeImageHeapdump[GraalVM企业版] 实现。基于GraalVM社区版的Mandrel不具备这种能力。"

#, fuzzy
#~ msgid "Although Mandrel can generate debug symbols and these contain a fair amount of information about object layouts, including what is a pointer field vs a primitive field, this information cannot be used as is to detect memory leaks or find dominator objects.  This is because it has no idea what constitutes a root pointer nor how to recursively trace pointers from those roots."
#~ msgstr "尽管Mandrel可以生成调试符号，并且这些符号包含了相当多的关于对象布局的信息，包括什么是指针字段与基元字段，但这些信息不能被用来检测内存泄漏或找到支配者对象。这是因为它不知道什么是根指针，也不知道如何从这些根上递归追踪指针。"
